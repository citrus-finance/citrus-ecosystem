{
  "language": "Solidity",
  "sources": {
    "contracts/rari-fuse/src/core/BaseJumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Logic for Compound's JumpRateModel Contract V2.\n * @author Compound (modified by Dharma Labs, refactored by Arr00)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\ncontract BaseJumpRateModelV2 {\n    using SafeMath for uint256;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink\n    );\n\n    /**\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n    address public owner;\n\n    /**\n     * @notice The approximate number of seconds per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 31536000; // 86400 seconds/day * 365 days/year\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_\n    ) internal {\n        owner = owner_;\n\n        updateJumpRateModelInternal(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_\n        );\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n\n        updateJumpRateModelInternal(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_\n        );\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(\n                baseRatePerBlock\n            );\n            uint256 excessUtil = util.sub(kink);\n            return\n                excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(\n                    normalRate\n                );\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(\n            reserveFactorMantissa\n        );\n        uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return\n            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModelInternal(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(\n            blocksPerYear.mul(kink_)\n        );\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n        kink = kink_;\n\n        emit NewInterestParams(\n            baseRatePerBlock,\n            multiplierPerBlock,\n            jumpMultiplierPerBlock,\n            kink\n        );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        uint256 c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (MathError, uint256) {\n        (MathError err0, uint256 sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CDaiDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CErc20Delegate.sol\";\n\n/**\n * @title Compound's CDai Contract\n * @notice CToken which wraps Multi-Collateral DAI\n * @author Compound\n */\ncontract CDaiDelegate is CErc20Delegate {\n    /**\n     * @notice DAI adapter address\n     */\n    address public daiJoinAddress;\n\n    /**\n     * @notice DAI Savings Rate (DSR) pot address\n     */\n    address public potAddress;\n\n    /**\n     * @notice DAI vat address\n     */\n    address public vatAddress;\n\n    /**\n     * @notice Delegate interface to become the implementation\n     * @param data The encoded arguments for becoming\n     */\n    function _becomeImplementation(bytes calldata data) external {\n        require(\n            msg.sender == address(this) || hasAdminRights(),\n            \"only self or admin may call _becomeImplementation\"\n        );\n\n        // Decode data\n        (address daiJoinAddress_, address potAddress_) = abi.decode(\n            data,\n            (address, address)\n        );\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\n    }\n\n    /**\n     * @notice Explicit interface to become the implementation\n     * @param daiJoinAddress_ DAI adapter address\n     * @param potAddress_ DAI Savings Rate (DSR) pot address\n     */\n    function _becomeImplementation(address daiJoinAddress_, address potAddress_)\n        internal\n    {\n        // Get dai and vat and sanity check the underlying\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n        PotLike pot = PotLike(potAddress_);\n        GemLike dai = daiJoin.dai();\n        VatLike vat = daiJoin.vat();\n        require(\n            address(dai) == underlying,\n            \"DAI must be the same as underlying\"\n        );\n\n        // Remember the relevant addresses\n        daiJoinAddress = daiJoinAddress_;\n        potAddress = potAddress_;\n        vatAddress = address(vat);\n\n        // Approve moving our DAI into the vat through daiJoin\n        dai.approve(daiJoinAddress, uint256(-1));\n\n        // Approve the pot to transfer our funds within the vat\n        vat.hope(potAddress);\n        vat.hope(daiJoinAddress);\n\n        // Accumulate DSR interest -- must do this in order to doTransferIn\n        pot.drip();\n\n        // Transfer all cash in (doTransferIn does this regardless of amount)\n        doTransferIn(address(this), 0);\n    }\n\n    /**\n     * @notice Delegate interface to resign the implementation\n     */\n    function _resignImplementation() internal {\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        PotLike pot = PotLike(potAddress);\n        VatLike vat = VatLike(vatAddress);\n\n        // Accumulate interest\n        pot.drip();\n\n        // Calculate the total amount in the pot, and move it out\n        uint256 pie = pot.pie(address(this));\n        pot.exit(pie);\n\n        // Checks the actual balance of DAI in the vat after the pot exit\n        uint256 bal = vat.dai(address(this));\n\n        // Remove our whole balance\n        daiJoin.exit(address(this), bal / RAY);\n    }\n\n    /*** CToken Overrides ***/\n\n    /**\n     * @notice Accrues DSR then applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *      up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        // Accumulate DSR interest\n        PotLike(potAddress).drip();\n\n        // Accumulate CToken interest\n        return super.accrueInterest();\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        PotLike pot = PotLike(potAddress);\n        uint256 pie = pot.pie(address(this));\n        return mul(pot.chi(), pie) / RAY;\n    }\n\n    /**\n     * @notice Transfer the underlying to this contract and sweep into DSR pot\n     * @param from Address to transfer funds from\n     * @param amount Amount of underlying to transfer\n     * @return The actual amount that is transferred\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        // Perform the EIP-20 transfer in\n        EIP20Interface token = EIP20Interface(underlying);\n        require(\n            token.transferFrom(from, address(this), amount),\n            \"unexpected EIP-20 transfer in return\"\n        );\n\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        GemLike dai = GemLike(underlying);\n        PotLike pot = PotLike(potAddress);\n        VatLike vat = VatLike(vatAddress);\n\n        // Convert all our DAI to internal DAI in the vat\n        daiJoin.join(address(this), dai.balanceOf(address(this)));\n\n        // Checks the actual balance of DAI in the vat after the join\n        uint256 bal = vat.dai(address(this));\n\n        // Calculate the percentage increase to th pot for the entire vat, and move it in\n        // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\n        uint256 pie = bal / pot.chi();\n        pot.join(pie);\n\n        return amount;\n    }\n\n    /**\n     * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\n     * @param to Address to transfer funds to\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n        PotLike pot = PotLike(potAddress);\n\n        // Calculate the percentage decrease from the pot, and move that much out\n        // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\n        uint256 pie = add(mul(amount, RAY) / pot.chi(), 1);\n        pot.exit(pie);\n\n        daiJoin.exit(to, amount);\n    }\n\n    /*** Maker Internals ***/\n\n    uint256 constant RAY = 10**27;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"add-overflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n}\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n    function chi() external view returns (uint256);\n\n    function pie(address) external view returns (uint256);\n\n    function drip() external returns (uint256);\n\n    function join(uint256) external;\n\n    function exit(uint256) external;\n}\n\ninterface GemLike {\n    function approve(address, uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n}\n\ninterface VatLike {\n    function dai(address) external view returns (uint256);\n\n    function hope(address) external;\n}\n\ninterface DaiJoinLike {\n    function vat() external returns (VatLike);\n\n    function dai() external returns (GemLike);\n\n    function join(address, uint256) external payable;\n\n    function exit(address, uint256) external;\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n    function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            reserveFactorMantissa_,\n            adminFeeMantissa_\n        );\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint256 mintAmount) external returns (uint256) {\n        (uint256 err, ) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint256 borrowAmount) external returns (uint256) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint256 repayAmount) external returns (uint256) {\n        (uint256 err, ) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256)\n    {\n        (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowInternal(\n            borrower,\n            repayAmount,\n            cTokenCollateral\n        );\n        return err;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        uint256 balanceBefore = EIP20Interface(underlying).balanceOf(\n            address(this)\n        );\n        _callOptionalReturn(\n            abi.encodeWithSelector(\n                EIP20NonStandardInterface(underlying).transferFrom.selector,\n                from,\n                address(this),\n                amount\n            ),\n            \"TOKEN_TRANSFER_IN_FAILED\"\n        );\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = EIP20Interface(underlying).balanceOf(\n            address(this)\n        );\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        _callOptionalReturn(\n            abi.encodeWithSelector(\n                EIP20NonStandardInterface(underlying).transfer.selector,\n                to,\n                amount\n            ),\n            \"TOKEN_TRANSFER_OUT_FAILED\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _callOptionalReturn(bytes memory data, string memory errorMessage)\n        internal\n    {\n        bytes memory returndata = _functionCall(underlying, data, errorMessage);\n        if (returndata.length > 0)\n            require(abi.decode(returndata, (bool)), errorMessage);\n    }\n\n    /**\n     * @notice Admin call to delegate the votes of the COMP-like underlying\n     * @param compLikeDelegatee The address to delegate votes to\n     * @dev CTokens whose underlying are not CompLike should revert here\n     */\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\n        require(\n            hasAdminRights(),\n            \"only the admin may set the comp-like delegate\"\n        );\n        CompLike(underlying).delegate(compLikeDelegatee);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CErc20.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CDelegateInterface, CErc20 {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() public {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) external {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n        // Make sure admin storage is set up correctly\n        __admin = address(0);\n        __adminHasRights = false;\n        __fuseAdminHasRights = false;\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() internal {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationInternal(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) internal {\n        // Check whitelist\n        require(\n            fuseAdmin.cErc20DelegateWhitelist(\n                implementation,\n                implementation_,\n                allowResign\n            ),\n            \"!impl\"\n        );\n\n        // Call _resignImplementation internally (this delegate's code)\n        if (allowResign) _resignImplementation();\n\n        // Get old implementation\n        address oldImplementation = implementation;\n\n        // Store new implementation\n        implementation = implementation_;\n\n        // Call _becomeImplementation externally (delegating to new delegate's code)\n        _functionCall(\n            address(this),\n            abi.encodeWithSignature(\n                \"_becomeImplementation(bytes)\",\n                becomeImplementationData\n            ),\n            \"!become\"\n        );\n\n        // Emit event\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external {\n        // Check admin rights\n        require(hasAdminRights(), \"!admin\");\n\n        // Set implementation\n        _setImplementationInternal(\n            implementation_,\n            allowResign,\n            becomeImplementationData\n        );\n    }\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() external payable {\n        if (\n            msg.sender != address(this) &&\n            ComptrollerV3Storage(address(comptroller)).autoImplementation()\n        ) {\n            (\n                address latestCErc20Delegate,\n                bool allowResign,\n                bytes memory becomeImplementationData\n            ) = fuseAdmin.latestCErc20Delegate(implementation);\n            if (implementation != latestCErc20Delegate)\n                _setImplementationInternal(\n                    latestCErc20Delegate,\n                    allowResign,\n                    becomeImplementationData\n                );\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CTokenInterfaces.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CDelegationStorage {\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        address implementation_,\n        bytes memory becomeImplementationData,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,string,string,uint256,uint256)\",\n                underlying_,\n                comptroller_,\n                interestRateModel_,\n                name_,\n                symbol_,\n                reserveFactorMantissa_,\n                adminFeeMantissa_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"_setImplementationSafe(address,bool,bytes)\",\n                implementation_,\n                false,\n                becomeImplementationData\n            )\n        );\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    function() external payable {\n        // Cannot send value to CErc20Delegator\n        require(\n            msg.value == 0,\n            \"CErc20Delegator:fallback: cannot send value to fallback\"\n        );\n\n        // Check for automatic implementation\n        delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize)\n            }\n            default {\n                return(free_mem_ptr, returndatasize)\n            }\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20PluginDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../core/CErc20Delegate.sol\";\nimport \"./IERC4626.sol\";\nimport \"./EIP20Interface.sol\";\n\n/**\n * @title Rari's CErc20Plugin's Contract\n * @notice CToken which outsources token logic to a plugin\n * @author Joey Santoro\n *\n * CErc20PluginDelegate deposits and withdraws from a plugin conract\n * It is also capable of delegating reward functionality to a PluginRewardsDistributor\n */\ncontract CErc20PluginDelegate is CErc20Delegate {\n    /**\n     * @notice Plugin address\n     */\n    IERC4626 public plugin;\n\n    uint256 public constant PRECISION = 1e18;\n\n    /**\n     * @notice Delegate interface to become the implementation\n     * @param data The encoded arguments for becoming\n     */\n    function _becomeImplementation(bytes calldata data) external {\n        require(msg.sender == address(this) || hasAdminRights());\n\n        address _plugin = abi.decode(data, (address));\n\n        require(_plugin != address(0), \"0\");\n\n        if (\n            address(plugin) != address(0) &&\n            plugin.balanceOf(address(this)) != 0\n        ) {\n            plugin.redeem(\n                plugin.balanceOf(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        plugin = IERC4626(_plugin);\n\n        EIP20Interface(underlying).approve(_plugin, uint256(-1));\n\n        uint256 amount = EIP20Interface(underlying).balanceOf(address(this));\n        if (amount != 0) {\n            deposit(amount);\n        }\n    }\n\n    /*** CToken Overrides ***/\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of the plugin in terms of the underlying\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        return plugin.previewRedeem(plugin.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Transfer the underlying to the cToken and trigger a deposit\n     * @param from Address to transfer funds from\n     * @param amount Amount of underlying to transfer\n     * @return The actual amount that is transferred\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        // Perform the EIP-20 transfer in\n        require(\n            EIP20Interface(underlying).transferFrom(\n                from,\n                address(this),\n                amount\n            ),\n            \"send\"\n        );\n\n        deposit(amount);\n        return amount;\n    }\n\n    function deposit(uint256 amount) internal {\n        plugin.deposit(amount, address(this));\n    }\n\n    /**\n     * @notice Transfer the underlying from plugin to destination\n     * @param to Address to transfer funds to\n     * @param amount Amount of underlying to transfer\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        plugin.withdraw(amount, to, address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20PluginRewardsDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./CErc20PluginDelegate.sol\";\n\ncontract CErc20PluginRewardsDelegate is CErc20PluginDelegate {\n    /**\n     * @notice Delegate interface to become the implementation\n     * @param data The encoded arguments for becoming\n     */\n    function _becomeImplementation(bytes calldata data) external {\n        require(msg.sender == address(this) || hasAdminRights());\n\n        address _plugin = abi.decode(data, (address));\n\n        plugin = IERC4626(_plugin);\n        EIP20Interface(underlying).approve(_plugin, uint256(-1));\n    }\n\n    /// @notice A reward token claim function\n    /// to be overriden for use cases where rewardToken needs to be pulled in\n    function claim() external {}\n\n    /// @notice token approval function\n    function approve(address _token, address _spender) external {\n        require(hasAdminRights(), \"!admin\");\n        require(_token != underlying && _token != address(plugin), \"!\");\n\n        EIP20Interface(_token).approve(_spender, uint256(-1));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CErc20RewardsDelegate.sol": {
      "content": "pragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./CErc20Delegate.sol\";\nimport \"./EIP20Interface.sol\";\n\ncontract CErc20RewardsDelegate is CErc20Delegate {\n    /// @notice A reward token claim function\n    /// to be overriden for use cases where rewardToken needs to be pulled in\n    function claim() external {}\n\n    /// @notice token approval function\n    function approve(address _token, address _spender) external {\n        require(hasAdminRights(), \"!admin\");\n        require(_token != underlying, \"!underlying\");\n\n        EIP20Interface(_token).approve(_spender, uint256(-1));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @dev This contract should not to be deployed on its own; instead, deploy `CEtherDelegator` (proxy contract) and `CEtherDelegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CEther is CToken, CEtherInterface {\n    /**\n     * @notice Initialize the new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = 18;\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            reserveFactorMantissa_,\n            adminFeeMantissa_\n        );\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Reverts upon any failure\n     */\n    function mint() external payable {\n        (uint256 err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint256 borrowAmount) external returns (uint256) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n    function repayBorrow() external payable {\n        (uint256 err, ) = repayBorrowInternal(msg.value);\n        requireNoError(err, \"repayBorrow failed\");\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower the account with the debt being payed off\n     */\n    function repayBorrowBehalf(address borrower) external payable {\n        (uint256 err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n        requireNoError(err, \"repayBorrowBehalf failed\");\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     */\n    function liquidateBorrow(address borrower, CToken cTokenCollateral)\n        external\n        payable\n    {\n        (uint256 err, ) = liquidateBorrowInternal(\n            borrower,\n            msg.value,\n            cTokenCollateral\n        );\n        requireNoError(err, \"liquidateBorrow failed\");\n    }\n\n    /**\n     * @notice Send Ether to CEther to mint\n     */\n    function() external payable {\n        (uint256 err, ) = mintInternal(msg.value);\n        requireNoError(err, \"mint failed\");\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of Ether, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of Ether owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        (MathError err, uint256 startingBalance) = subUInt(\n            address(this).balance,\n            msg.value\n        );\n        require(err == MathError.NO_ERROR);\n        return startingBalance;\n    }\n\n    /**\n     * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the Ether\n     * @param amount Amount of Ether being sent\n     * @return The actual amount of Ether transferred\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        // Sanity checks\n        require(msg.sender == from, \"sender mismatch\");\n        require(msg.value == amount, \"value mismatch\");\n        return amount;\n    }\n\n    function doTransferOut(address payable to, uint256 amount) internal {\n        // Send the Ether and revert on failure\n        to.transfer(amount);\n    }\n\n    function requireNoError(uint256 errCode, string memory message)\n        internal\n        pure\n    {\n        if (errCode == uint256(Error.NO_ERROR)) {\n            return;\n        }\n\n        bytes memory fullMessage = new bytes(bytes(message).length + 7);\n        uint256 i;\n\n        for (i = 0; i < bytes(message).length; i++) {\n            fullMessage[i] = bytes(message)[i];\n        }\n\n        fullMessage[i + 0] = bytes1(uint8(32));\n        fullMessage[i + 1] = bytes1(uint8(40));\n        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 1000)));\n        fullMessage[i + 3] = bytes1(uint8(48 + ((errCode / 100) % 10)));\n        fullMessage[i + 4] = bytes1(uint8(48 + ((errCode / 10) % 10)));\n        fullMessage[i + 5] = bytes1(uint8(48 + (errCode % 10)));\n        fullMessage[i + 6] = bytes1(uint8(41));\n\n        require(errCode == uint256(Error.NO_ERROR), string(fullMessage));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CEtherDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's CEtherDelegate Contract\n * @notice CTokens which wrap Ether and are delegated to\n * @author Compound\n */\ncontract CEtherDelegate is CDelegateInterface, CEther {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() public {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) external {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n        // Make sure admin storage is set up correctly\n        __admin = address(0);\n        __adminHasRights = false;\n        __fuseAdminHasRights = false;\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() internal {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n    }\n\n    /**\n     * @dev Internal function to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationInternal(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) internal {\n        // Check whitelist\n        require(\n            fuseAdmin.cEtherDelegateWhitelist(\n                implementation,\n                implementation_,\n                allowResign\n            ),\n            \"!impl\"\n        );\n\n        // Call _resignImplementation internally (this delegate's code)\n        if (allowResign) _resignImplementation();\n\n        // Get old implementation\n        address oldImplementation = implementation;\n\n        // Store new implementation\n        implementation = implementation_;\n\n        // Call _becomeImplementation externally (delegating to new delegate's code)\n        _functionCall(\n            address(this),\n            abi.encodeWithSignature(\n                \"_becomeImplementation(bytes)\",\n                becomeImplementationData\n            ),\n            \"!become\"\n        );\n\n        // Emit event\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external {\n        // Check admin rights\n        require(hasAdminRights(), \"!admin\");\n\n        // Set implementation\n        _setImplementationInternal(\n            implementation_,\n            allowResign,\n            becomeImplementationData\n        );\n    }\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() external payable {\n        if (\n            msg.sender != address(this) &&\n            ComptrollerV3Storage(address(comptroller)).autoImplementation()\n        ) {\n            (\n                address latestCEtherDelegate,\n                bool allowResign,\n                bytes memory becomeImplementationData\n            ) = fuseAdmin.latestCEtherDelegate(implementation);\n            if (implementation != latestCEtherDelegate)\n                _setImplementationInternal(\n                    latestCEtherDelegate,\n                    allowResign,\n                    becomeImplementationData\n                );\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CEtherDelegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CTokenInterfaces.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Compound's CEtherDelegator Contract\n * @notice CTokens which wrap Ether and delegate to an implementation\n * @author Compound\n */\ncontract CEtherDelegator is CDelegationStorage {\n    /**\n     * @notice Construct a new CEther money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n    constructor(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        address implementation_,\n        bytes memory becomeImplementationData,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"initialize(address,address,string,string,uint256,uint256)\",\n                comptroller_,\n                interestRateModel_,\n                name_,\n                symbol_,\n                reserveFactorMantissa_,\n                adminFeeMantissa_\n            )\n        );\n\n        // New implementations always get set via the settor (post-initialize)\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                \"_setImplementationSafe(address,bool,bytes)\",\n                implementation_,\n                false,\n                becomeImplementationData\n            )\n        );\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    function() external payable {\n        // Check for automatic implementation\n        delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize)\n            }\n            default {\n                return(free_mem_ptr, returndatasize)\n            }\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./UnitrollerInterface.sol\";\nimport \"./RewardsDistributorDelegate.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is\n    ComptrollerV4Storage,\n    ComptrollerErrorReporter,\n    Exponential\n{\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(\n        uint256 oldCloseFactorMantissa,\n        uint256 newCloseFactorMantissa\n    );\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(\n        CToken cToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(\n        PriceOracle oldPriceOracle,\n        PriceOracle newPriceOracle\n    );\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when the whitelist enforcement is changed\n    event WhitelistEnforcementChanged(bool enforce);\n\n    /// @notice Emitted when auto implementations are toggled\n    event AutoImplementationsToggled(bool enabled);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(\n        address oldBorrowCapGuardian,\n        address newBorrowCapGuardian\n    );\n\n    /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n    event AddedRewardsDistributor(address rewardsDistributor);\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account)\n        external\n        view\n        returns (CToken[] memory)\n    {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken)\n        external\n        view\n        returns (bool)\n    {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens)\n        public\n        returns (uint256[] memory)\n    {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower)\n        internal\n        returns (Error)\n    {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken\n            .getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return\n                fail(\n                    Error.NONZERO_BORROW_BALANCE,\n                    FailureInfo.EXIT_MARKET_BALANCE_OWED\n                );\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(\n            cTokenAddress,\n            msg.sender,\n            tokensHeld\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.REJECTION,\n                    FailureInfo.EXIT_MARKET_REJECTION,\n                    allowed\n                );\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already in the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the accounts list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            uint256 borrowerIndex = borrowerIndexes[msg.sender];\n\n            // If borrower not at the end of the borrower array, replace it with the item at the end of the borrower array\n            if (borrowerIndex < allBorrowers.length - 1) {\n                address lastElement = allBorrowers[allBorrowers.length - 1];\n                allBorrowers[borrowerIndex] = lastElement; // Copy last item in list to location of item to be removed\n                borrowerIndexes[lastElement] = borrowerIndex; // Set borrower index of moved item to correct index\n            }\n\n            // Remove the last element of the borrower array\n            allBorrowers.length--; // Reduce length by 1\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure minter is whitelisted\n        if (enforceWhitelist && !whitelist[minter]) {\n            return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n        }\n\n        // Check supply cap\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n            uint256 totalFuseFees = CToken(cToken).totalFuseFees();\n            uint256 totalAdminFees = CToken(cToken).totalAdminFees();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)\n            (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(\n                totalCash,\n                totalBorrows,\n                add_(add_(totalReserves, totalFuseFees), totalAdminFees)\n            );\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            uint256 nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(\n                totalUnderlyingSupply,\n                mintAmount\n            );\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            require(\n                nextTotalUnderlyingSupply < supplyCap,\n                \"market supply cap reached\"\n            );\n        }\n\n        // Keep the flywheel moving\n        flywheelPreSupplierAction(cToken, minter);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 actualMintAmount,\n        uint256 mintTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        minter;\n        actualMintAmount;\n        mintTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n\n        // Add minter to suppliers mapping\n        suppliers[minter] = true;\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        flywheelPreSupplierAction(cToken, redeemer);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (\n            Error err,\n            ,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(\n                redeemer,\n                CToken(cToken),\n                redeemTokens,\n                0\n            );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        // Make sure borrower is whitelisted\n        if (enforceWhitelist && !whitelist[borrower]) {\n            return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n        }\n\n        // Check borrow cap\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint256 nextTotalBorrows) = addUInt(\n                totalBorrows,\n                borrowAmount\n            );\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Keep the flywheel moving\n        flywheelPreBorrowerAction(cToken, borrower);\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (\n            Error err,\n            ,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(\n                borrower,\n                CToken(cToken),\n                0,\n                borrowAmount\n            );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken Asset whose underlying is being borrowed\n     * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n     */\n    function borrowWithinLimits(address cToken, uint256 accountBorrowsNew)\n        external\n        returns (uint256)\n    {\n        // Check if global pause borrow override exists\n        uint256 minBorrowEth = _globalPauseBorrowOverride\n            ? 1e18\n            : fuseAdmin.minBorrowEth();\n\n        if (minBorrowEth > 0) {\n            // Get new underlying borrow balance of account for this cToken\n            uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(\n                CToken(cToken)\n            );\n            if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\n            (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\n                Exp({mantissa: oraclePriceMantissa}),\n                accountBorrowsNew\n            );\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            // Check against min borrow\n            if (borrowBalanceEth < minBorrowEth)\n                return uint256(Error.BORROW_BELOW_MIN);\n        }\n\n        // Return no error\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken Asset whose underlying is being borrowed\n     * @param exchangeRateMantissa Underlying/cToken exchange rate\n     * @param accountTokens Initial account cToken balance\n     * @param accountTokens Underlying amount to mint\n     */\n    function mintWithinLimits(\n        address cToken,\n        uint256 exchangeRateMantissa,\n        uint256 accountTokens,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Return no error\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external {\n        // Shh - currently unused\n        cToken;\n        borrower;\n        borrowAmount;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        flywheelPreBorrowerAction(cToken, borrower);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 actualRepayAmount,\n        uint256 borrowerIndex\n    ) external {\n        // Shh - currently unused\n        cToken;\n        payer;\n        borrower;\n        actualRepayAmount;\n        borrowerIndex;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (\n            !markets[cTokenBorrowed].isListed ||\n            !markets[cTokenCollateral].isListed\n        ) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(\n            borrower\n        );\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(\n                borrowBalance >= repayAmount,\n                \"Can not repay more than the total borrow\"\n            );\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(\n                borrower\n            );\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(\n                Exp({mantissa: closeFactorMantissa}),\n                borrowBalance\n            );\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount,\n        uint256 seizeTokens\n    ) external {\n        // Shh - currently unused\n        cTokenBorrowed;\n        cTokenCollateral;\n        liquidator;\n        borrower;\n        actualRepayAmount;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (\n            !markets[cTokenCollateral].isListed ||\n            !markets[cTokenBorrowed].isListed\n        ) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (\n            CToken(cTokenCollateral).comptroller() !=\n            CToken(cTokenBorrowed).comptroller()\n        ) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external {\n        // Shh - currently unused\n        cTokenCollateral;\n        cTokenBorrowed;\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        flywheelPreTransferAction(cToken, src, dst);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        src;\n        dst;\n        transferTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            maxAssets = maxAssets;\n        }\n    }\n\n    /*** Flywheel Hooks ***/\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier)\n        internal\n    {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++)\n            RewardsDistributorDelegate(rewardsDistributors[i])\n                .flywheelPreSupplierAction(cToken, supplier);\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower)\n        internal\n    {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++)\n            RewardsDistributorDelegate(rewardsDistributors[i])\n                .flywheelPreBorrowerAction(cToken, borrower);\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-transfer and pre-seize\n     * @param cToken The relevant market\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     */\n    function flywheelPreTransferAction(\n        address cToken,\n        address src,\n        address dst\n    ) internal {\n        for (uint256 i = 0; i < rewardsDistributors.length; i++)\n            RewardsDistributorDelegate(rewardsDistributors[i])\n                .flywheelPreTransferAction(cToken, src, dst);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            Error err,\n            uint256 liquidity,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return\n            getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            Error err,\n            uint256 liquidity,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(\n                account,\n                CToken(cTokenModify),\n                redeemTokens,\n                borrowAmount\n            );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (\n                oErr,\n                vars.cTokenBalance,\n                vars.borrowBalance,\n                vars.exchangeRateMantissa\n            ) = asset.getAccountSnapshot(account);\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({\n                mantissa: markets[address(asset)].collateralFactorMantissa\n            });\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(\n                mul_(vars.collateralFactor, vars.exchangeRate),\n                vars.oraclePrice\n            );\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                vars.cTokenBalance,\n                vars.sumCollateral\n            );\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (\n                Error.NO_ERROR,\n                vars.sumCollateral - vars.sumBorrowPlusEffects,\n                0\n            );\n        } else {\n            return (\n                Error.NO_ERROR,\n                0,\n                vars.sumBorrowPlusEffects - vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(\n            CToken(cTokenBorrowed)\n        );\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(\n            CToken(cTokenCollateral)\n        );\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint256(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral)\n            .exchangeRateStored(); // Note: reverts on error\n        uint256 seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(\n            Exp({mantissa: liquidationIncentiveMantissa}),\n            Exp({mantissa: priceBorrowedMantissa})\n        );\n        denominator = mul_(\n            Exp({mantissa: priceCollateralMantissa}),\n            Exp({mantissa: exchangeRateMantissa})\n        );\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint256(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Add a RewardsDistributor contracts.\n     * @dev Admin function to add a RewardsDistributor contract\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addRewardsDistributor(address distributor)\n        external\n        returns (uint256)\n    {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK\n                );\n        }\n\n        // Check marker method\n        require(\n            RewardsDistributorDelegate(distributor).isRewardsDistributor(),\n            \"marker method returned false\"\n        );\n\n        // Check for existing RewardsDistributor\n        for (uint256 i = 0; i < rewardsDistributors.length; i++)\n            require(\n                distributor != rewardsDistributors[i],\n                \"RewardsDistributor contract already added\"\n            );\n\n        // Add RewardsDistributor to array\n        rewardsDistributors.push(distributor);\n        emit AddedRewardsDistributor(distributor);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the global pause borrows override\n     */\n    function _setGlobalPauseBorrowOverride(bool status) external {\n        require(hasAdminRights(), \"!admin\");\n        _globalPauseBorrowOverride = status;\n    }\n\n    /**\n     * @notice Sets the whitelist enforcement for the comptroller\n     * @dev Admin function to set a new whitelist enforcement boolean\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK\n                );\n        }\n\n        // Check if `enforceWhitelist` already equals `enforce`\n        if (enforceWhitelist == enforce) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        // Set comptroller's `enforceWhitelist` to `enforce`\n        enforceWhitelist = enforce;\n\n        // Emit WhitelistEnforcementChanged(bool enforce);\n        emit WhitelistEnforcementChanged(enforce);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the whitelist `statuses` for `suppliers`\n     * @dev Admin function to set the whitelist `statuses` for `suppliers`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setWhitelistStatuses(\n        address[] calldata suppliers,\n        bool[] calldata statuses\n    ) external returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK\n                );\n        }\n\n        // Set whitelist statuses for suppliers\n        for (uint256 i = 0; i < suppliers.length; i++) {\n            address supplier = suppliers[i];\n\n            if (statuses[i]) {\n                // If not already whitelisted, add to whitelist\n                if (!whitelist[supplier]) {\n                    whitelist[supplier] = true;\n                    whitelistArray.push(supplier);\n                    whitelistIndexes[supplier] = whitelistArray.length - 1;\n                }\n            } else {\n                // If whitelisted, remove from whitelist\n                if (whitelist[supplier]) {\n                    uint256 supplierIndex = whitelistIndexes[supplier];\n\n                    // If supplier not at the end of the whitelist array, replace it with the item at the end of the whitelist array\n                    if (supplierIndex < whitelistArray.length - 1) {\n                        address lastElement = whitelistArray[\n                            whitelistArray.length - 1\n                        ];\n                        whitelistArray[supplierIndex] = lastElement; // Copy last item in list to location of item to be removed\n                        whitelistIndexes[lastElement] = supplierIndex; // Set whitelist index of moved item to correct index\n                    }\n\n                    // Remove the last element of the whitelist array\n                    whitelistArray.length--; // Reduce length by 1\n                    whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n                    whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n                }\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK\n                );\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa)\n        external\n        returns (uint256)\n    {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK\n                );\n        }\n\n        // Check limits\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return\n                fail(\n                    Error.INVALID_CLOSE_FACTOR,\n                    FailureInfo.SET_CLOSE_FACTOR_VALIDATION\n                );\n        }\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return\n                fail(\n                    Error.INVALID_CLOSE_FACTOR,\n                    FailureInfo.SET_CLOSE_FACTOR_VALIDATION\n                );\n        }\n\n        // Set pool close factor to new close factor, remember old value\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        // Emit event\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Admin function to set per-market collateralFactor\n     * @param cToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(\n        CToken cToken,\n        uint256 newCollateralFactorMantissa\n    ) public returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK\n                );\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return\n                fail(\n                    Error.MARKET_NOT_LISTED,\n                    FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS\n                );\n        }\n\n        Exp memory newCollateralFactorExp = Exp({\n            mantissa: newCollateralFactorMantissa\n        });\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return\n                fail(\n                    Error.INVALID_COLLATERAL_FACTOR,\n                    FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION\n                );\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (\n            newCollateralFactorMantissa != 0 &&\n            oracle.getUnderlyingPrice(cToken) == 0\n        ) {\n            return\n                fail(\n                    Error.PRICE_ERROR,\n                    FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE\n                );\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(\n            cToken,\n            oldCollateralFactorMantissa,\n            newCollateralFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\n        external\n        returns (uint256)\n    {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK\n                );\n        }\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n        Exp memory newLiquidationIncentive = Exp({\n            mantissa: newLiquidationIncentiveMantissa\n        });\n        Exp memory minLiquidationIncentive = Exp({\n            mantissa: liquidationIncentiveMinMantissa\n        });\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_INCENTIVE,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION\n                );\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({\n            mantissa: liquidationIncentiveMaxMantissa\n        });\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_INCENTIVE,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION\n                );\n        }\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(\n            oldLiquidationIncentiveMantissa,\n            newLiquidationIncentiveMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param cToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(CToken cToken) internal returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SUPPORT_MARKET_OWNER_CHECK\n                );\n        }\n\n        // Is market already listed?\n        if (markets[address(cToken)].isListed) {\n            return\n                fail(\n                    Error.MARKET_ALREADY_LISTED,\n                    FailureInfo.SUPPORT_MARKET_EXISTS\n                );\n        }\n\n        // Sanity check to make sure its really a CToken\n        require(cToken.isCToken(), \"marker method returned false\");\n\n        // Check cToken.comptroller == this\n        require(\n            address(cToken.comptroller()) == address(this),\n            \"Cannot support a market with a different Comptroller.\"\n        );\n\n        // Make sure market is not already listed\n        address underlying = cToken.isCEther()\n            ? address(0)\n            : CErc20(address(cToken)).underlying();\n\n        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n            return\n                fail(\n                    Error.MARKET_ALREADY_LISTED,\n                    FailureInfo.SUPPORT_MARKET_EXISTS\n                );\n        }\n\n        // List market and emit event\n        markets[address(cToken)] = Market({\n            isListed: true,\n            collateralFactorMantissa: 0\n        });\n        allMarkets.push(cToken);\n        cTokensByUnderlying[underlying] = cToken;\n        emit MarketListed(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n     * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _deployMarket(\n        bool isCEther,\n        bytes calldata constructorData,\n        uint256 collateralFactorMantissa\n    ) external returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SUPPORT_MARKET_OWNER_CHECK\n                );\n        }\n\n        // Temporarily enable Fuse admin rights for asset deployment (storing the original value)\n        bool oldFuseAdminHasRights = fuseAdminHasRights;\n        fuseAdminHasRights = true;\n\n        // Deploy via Fuse admin\n        CToken cToken = CToken(\n            isCEther\n                ? fuseAdmin.deployCEther(constructorData)\n                : fuseAdmin.deployCErc20(constructorData)\n        );\n\n        // Reset Fuse admin rights to the original value\n        fuseAdminHasRights = oldFuseAdminHasRights;\n\n        // Support market here in the Comptroller\n        uint256 err = _supportMarket(cToken);\n\n        // Set collateral factor\n        return\n            err == uint256(Error.NO_ERROR)\n                ? _setCollateralFactor(cToken, collateralFactorMantissa)\n                : err;\n    }\n\n    /**\n     * @notice Removed a market from the markets mapping and sets it as unlisted\n     * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n     * @param cToken The address of the market (token) to unlist\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _unsupportMarket(CToken cToken) external returns (uint256) {\n        // Check admin rights\n        if (!hasAdminRights())\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK\n                );\n\n        // Check if market is already unlisted\n        if (!markets[address(cToken)].isListed)\n            return\n                fail(\n                    Error.MARKET_NOT_LISTED,\n                    FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST\n                );\n\n        // Check if market is in use\n        if (cToken.totalSupply() > 0)\n            return\n                fail(\n                    Error.NONZERO_TOTAL_SUPPLY,\n                    FailureInfo.UNSUPPORT_MARKET_IN_USE\n                );\n\n        // Unlist market\n        delete markets[address(cToken)];\n\n        /* Delete cToken from allMarkets */\n        // load into memory for faster iteration\n        CToken[] memory _allMarkets = allMarkets;\n        uint256 len = _allMarkets.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (_allMarkets[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n        allMarkets.length--;\n\n        cTokensByUnderlying[\n            cToken.isCEther()\n                ? address(0)\n                : CErc20(address(cToken)).underlying()\n        ] = CToken(address(0));\n        emit MarketUnlisted(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Toggles the auto-implementation feature\n     * @param enabled If the feature is to be enabled\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _toggleAutoImplementations(bool enabled) public returns (uint256) {\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK\n                );\n        }\n\n        // Return no error if already set to the desired value\n        if (autoImplementation == enabled) return uint256(Error.NO_ERROR);\n\n        // Store autoImplementation with value enabled\n        autoImplementation = enabled;\n\n        // Emit AutoImplementationsToggled(enabled)\n        emit AutoImplementationsToggled(enabled);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n     * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n     */\n    function _setMarketSupplyCaps(\n        CToken[] calldata cTokens,\n        uint256[] calldata newSupplyCaps\n    ) external {\n        require(\n            hasAdminRights() || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set supply caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(\n            numMarkets != 0 && numMarkets == numSupplyCaps,\n            \"invalid input\"\n        );\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(\n        CToken[] calldata cTokens,\n        uint256[] calldata newBorrowCaps\n    ) external {\n        require(\n            hasAdminRights() || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set borrow caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(\n            numMarkets != 0 && numMarkets == numBorrowCaps,\n            \"invalid input\"\n        );\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(hasAdminRights(), \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian)\n        public\n        returns (uint256)\n    {\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK\n                );\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(\n            markets[address(cToken)].isListed,\n            \"cannot pause a market that is not listed\"\n        );\n        require(\n            msg.sender == pauseGuardian || hasAdminRights(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(\n            markets[address(cToken)].isListed,\n            \"cannot pause a market that is not listed\"\n        );\n        require(\n            msg.sender == pauseGuardian || hasAdminRights(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPaused(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(\n            msg.sender == pauseGuardian || hasAdminRights(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(\n            msg.sender == pauseGuardian || hasAdminRights(),\n            \"only pause guardian and admin can pause\"\n        );\n        require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(UnitrollerInterface unitroller) public {\n        require(\n            (msg.sender == address(fuseAdmin) &&\n                unitroller.fuseAdminHasRights()) ||\n                (msg.sender == unitroller.admin() &&\n                    unitroller.adminHasRights()),\n            \"only unitroller admin can change brains\"\n        );\n\n        uint256 changeStatus = unitroller._acceptImplementation();\n        require(changeStatus == 0, \"change not authorized\");\n\n        Comptroller(address(unitroller))._becomeImplementation();\n    }\n\n    function _becomeImplementation() external {\n        require(\n            msg.sender == comptrollerImplementation,\n            \"only implementation may call _becomeImplementation\"\n        );\n\n        if (!_notEnteredInitialized) {\n            _notEntered = true;\n            _notEnteredInitialized = true;\n        }\n    }\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Return all of the borrowers\n     * @dev The automatic getter may be used to access an individual borrower.\n     * @return The list of borrower account addresses\n     */\n    function getAllBorrowers() public view returns (address[] memory) {\n        return allBorrowers;\n    }\n\n    /**\n     * @notice Return all of the whitelist\n     * @dev The automatic getter may be used to access an individual whitelist status.\n     * @return The list of borrower account addresses\n     */\n    function getWhitelist() external view returns (address[] memory) {\n        return whitelistArray;\n    }\n\n    /**\n     * @notice Returns an array of all RewardsDistributors\n     */\n    function getRewardsDistributors() external view returns (address[] memory) {\n        return rewardsDistributors;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) public view returns (bool) {\n        return\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\n            borrowGuardianPaused[address(cToken)] == true &&\n            add_(\n                add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()),\n                cToken.fuseFeeMantissa()\n            ) ==\n            1e18;\n    }\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    /**\n     * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _beforeNonReentrant() external {\n        require(\n            markets[msg.sender].isListed,\n            \"Comptroller:_beforeNonReentrant: caller not listed as market\"\n        );\n        require(_notEntered, \"re-entered across assets\");\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _afterNonReentrant() external {\n        require(\n            markets[msg.sender].isListed,\n            \"Comptroller:_afterNonReentrant: caller not listed as market\"\n        );\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/ComptrollerG1.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This was the first version of the Comptroller brains.\n *  We keep it so our tests can continue to do the real-life behavior of upgrading from this logic forward.\n */\ncontract ComptrollerG1 is\n    ComptrollerV1Storage,\n    ComptrollerErrorReporter,\n    Exponential\n{\n    struct Market {\n        /**\n         * @notice Whether or not this market is listed\n         */\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /**\n         * @notice Per-market mapping of \"accounts in this asset\"\n         */\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /**\n     * @notice Emitted when an admin supports a market\n     */\n    event MarketListed(CToken cToken);\n\n    /**\n     * @notice Emitted when an account enters a market\n     */\n    event MarketEntered(CToken cToken, address account);\n\n    /**\n     * @notice Emitted when an account exits a market\n     */\n    event MarketExited(CToken cToken, address account);\n\n    /**\n     * @notice Emitted when close factor is changed by admin\n     */\n    event NewCloseFactor(\n        uint256 oldCloseFactorMantissa,\n        uint256 newCloseFactorMantissa\n    );\n\n    /**\n     * @notice Emitted when a collateral factor is changed by admin\n     */\n    event NewCollateralFactor(\n        CToken cToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    /**\n     * @notice Emitted when liquidation incentive is changed by admin\n     */\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    /**\n     * @notice Emitted when maxAssets is changed by admin\n     */\n    event NewMaxAssets(uint256 oldMaxAssets, uint256 newMaxAssets);\n\n    /**\n     * @notice Emitted when price oracle is changed\n     */\n    event NewPriceOracle(\n        PriceOracle oldPriceOracle,\n        PriceOracle newPriceOracle\n    );\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 constant closeFactorMinMantissa = 5e16; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 constant closeFactorMaxMantissa = 9e17; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 constant liquidationIncentiveMinMantissa = mantissaOne;\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account)\n        external\n        view\n        returns (CToken[] memory)\n    {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken)\n        external\n        view\n        returns (bool)\n    {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens)\n        public\n        returns (uint256[] memory)\n    {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n            Market storage marketToJoin = markets[address(cToken)];\n\n            if (!marketToJoin.isListed) {\n                // if market is not listed, cannot join move along\n                results[i] = uint256(Error.MARKET_NOT_LISTED);\n                continue;\n            }\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n                // if already joined, move along\n                results[i] = uint256(Error.NO_ERROR);\n                continue;\n            }\n\n            if (accountAssets[msg.sender].length >= maxAssets) {\n                // if no space, cannot join, move along\n                results[i] = uint256(Error.TOO_MANY_ASSETS);\n                continue;\n            }\n\n            // survived the gauntlet, add to list\n            // NOTE: we store these somewhat redundantly as a significant optimization\n            //  this avoids having to iterate through the list for the most common use cases\n            //  that is, only when we need to perform liquidity checks\n            //   and not whenever we want to check if an account is in a particular market\n            marketToJoin.accountMembership[msg.sender] = true;\n            accountAssets[msg.sender].push(cToken);\n\n            emit MarketEntered(cToken, msg.sender);\n\n            results[i] = uint256(Error.NO_ERROR);\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken\n            .getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return\n                fail(\n                    Error.NONZERO_BORROW_BALANCE,\n                    FailureInfo.EXIT_MARKET_BALANCE_OWED\n                );\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(\n            cTokenAddress,\n            msg.sender,\n            tokensHeld\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.REJECTION,\n                    FailureInfo.EXIT_MARKET_REJECTION,\n                    allowed\n                );\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already in the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the accounts list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        minter; // currently unused\n        mintAmount; // currently unused\n\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param mintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external {\n        cToken; // currently unused\n        minter; // currently unused\n        mintAmount; // currently unused\n        mintTokens; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        return redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (\n            Error err,\n            ,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(\n                redeemer,\n                CToken(cToken),\n                redeemTokens,\n                0\n            );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        cToken; // currently unused\n        redeemer; // currently unused\n        redeemAmount; // currently unused\n        redeemTokens; // currently unused\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            return uint256(Error.MARKET_NOT_ENTERED);\n        }\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        (\n            Error err,\n            ,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(\n                borrower,\n                CToken(cToken),\n                0,\n                borrowAmount\n            );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external {\n        cToken; // currently unused\n        borrower; // currently unused\n        borrowAmount; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        payer; // currently unused\n        borrower; // currently unused\n        repayAmount; // currently unused\n\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external {\n        cToken; // currently unused\n        payer; // currently unused\n        borrower; // currently unused\n        repayAmount; // currently unused\n        borrowerIndex; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        liquidator; // currently unused\n        borrower; // currently unused\n        repayAmount; // currently unused\n\n        if (\n            !markets[cTokenBorrowed].isListed ||\n            !markets[cTokenCollateral].isListed\n        ) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // *may include Policy Hook-type checks\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getAccountLiquidityInternal(\n            borrower\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall == 0) {\n            return uint256(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(\n            borrower\n        );\n        (MathError mathErr, uint256 maxClose) = mulScalarTruncate(\n            Exp({mantissa: closeFactorMantissa}),\n            borrowBalance\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return uint256(Error.MATH_ERROR);\n        }\n        if (repayAmount > maxClose) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external {\n        cTokenBorrowed; // currently unused\n        cTokenCollateral; // currently unused\n        liquidator; // currently unused\n        borrower; // currently unused\n        repayAmount; // currently unused\n        seizeTokens; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        liquidator; // currently unused\n        borrower; // currently unused\n        seizeTokens; // currently unused\n\n        if (\n            !markets[cTokenCollateral].isListed ||\n            !markets[cTokenBorrowed].isListed\n        ) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (\n            CToken(cTokenCollateral).comptroller() !=\n            CToken(cTokenBorrowed).comptroller()\n        ) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // *may include Policy Hook-type checks\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external {\n        cTokenCollateral; // currently unused\n        cTokenBorrowed; // currently unused\n        liquidator; // currently unused\n        borrower; // currently unused\n        seizeTokens; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        cToken; // currently unused\n        src; // currently unused\n        dst; // currently unused\n        transferTokens; // currently unused\n\n        // *may include Policy Hook-type checks\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        return redeemAllowedInternal(cToken, src, transferTokens);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external {\n        cToken; // currently unused\n        src; // currently unused\n        dst; // currently unused\n        transferTokens; // currently unused\n\n        if (false) {\n            maxAssets = maxAssets; // not pure\n        }\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToEther;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            Error err,\n            uint256 liquidity,\n            uint256 shortfall\n        ) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return\n            getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n        MathError mErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (\n                oErr,\n                vars.cTokenBalance,\n                vars.borrowBalance,\n                vars.exchangeRateMantissa\n            ) = asset.getAccountSnapshot(account);\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({\n                mantissa: markets[address(asset)].collateralFactorMantissa\n            });\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            (mErr, vars.tokensToEther) = mulExp3(\n                vars.collateralFactor,\n                vars.exchangeRate,\n                vars.oraclePrice\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // sumCollateral += tokensToEther * cTokenBalance\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(\n                vars.tokensToEther,\n                vars.cTokenBalance,\n                vars.sumCollateral\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n            if (mErr != MathError.NO_ERROR) {\n                return (Error.MATH_ERROR, 0, 0);\n            }\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToEther * redeemTokens\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n                    vars.tokensToEther,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n                if (mErr != MathError.NO_ERROR) {\n                    return (Error.MATH_ERROR, 0, 0);\n                }\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n                if (mErr != MathError.NO_ERROR) {\n                    return (Error.MATH_ERROR, 0, 0);\n                }\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (\n                Error.NO_ERROR,\n                vars.sumCollateral - vars.sumBorrowPlusEffects,\n                0\n            );\n        } else {\n            return (\n                Error.NO_ERROR,\n                0,\n                vars.sumBorrowPlusEffects - vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param repayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(\n            CToken(cTokenBorrowed)\n        );\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(\n            CToken(cTokenCollateral)\n        );\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint256(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = repayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = repayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral)\n            .exchangeRateStored(); // Note: reverts on error\n        uint256 seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n        MathError mathErr;\n\n        (mathErr, numerator) = mulExp(\n            liquidationIncentiveMantissa,\n            priceBorrowedMantissa\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        (mathErr, denominator) = mulExp(\n            priceCollateralMantissa,\n            exchangeRateMantissa\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        (mathErr, ratio) = divExp(numerator, denominator);\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, repayAmount);\n        if (mathErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0);\n        }\n\n        return (uint256(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK\n                );\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa)\n        external\n        returns (uint256)\n    {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK\n                );\n        }\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return\n                fail(\n                    Error.INVALID_CLOSE_FACTOR,\n                    FailureInfo.SET_CLOSE_FACTOR_VALIDATION\n                );\n        }\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return\n                fail(\n                    Error.INVALID_CLOSE_FACTOR,\n                    FailureInfo.SET_CLOSE_FACTOR_VALIDATION\n                );\n        }\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Admin function to set per-market collateralFactor\n     * @param cToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(\n        CToken cToken,\n        uint256 newCollateralFactorMantissa\n    ) external returns (uint256) {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK\n                );\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return\n                fail(\n                    Error.MARKET_NOT_LISTED,\n                    FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS\n                );\n        }\n\n        Exp memory newCollateralFactorExp = Exp({\n            mantissa: newCollateralFactorMantissa\n        });\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return\n                fail(\n                    Error.INVALID_COLLATERAL_FACTOR,\n                    FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION\n                );\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (\n            newCollateralFactorMantissa != 0 &&\n            oracle.getUnderlyingPrice(cToken) == 0\n        ) {\n            return\n                fail(\n                    Error.PRICE_ERROR,\n                    FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE\n                );\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(\n            cToken,\n            oldCollateralFactorMantissa,\n            newCollateralFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets maxAssets which controls how many markets can be entered\n     * @dev Admin function to set maxAssets\n     * @param newMaxAssets New max assets\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setMaxAssets(uint256 newMaxAssets) external returns (uint256) {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_MAX_ASSETS_OWNER_CHECK\n                );\n        }\n\n        uint256 oldMaxAssets = maxAssets;\n        maxAssets = newMaxAssets;\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\n        external\n        returns (uint256)\n    {\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n        if (!adminOrInitializing()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK\n                );\n        }\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n        Exp memory newLiquidationIncentive = Exp({\n            mantissa: newLiquidationIncentiveMantissa\n        });\n        Exp memory minLiquidationIncentive = Exp({\n            mantissa: liquidationIncentiveMinMantissa\n        });\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_INCENTIVE,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION\n                );\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({\n            mantissa: liquidationIncentiveMaxMantissa\n        });\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return\n                fail(\n                    Error.INVALID_LIQUIDATION_INCENTIVE,\n                    FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION\n                );\n        }\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(\n            oldLiquidationIncentiveMantissa,\n            newLiquidationIncentiveMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param cToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(CToken cToken) external returns (uint256) {\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SUPPORT_MARKET_OWNER_CHECK\n                );\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return\n                fail(\n                    Error.MARKET_ALREADY_LISTED,\n                    FailureInfo.SUPPORT_MARKET_EXISTS\n                );\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        markets[address(cToken)] = Market({\n            isListed: true,\n            collateralFactorMantissa: 0\n        });\n        emit MarketListed(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _become(\n        Unitroller unitroller,\n        PriceOracle _oracle,\n        uint256 _closeFactorMantissa,\n        uint256 _maxAssets,\n        bool reinitializing\n    ) public {\n        require(\n            msg.sender == unitroller.admin(),\n            \"only unitroller admin can change brains\"\n        );\n        uint256 changeStatus = unitroller._acceptImplementation();\n\n        require(changeStatus == 0, \"change not authorized\");\n\n        if (!reinitializing) {\n            ComptrollerG1 freshBrainedComptroller = ComptrollerG1(\n                address(unitroller)\n            );\n\n            // Ensure invoke _setPriceOracle() = 0\n            uint256 err = freshBrainedComptroller._setPriceOracle(_oracle);\n            require(err == uint256(Error.NO_ERROR), \"set price oracle error\");\n\n            // Ensure invoke _setCloseFactor() = 0\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n            require(err == uint256(Error.NO_ERROR), \"set close factor error\");\n\n            // Ensure invoke _setMaxAssets() = 0\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n            require(err == uint256(Error.NO_ERROR), \"set max asssets error\");\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n            err = freshBrainedComptroller._setLiquidationIncentive(\n                liquidationIncentiveMinMantissa\n            );\n            require(\n                err == uint256(Error.NO_ERROR),\n                \"set liquidation incentive error\"\n            );\n        }\n    }\n\n    /**\n     * @dev Check that caller is admin or this contract is initializing itself as\n     * the new implementation.\n     * There should be no way to satisfy msg.sender == comptrollerImplementaiton\n     * without tx.origin also being admin, but both are included for extra safety\n     */\n    function adminOrInitializing() internal view returns (bool) {\n        bool initializing = (msg.sender == comptrollerImplementation &&\n            //solium-disable-next-line security/no-tx-origin\n            tx.origin == admin);\n        bool isAdmin = hasAdminRights();\n        return isAdmin || initializing;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./IFuseFeeDistributor.sol\";\n\ncontract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /// @notice Administrator for Fuse\n    function fuseAdmin() external returns (IFuseFeeDistributor);\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens)\n        external\n        returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintWithinLimits(\n        address cToken,\n        uint256 exchangeRateMantissa,\n        uint256 accountTokens,\n        uint256 mintAmount\n    ) external returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function borrowWithinLimits(address cToken, uint256 accountBorrowsNew)\n        external\n        returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external view returns (uint256, uint256);\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    function _beforeNonReentrant() external;\n\n    function _afterNonReentrant() external;\n}\n"
    },
    "contracts/rari-fuse/src/core/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for Fuse\n     */\n    IFuseFeeDistributor public fuseAdmin;\n\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Whether or not the Fuse admin has admin rights\n     */\n    bool public fuseAdminHasRights = true;\n\n    /**\n     * @notice Whether or not the admin has admin rights\n     */\n    bool public adminHasRights = true;\n\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        return\n            (msg.sender == admin && adminHasRights) ||\n            (msg.sender == address(fuseAdmin) && fuseAdminHasRights);\n    }\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 internal maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    struct Market {\n        /**\n         * @notice Whether or not this market is listed\n         */\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /**\n         * @notice Per-market mapping of \"accounts in this asset\"\n         */\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /**\n     * @dev Maps borrowers to booleans indicating if they have entered any markets\n     */\n    mapping(address => bool) internal borrowers;\n\n    /// @notice A list of all borrowers who have entered markets\n    address[] public allBorrowers;\n\n    /// @notice Indexes of borrower account addresses in the `allBorrowers` array\n    mapping(address => uint256) internal borrowerIndexes;\n\n    /**\n     * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n     */\n    mapping(address => bool) public suppliers;\n\n    /// @notice All cTokens addresses mapped by their underlying token addresses\n    mapping(address => CToken) public cTokensByUnderlying;\n\n    /// @notice Whether or not the supplier whitelist is enforced\n    bool public enforceWhitelist;\n\n    /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n    mapping(address => bool) public whitelist;\n\n    /// @notice An array of all whitelisted accounts\n    address[] public whitelistArray;\n\n    /// @notice Indexes of account addresses in the `whitelistArray` array\n    mapping(address => uint256) internal whitelistIndexes;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /**\n     * @dev Whether or not the implementation should be auto-upgraded.\n     */\n    bool public autoImplementation;\n\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint256) public borrowCaps;\n\n    /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint256) public supplyCaps;\n\n    /// @notice RewardsDistributor contracts to notify of flywheel changes.\n    address[] public rewardsDistributors;\n\n    /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n    bool internal _notEntered;\n\n    /// @dev Whether or not _notEntered has been initialized\n    bool internal _notEnteredInitialized;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    bool public _globalPauseBorrowOverride;\n}\n"
    },
    "contracts/rari-fuse/src/core/CToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./IFuseFeeDistributor.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Returns a boolean indicating if the sender has admin rights\n     */\n    function hasAdminRights() internal view returns (bool) {\n        ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(\n            address(comptroller)\n        );\n        return\n            (msg.sender == comptrollerStorage.admin() &&\n                comptrollerStorage.adminHasRights()) ||\n            (msg.sender == address(fuseAdmin) &&\n                comptrollerStorage.fuseAdminHasRights());\n    }\n\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 reserveFactorMantissa_,\n        uint256 adminFeeMantissa_\n    ) public {\n        IFuseFeeDistributor _fuseAdmin = comptroller_.fuseAdmin();\n\n        require(\n            msg.sender == address(_fuseAdmin),\n            \"only Fuse admin may initialize the market\"\n        );\n        fuseAdmin = IFuseFeeDistributor(_fuseAdmin);\n\n        require(\n            accrualBlockNumber == 0 && borrowIndex == 0,\n            \"market may only be initialized once\"\n        );\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(\n            initialExchangeRateMantissa > 0,\n            \"initial exchange rate must be greater than zero.\"\n        );\n\n        // Set the comptroller\n        uint256 err = _setComptroller(comptroller_);\n        require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(\n            err == uint256(Error.NO_ERROR),\n            \"setting interest rate model failed\"\n        );\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(\n            err == uint256(Error.NO_ERROR),\n            \"setting reserve factor failed\"\n        );\n\n        // Set admin fee\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"setting admin fee failed\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)\n     */\n    function getPendingFuseFeeFromAdmin() internal view returns (uint256) {\n        return fuseAdmin.interestFeeRate();\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal returns (uint256) {\n        /* Fail if transfer not allowed */\n        uint256 allowed = comptroller.transferAllowed(\n            address(this),\n            src,\n            dst,\n            tokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.TRANSFER_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint256(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint256 allowanceNew;\n        uint256 srcTokensNew;\n        uint256 dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint256(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount)\n        external\n        nonReentrant(false)\n        returns (bool)\n    {\n        return\n            transferTokens(msg.sender, msg.sender, dst, amount) ==\n            uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external nonReentrant(false) returns (bool) {\n        return\n            transferTokens(msg.sender, src, dst, amount) ==\n            uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            accountTokens[owner]\n        );\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cTokenBalance = accountTokens[account];\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (\n            uint256(Error.NO_ERROR),\n            cTokenBalance,\n            borrowBalance,\n            exchangeRateMantissa\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     * @dev WARNING: On Citrus, it will return the timestamp instead.\n     *  It should not matter as long as you keep using this function.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256) {\n        return\n            interestRateModel.getBorrowRate(\n                getCashPrior(),\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n            );\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256) {\n        return\n            interestRateModel.getSupplyRate(\n                getCashPrior(),\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees)),\n                reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa\n            );\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent()\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account)\n        public\n        view\n        returns (uint256)\n    {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(\n            err == MathError.NO_ERROR,\n            \"borrowBalanceStored: borrowBalanceStoredInternal failed\"\n        );\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account)\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(\n            borrowSnapshot.principal,\n            borrowIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(\n            principalTimesIndex,\n            borrowSnapshot.interestIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent()\n        public\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(\n            err == MathError.NO_ERROR,\n            \"exchangeRateStored: exchangeRateStoredInternal failed\"\n        );\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal()\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash,\n                totalBorrows,\n                add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(\n                cashPlusBorrowsMinusReserves,\n                _totalSupply\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\n            cashPrior,\n            totalBorrows,\n            add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n        );\n        require(\n            borrowRateMantissa <= borrowRateMaxMantissa,\n            \"borrow rate is absurdly high\"\n        );\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint256 blockDelta) = subUInt(\n            currentBlockNumber,\n            accrualBlockNumber\n        );\n        require(\n            mathErr == MathError.NO_ERROR,\n            \"could not calculate block delta\"\n        );\n\n        return\n            finishInterestAccrual(\n                currentBlockNumber,\n                cashPrior,\n                borrowRateMantissa,\n                blockDelta\n            );\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(\n        uint256 currentBlockNumber,\n        uint256 cashPrior,\n        uint256 borrowRateMantissa,\n        uint256 blockDelta\n    ) private returns (uint256) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(\n            Exp({mantissa: borrowRateMantissa}),\n            blockDelta\n        );\n        uint256 interestAccumulated = mul_ScalarTruncate(\n            simpleInterestFactor,\n            totalBorrows\n        );\n        uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: reserveFactorMantissa}),\n            interestAccumulated,\n            totalReserves\n        );\n        uint256 totalFuseFeesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: fuseFeeMantissa}),\n            interestAccumulated,\n            totalFuseFees\n        );\n        uint256 totalAdminFeesNew = mul_ScalarTruncateAddUInt(\n            Exp({mantissa: adminFeeMantissa}),\n            interestAccumulated,\n            totalAdminFees\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(\n            simpleInterestFactor,\n            borrowIndex,\n            borrowIndex\n        );\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n        totalFuseFees = totalFuseFeesNew;\n        totalAdminFees = totalAdminFeesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(\n            cashPrior,\n            interestAccumulated,\n            borrowIndexNew,\n            totalBorrowsNew\n        );\n\n        // Attempt to add interest checkpoint\n        address(interestRateModel).call(\n            abi.encodeWithSignature(\n                \"checkpointInterest(uint256)\",\n                borrowRateMantissa\n            )\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint256 mintAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint256 mintAmount)\n        internal\n        returns (uint256, uint256)\n    {\n        /* Fail if mint not allowed */\n        uint256 allowed = comptroller.mintAllowed(\n            address(this),\n            minter,\n            mintAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.MINT_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK),\n                0\n            );\n        }\n\n        MintLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        // Check max supply\n        // unused function\n        /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"MINT_EXCHANGE_CALCULATION_FAILED\"\n        );\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        /* We call the defense hook */\n        comptroller.mintVerify(\n            address(this),\n            minter,\n            vars.actualMintAmount,\n            vars.mintTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemInternal(uint256 redeemTokens)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return\n                fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingInternal(uint256 redeemAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return\n                fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(\n        address payable redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal returns (uint256) {\n        require(\n            redeemTokensIn == 0 || redeemAmountIn == 0,\n            \"one of redeemTokensIn or redeemAmountIn must be zero\"\n        );\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                redeemTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint256 allowed = comptroller.redeemAllowed(\n            address(this),\n            redeemer,\n            vars.redeemTokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.REDEEM_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REDEEM_FRESHNESS_CHECK\n                );\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(\n            totalSupply,\n            vars.redeemTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(\n            accountTokens[redeemer],\n            vars.redeemTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, vars.redeemAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(\n            address(this),\n            redeemer,\n            vars.redeemAmount,\n            vars.redeemTokens\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowInternal(uint256 borrowAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowFresh(address payable borrower, uint256 borrowAmount)\n        internal\n        returns (uint256)\n    {\n        /* Fail if borrow not allowed */\n        uint256 allowed = comptroller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint256 cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        // Check min borrow for this user for this asset\n        allowed = comptroller.borrowWithinLimits(\n            address(this),\n            vars.accountBorrowsNew\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowInternal(uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if repayBorrow not allowed */\n        uint256 allowed = comptroller.repayBorrowAllowed(\n            address(this),\n            payer,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint256(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\"\n        );\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return\n            liquidateBorrowFresh(\n                msg.sender,\n                borrower,\n                repayAmount,\n                cTokenCollateral\n            );\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(cTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (\n                fail(\n                    Error.INVALID_CLOSE_AMOUNT_REQUESTED,\n                    FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (\n                fail(\n                    Error.INVALID_CLOSE_AMOUNT_REQUESTED,\n                    FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX\n                ),\n                0\n            );\n        }\n\n        /* Fail if repayBorrow fails */\n        (\n            uint256 repayBorrowError,\n            uint256 actualRepayAmount\n        ) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(repayBorrowError),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller\n            .liquidateCalculateSeizeTokens(\n                address(this),\n                address(cTokenCollateral),\n                actualRepayAmount\n            );\n        require(\n            amountSeizeError == uint256(Error.NO_ERROR),\n            \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n        );\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(\n            cTokenCollateral.balanceOf(borrower) >= seizeTokens,\n            \"LIQUIDATE_SEIZE_TOO_MUCH\"\n        );\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint256 seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(\n                address(this),\n                liquidator,\n                borrower,\n                seizeTokens\n            );\n        } else {\n            seizeError = cTokenCollateral.seize(\n                liquidator,\n                borrower,\n                seizeTokens\n            );\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            address(cTokenCollateral),\n            seizeTokens\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external nonReentrant(true) returns (uint256) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint256 borrowerTokensNew;\n        uint256 liquidatorTokensNew;\n        uint256 liquidatorSeizeTokens;\n        uint256 protocolSeizeTokens;\n        uint256 protocolSeizeAmount;\n        uint256 exchangeRateMantissa;\n        uint256 totalReservesNew;\n        uint256 totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) internal returns (uint256) {\n        /* Fail if seize not allowed */\n        uint256 allowed = comptroller.seizeAllowed(\n            address(this),\n            seizerToken,\n            liquidator,\n            borrower,\n            seizeTokens\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.COMPTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER\n                );\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(\n            accountTokens[borrower],\n            seizeTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        vars.protocolSeizeTokens = mul_(\n            seizeTokens,\n            Exp({mantissa: protocolSeizeShareMantissa})\n        );\n        vars.liquidatorSeizeTokens = sub_(\n            seizeTokens,\n            vars.protocolSeizeTokens\n        );\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(\n            Exp({mantissa: vars.exchangeRateMantissa}),\n            vars.protocolSeizeTokens\n        );\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(\n            accountTokens[liquidator],\n            vars.liquidatorSeizeTokens\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(\n            address(this),\n            vars.protocolSeizeAmount,\n            vars.totalReservesNew\n        );\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Internal function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller)\n        internal\n        returns (uint256)\n    {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n     * @dev Admin function to accrue interest and set a new admin fee\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setAdminFee(uint256 newAdminFeeMantissa)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setAdminFeeFresh(newAdminFeeMantissa);\n    }\n\n    /**\n     * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new admin fee\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setAdminFeeFresh(uint256 newAdminFeeMantissa)\n        internal\n        returns (uint256)\n    {\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_ADMIN_FEE_FRESH_CHECK\n                );\n        }\n\n        // Sanitize newAdminFeeMantissa\n        if (newAdminFeeMantissa == uint256(-1))\n            newAdminFeeMantissa = adminFeeMantissa;\n\n        // Get latest Fuse fee\n        uint256 newFuseFeeMantissa = getPendingFuseFeeFromAdmin();\n\n        // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa  reserveFactorPlusFeesMaxMantissa\n        if (\n            add_(\n                add_(reserveFactorMantissa, newAdminFeeMantissa),\n                newFuseFeeMantissa\n            ) > reserveFactorPlusFeesMaxMantissa\n        ) {\n            return\n                fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n        }\n\n        // If setting admin fee\n        if (adminFeeMantissa != newAdminFeeMantissa) {\n            // Check caller is admin\n            if (!hasAdminRights()) {\n                return\n                    fail(\n                        Error.UNAUTHORIZED,\n                        FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK\n                    );\n            }\n\n            // Set admin fee\n            uint256 oldAdminFeeMantissa = adminFeeMantissa;\n            adminFeeMantissa = newAdminFeeMantissa;\n\n            // Emit event\n            emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n        }\n\n        // If setting Fuse fee\n        if (fuseFeeMantissa != newFuseFeeMantissa) {\n            // Set Fuse fee\n            uint256 oldFuseFeeMantissa = fuseFeeMantissa;\n            fuseFeeMantissa = newFuseFeeMantissa;\n\n            // Emit event\n            emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa)\n        internal\n        returns (uint256)\n    {\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK\n                );\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        // Check newReserveFactor  maxReserveFactor\n        if (\n            add_(\n                add_(newReserveFactorMantissa, adminFeeMantissa),\n                fuseFeeMantissa\n            ) > reserveFactorPlusFeesMaxMantissa\n        ) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(\n            oldReserveFactorMantissa,\n            newReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint256 reduceAmount)\n        internal\n        returns (uint256)\n    {\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.REDUCE_RESERVES_ADMIN_CHECK\n                );\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REDUCE_RESERVES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check reduceAmount  reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return\n                fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces Fuse fees by transferring to Fuse\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFees(uint256 withdrawAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawFuseFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces Fuse fees by transferring to Fuse\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawFuseFeesFresh(uint256 withdrawAmount)\n        internal\n        returns (uint256)\n    {\n        // totalFuseFees - reduceAmount\n        uint256 totalFuseFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check withdrawAmount  fuseFees[n] (totalFuseFees)\n        if (withdrawAmount > totalFuseFees) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalFuseFees above, so this should never revert.\n        totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);\n\n        // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount\n        totalFuseFees = totalFuseFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(address(fuseAdmin), withdrawAmount);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces admin fees by transferring to admin\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFees(uint256 withdrawAmount)\n        external\n        nonReentrant(false)\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _withdrawAdminFeesFresh(withdrawAmount);\n    }\n\n    /**\n     * @notice Reduces admin fees by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param withdrawAmount Amount of fees to withdraw\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawAdminFeesFresh(uint256 withdrawAmount)\n        internal\n        returns (uint256)\n    {\n        // totalAdminFees - reduceAmount\n        uint256 totalAdminFeesNew;\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK\n                );\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        // Check withdrawAmount  adminFees[n] (totalAdminFees)\n        if (withdrawAmount > totalAdminFees) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked withdrawAmount <= totalAdminFees above, so this should never revert.\n        totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);\n\n        // Store adminFees[n+1] = adminFees[n] - withdrawAmount\n        totalAdminFees = totalAdminFeesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(\n            address(\n                uint160(UnitrollerAdminStorage(address(comptroller)).admin())\n            ),\n            withdrawAmount\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel)\n        public\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel)\n        internal\n        returns (uint256)\n    {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK\n                );\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(\n            newInterestRateModel.isInterestRateModel(),\n            \"marker method returned false\"\n        );\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(\n            oldInterestRateModel,\n            newInterestRateModel\n        );\n\n        // Attempt to reset interest checkpoints on old IRM\n        if (address(oldInterestRateModel) != address(0))\n            address(oldInterestRateModel).call(\n                abi.encodeWithSignature(\"resetInterestCheckpoints()\")\n            );\n\n        // Attempt to add first interest checkpoint on new IRM\n        address(newInterestRateModel).call(\n            abi.encodeWithSignature(\"checkpointInterest()\")\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol)\n        external\n    {\n        // Check caller is admin\n        require(hasAdminRights(), \"caller not admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint256 amount) internal;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenAdminStorage {\n    /**\n     * @notice Administrator for Fuse\n     */\n    IFuseFeeDistributor public fuseAdmin;\n\n    /**\n     * @dev LEGACY USE ONLY: Administrator for this contract\n     */\n    address payable internal __admin;\n\n    /**\n     * @dev LEGACY USE ONLY: Whether or not the Fuse admin has admin rights\n     */\n    bool internal __fuseAdminHasRights;\n\n    /**\n     * @dev LEGACY USE ONLY: Whether or not the admin has admin rights\n     */\n    bool internal __adminHasRights;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\ncontract CTokenStorage is CTokenAdminStorage {\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0001% / second)\n     */\n    uint256 internal constant borrowRateMaxMantissa = 0.0001e16;\n\n    /**\n     * @notice Maximum fraction of interest that can be set aside for reserves + fees\n     */\n    uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n    /**\n     * @notice LEGACY USE ONLY: Pending administrator for this contract\n     */\n    address payable private __pendingAdmin;\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /**\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     */\n    uint256 internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for admin fees\n     */\n    uint256 public adminFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for Fuse fees\n     */\n    uint256 public fuseFeeMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint256 public reserveFactorMantissa;\n\n    /**\n     * @notice Block number that interest was last accrued at\n     \n     */\n    uint256 public accrualBlockNumber;\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint256 public borrowIndex;\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint256 public totalBorrows;\n\n    /**\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint256 public totalReserves;\n\n    /**\n     * @notice Total amount of admin fees of the underlying held in this market\n     */\n    uint256 public totalAdminFees;\n\n    /**\n     * @notice Total amount of Fuse fees of the underlying held in this market\n     */\n    uint256 public totalFuseFees;\n\n    /**\n     * @notice Total number of tokens in circulation\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @notice Official record of token balances for each account\n     */\n    mapping(address => uint256) internal accountTokens;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     * @notice Share of seized collateral that is added to reserves\n     */\n    uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\ncontract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /**\n     * @notice Indicator that this is or is not a CEther contract (for inspection)\n     */\n    bool public constant isCEther = false;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(\n        ComptrollerInterface oldComptroller,\n        ComptrollerInterface newComptroller\n    );\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModel oldInterestRateModel,\n        InterestRateModel newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(\n        address benefactor,\n        uint256 addAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(\n        address admin,\n        uint256 reduceAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice Event emitted when the admin fee is changed\n     */\n    event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n    /**\n     * @notice Event emitted when the Fuse fee is changed\n     */\n    event NewFuseFee(uint256 oldFuseFeeMantissa, uint256 newFuseFeeMantissa);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) public view returns (uint256);\n\n    function exchangeRateCurrent() public returns (uint256);\n\n    function exchangeRateStored() public view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() public returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    /*** Admin Functions ***/\n\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel)\n        public\n        returns (uint256);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\ncontract CErc20Interface is CErc20Storage {\n    /*** User Interface ***/\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256);\n}\n\ncontract CEtherInterface is CErc20Storage {\n    /**\n     * @notice Indicator that this is a CEther contract (for inspection)\n     */\n    bool public constant isCEther = true;\n}\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\ncontract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(\n        address oldImplementation,\n        address newImplementation\n    );\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external;\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes calldata data) external;\n\n    /**\n     * @notice Function called before all delegator functions\n     * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n     */\n    function _prepare() external payable;\n}\n"
    },
    "contracts/rari-fuse/src/core/DAIInterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./JumpRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's DAIInterestRateModel Contract (version 2)\n * @author Compound (modified by Dharma Labs)\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\n * Version 2 modifies the original interest rate model by increasing the \"gap\" or slope of the model prior\n * to the \"kink\" from 0.05% to 2% with the goal of \"smoothing out\" interest rate changes as the utilization\n * rate increases.\n */\ncontract DAIInterestRateModelV2 is JumpRateModel {\n    using SafeMath for uint256;\n\n    /**\n     * @notice The additional margin per block separating the base borrow rate from the roof (2% / block).\n     * Note that this value has been increased from the original value of 0.05% per block.\n     */\n    uint256 public constant gapPerBlock = 2e16 / blocksPerYear;\n\n    /**\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\n     */\n    uint256 public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n    PotLike pot;\n    JugLike jug;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param pot_ The address of the Dai pot (where DSR is earned)\n     * @param jug_ The address of the Dai jug (where SF is kept)\n     */\n    constructor(\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address pot_,\n        address jug_\n    ) public JumpRateModel(0, 0, jumpMultiplierPerYear, kink_) {\n        pot = PotLike(pot_);\n        jug = JugLike(jug_);\n        poke();\n    }\n\n    /**\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 protocolRate = super.getSupplyRate(\n            cash,\n            borrows,\n            reserves,\n            reserveFactorMantissa\n        );\n\n        uint256 underlying = cash.add(borrows).sub(reserves);\n        if (underlying == 0) {\n            return protocolRate;\n        } else {\n            uint256 cashRate = cash.mul(dsrPerBlock()).div(underlying);\n            return cashRate.add(protocolRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the Dai savings rate per block\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\n     */\n    function dsrPerBlock() public view returns (uint256) {\n        return pot.dsr().sub(1e27).div(1e9).mul(15); // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction // descale to 1e18 // 15 seconds per block\n    }\n\n    /**\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\n     */\n    function poke() public {\n        (uint256 duty, ) = jug.ilks(\"ETH-A\");\n        uint256 stabilityFeePerBlock = duty\n            .add(jug.base())\n            .sub(1e27)\n            .mul(1e18)\n            .div(1e27)\n            .mul(15);\n\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(\n            assumedOneMinusReserveFactorMantissa\n        );\n\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n        if (baseRatePerBlock < stabilityFeePerBlock) {\n            multiplierPerBlock = stabilityFeePerBlock\n                .sub(baseRatePerBlock)\n                .add(gapPerBlock)\n                .mul(1e18)\n                .div(kink);\n        } else {\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\n        }\n\n        emit NewInterestParams(\n            baseRatePerBlock,\n            multiplierPerBlock,\n            jumpMultiplierPerBlock,\n            kink\n        );\n    }\n}\n\n/*** Maker Interfaces ***/\n\ncontract PotLike {\n    function chi() external view returns (uint256);\n\n    function dsr() external view returns (uint256);\n\n    function rho() external view returns (uint256);\n\n    function pie(address) external view returns (uint256);\n\n    function drip() external returns (uint256);\n\n    function join(uint256) external;\n\n    function exit(uint256) external;\n}\n\ncontract JugLike {\n    // --- Data ---\n    struct Ilk {\n        uint256 duty;\n        uint256 rho;\n    }\n\n    mapping(bytes32 => Ilk) public ilks;\n    uint256 public base;\n}\n"
    },
    "contracts/rari-fuse/src/core/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount)\n        external\n        returns (bool success);\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool success);\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount)\n        external\n        returns (bool success);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n}\n"
    },
    "contracts/rari-fuse/src/core/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount)\n        external\n        returns (bool success);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n}\n"
    },
    "contracts/rari-fuse/src/core/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        SUPPLIER_NOT_WHITELISTED,\n        BORROW_BELOW_MIN,\n        SUPPLY_ABOVE_MAX,\n        NONZERO_TOTAL_SUPPLY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n        SET_WHITELIST_STATUS_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        UNSUPPORT_MARKET_OWNER_CHECK,\n        UNSUPPORT_MARKET_DOES_NOT_EXIST,\n        UNSUPPORT_MARKET_IN_USE\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return uint256(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        COMPTROLLER_REJECTION,\n        COMPTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        UTILIZATION_ABOVE_MAX\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_COMPTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COMPTROLLER_REJECTION,\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_COMPTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        NEW_UTILIZATION_RATE_ABOVE_MAX,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_COMPTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_FUSE_FEES_FRESH_CHECK,\n        WITHDRAW_FUSE_FEES_VALIDATION,\n        WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n        WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n        WITHDRAW_ADMIN_FEES_VALIDATION,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_COMPTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COMPTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n        SET_ADMIN_FEE_ADMIN_CHECK,\n        SET_ADMIN_FEE_FRESH_CHECK,\n        SET_ADMIN_FEE_BOUNDS_CHECK,\n        SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,\n        SET_FUSE_FEE_FRESH_CHECK,\n        SET_FUSE_FEE_BOUNDS_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_COMPTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return\n            err == Error.COMPTROLLER_REJECTION\n                ? 1000 + opaqueError\n                : uint256(err);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/Exponential.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint256 num, uint256 denom)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (MathError, uint256) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 descaledMantissa) = divUInt(\n            a.mantissa,\n            scalar\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(\n            a.mantissa,\n            b.mantissa\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(\n            halfExpScale,\n            doubleScaledProduct\n        );\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint256 product) = divUInt(\n            doubleScaledProductWithHalfScale,\n            expScale\n        );\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(\n        Exp memory a,\n        Exp memory b,\n        Exp memory c\n    ) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint256 constant expScale = 1e18;\n    uint256 constant doubleScale = 1e36;\n    uint256 constant halfExpScale = expScale / 2;\n    uint256 constant mantissaOne = expScale;\n\n    struct Exp {\n        uint256 mantissa;\n    }\n\n    struct Double {\n        uint256 mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint256) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (uint256)\n    {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (uint256) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe216(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint216)\n    {\n        require(n < 2**216, errorMessage);\n        return uint216(n);\n    }\n\n    function safe40(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint40)\n    {\n        require(n < 2**40, errorMessage);\n        return uint40(n);\n    }\n\n    function add_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return\n            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint256 a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {EIP20Interface} from \"./EIP20Interface.sol\";\n\ncontract IERC4626 is EIP20Interface {\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed from, address indexed to, uint256 value);\n\n    event Withdraw(address indexed from, address indexed to, uint256 value);\n\n    /*///////////////////////////////////////////////////////////////\n                            Mutable Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n      @notice Deposit a specific amount of underlying tokens.\n      @param amount The amount of the underlying token to deposit.\n      @param to The address to receive shares corresponding to the deposit\n      @return shares The shares in the vault credited to `to`\n    */\n    function deposit(uint256 amount, address to)\n        public\n        returns (uint256 shares);\n\n    /**\n      @notice Mint an exact amount of shares for a variable amount of underlying tokens.\n      @param shares The amount of vault shares to mint.\n      @param to The address to receive shares corresponding to the mint.\n      @return amount The amount of the underlying tokens deposited from the mint call.\n    */\n    function mint(uint256 shares, address to) public returns (uint256 amount);\n\n    /**\n      @notice Withdraw a specific amount of underlying tokens.\n      @param amount The amount of the underlying token to withdraw.\n      @param to The address to receive underlying corresponding to the withdrawal.\n      @param from The address to burn shares from corresponding to the withdrawal.\n      @return shares The shares in the vault burned from sender\n    */\n    function withdraw(\n        uint256 amount,\n        address to,\n        address from\n    ) public returns (uint256 shares);\n\n    /**\n      @notice Redeem a specific amount of shares for underlying tokens.\n      @param from The address to burn shares from corresponding to the redemption.\n      @param to The address to receive underlying corresponding to the redemption.\n      @param shares The amount of shares to redeem.\n      @return amount The underlying amount transferred to `to`.\n    */\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) public returns (uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                            View Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n      @notice The underlying token the Vault accepts.\n      @return the ERC20 underlying implementation address.\n    */\n    function asset() public view returns (EIP20Interface);\n\n    /**\n      @notice Returns a user's Vault balance in underlying tokens.\n      @param user The user to get the underlying balance of.\n      @return amount The user's Vault balance in underlying tokens.\n    */\n    function assetsOf(address user) public view returns (uint256 amount);\n\n    /**\n      @notice Calculates the total amount of underlying tokens the Vault manages.\n      @return The total amount of underlying tokens the Vault manages.\n    */\n    function totalAssets() public view returns (uint256);\n\n    /**\n      @notice Returns the value in underlying terms of one vault token.\n     */\n    function exchangeRate() public view returns (uint256);\n\n    /**\n      @notice Returns the amount of vault tokens that would be obtained if depositing a given amount of underlying tokens in a `deposit` call.\n      @param amount the input amount of underlying tokens\n      @return shares the corresponding amount of shares out from a deposit call with `amount` in\n     */\n    function previewDeposit(uint256 amount)\n        public\n        view\n        returns (uint256 shares);\n\n    /**\n      @notice Returns the amount of underlying tokens that would be deposited if minting a given amount of shares in a `mint` call.\n      @param shares the amount of shares from a mint call.\n      @return amount the amount of underlying tokens corresponding to the mint call\n     */\n    function previewMint(uint256 shares) public view returns (uint256 amount);\n\n    /**\n      @notice Returns the amount of vault tokens that would be burned if withdrawing a given amount of underlying tokens in a `withdraw` call.\n      @param amount the input amount of underlying tokens\n      @return shares the corresponding amount of shares out from a withdraw call with `amount` in\n     */\n    function previewWithdraw(uint256 amount)\n        public\n        view\n        returns (uint256 shares);\n\n    /**\n      @notice Returns the amount of underlying tokens that would be obtained if redeeming a given amount of shares in a `redeem` call.\n      @param shares the amount of shares from a redeem call.\n      @return amount the amount of underlying tokens corresponding to the redeem call\n     */\n    function previewRedeem(uint256 shares) public view returns (uint256 amount);\n\n    /**\n      @notice Returns the max deposit amount for a recipient\n      @param to the deposit recipient\n      @return amount the max input amount for deposit for a user\n    */\n    function maxDeposit(address to) public view returns (uint256 amount);\n\n    /**\n      @notice Returns the max mint shares for a recipient\n      @param to the mint recipient\n      @return shares the max shares for mint for a user\n    */\n    function maxMint(address to) public view returns (uint256 shares);\n\n    /**\n      @notice Returns the max withdraw amount for a user\n      @param from the withdraw source\n      @return amount the max amount out for withdraw for a user\n    */\n    function maxWithdraw(address from) public view returns (uint256 amount);\n\n    /**\n      @notice Returns the max redeem shares for a user\n      @param from the redeem source\n      @return shares the max shares out for redeem for a user\n    */\n    function maxRedeem(address from) public view returns (uint256 shares);\n}\n"
    },
    "contracts/rari-fuse/src/core/IFuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\ninterface IFuseFeeDistributor {\n    function minBorrowEth() external view returns (uint256);\n\n    function maxSupplyEth() external view returns (uint256);\n\n    function maxUtilizationRate() external view returns (uint256);\n\n    function interestFeeRate() external view returns (uint256);\n\n    function _callPool(address[] calldata targets, bytes[] calldata data)\n        external;\n\n    function owner() external view returns (address);\n\n    function comptrollerImplementationWhitelist(\n        address oldImplementation,\n        address newImplementation\n    ) external view returns (bool);\n\n    function cErc20DelegateWhitelist(\n        address oldImplementation,\n        address newImplementation,\n        bool allowResign\n    ) external view returns (bool);\n\n    function cEtherDelegateWhitelist(\n        address oldImplementation,\n        address newImplementation,\n        bool allowResign\n    ) external view returns (bool);\n\n    function latestComptrollerImplementation(address oldImplementation)\n        external\n        view\n        returns (address);\n\n    function latestCErc20Delegate(address oldImplementation)\n        external\n        view\n        returns (\n            address cErc20Delegate,\n            bool allowResign,\n            bytes memory becomeImplementationData\n        );\n\n    function latestCEtherDelegate(address oldImplementation)\n        external\n        view\n        returns (\n            address cEtherDelegate,\n            bool allowResign,\n            bytes memory becomeImplementationData\n        );\n\n    function deployCEther(bytes calldata constructorData)\n        external\n        returns (address);\n\n    function deployCErc20(bytes calldata constructorData)\n        external\n        returns (address);\n\n    function() external payable;\n}\n"
    },
    "contracts/rari-fuse/src/core/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ncontract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/core/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract\n * @author Compound\n */\ncontract JumpRateModel is InterestRateModel {\n    using SafeMath for uint256;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink\n    );\n\n    /**\n     * @notice The approximate number of seconds per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 31536000; // 86400 seconds/day * 365 days/year\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) public {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n        kink = kink_;\n\n        emit NewInterestParams(\n            baseRatePerBlock,\n            multiplierPerBlock,\n            jumpMultiplierPerBlock,\n            kink\n        );\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(\n                baseRatePerBlock\n            );\n            uint256 excessUtil = util.sub(kink);\n            return\n                excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(\n                    normalRate\n                );\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(\n            reserveFactorMantissa\n        );\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return\n            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/JumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./BaseJumpRateModelV2.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract V2 for V2 cTokens\n * @author Arr00\n * @notice Supports only for V2 cTokens\n */\ncontract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2 {\n    /**\n     * @notice Calculates the current borrow rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256) {\n        return getBorrowRateInternal(cash, borrows, reserves);\n    }\n\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_\n    )\n        public\n        BaseJumpRateModelV2(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_,\n            owner_\n        )\n    {}\n}\n"
    },
    "contracts/rari-fuse/src/core/Maximillion.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's Maximillion Contract\n * @author Compound\n */\ncontract Maximillion {\n    /**\n     * @notice The default cEther market to repay in\n     */\n    CEther public cEther;\n\n    /**\n     * @notice Construct a Maximillion to repay max in a CEther market\n     */\n    constructor(CEther cEther_) public {\n        cEther = cEther_;\n    }\n\n    /**\n     * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     */\n    function repayBehalf(address borrower) public payable {\n        repayBehalfExplicit(borrower, cEther);\n    }\n\n    /**\n     * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     * @param cEther_ The address of the cEther contract to repay in\n     */\n    function repayBehalfExplicit(address borrower, CEther cEther_)\n        public\n        payable\n    {\n        uint256 received = msg.value;\n        uint256 borrows = cEther_.borrowBalanceCurrent(borrower);\n        if (received > borrows) {\n            cEther_.repayBorrowBehalf.value(borrows)(borrower);\n            msg.sender.transfer(received - borrows);\n        } else {\n            cEther_.repayBorrowBehalf.value(received)(borrower);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\n\ncontract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n     * @notice Get the underlying price of a cToken asset\n     * @param cToken The cToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n    function getUnderlyingPrice(CToken cToken) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/core/ReactiveJumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./BaseJumpRateModelV2.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract V2 for V2 cTokens\n * @author Arr00\n * @notice Supports only for V2 cTokens\n */\ncontract ReactiveJumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2 {\n    /**\n     * @notice CToken to react to\n     */\n    CToken public cToken;\n\n    /**\n     * @notice Buffer size of interest checkpoints\n     */\n    uint256 internal constant INTEREST_CHECKPOINT_BUFFER = 16;\n\n    /**\n     * @notice Number of interest checkpoints\n     */\n    uint256 internal interestCheckpointCount;\n\n    /**\n     * @notice Struct for interest checkpoints\n     */\n    struct InterestCheckpoint {\n        uint256 blockNumber;\n        uint256 borrowIndex;\n        uint256 borrowRateMantissa;\n    }\n\n    /**\n     * @notice Array of interest checkpoints\n     */\n    InterestCheckpoint[] internal interestCheckpoints;\n\n    /**\n     * @notice Calculates the current borrow rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256) {\n        return getBorrowRateInternal(cash, borrows, reserves);\n    }\n\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_,\n        address cToken_\n    )\n        public\n        BaseJumpRateModelV2(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_,\n            owner_\n        )\n    {\n        cToken = CToken(cToken_);\n    }\n\n    /**\n     * @dev Checkpoints the current borrow index and adjusts parameters based on the average borrow rate calculated from past checkpoints.\n     */\n    function checkpointInterest() external {\n        checkpointInterest(cToken.borrowRatePerBlock());\n    }\n\n    /**\n     * @dev Checkpoints the current borrow index and adjusts parameters based on the average borrow rate calculated from past checkpoints.\n     */\n    function checkpointInterest(uint256 borrowRateMantissa) public {\n        // Make sure the sender is the cToken\n        require(msg.sender == address(cToken));\n\n        // Get cToken variables\n        uint256 accrualBlockNumber = cToken.accrualBlockNumber();\n        uint256 borrowIndex = cToken.borrowIndex();\n\n        // Add latest interest checkpoint\n        InterestCheckpoint memory checkpointNow = InterestCheckpoint(\n            accrualBlockNumber,\n            borrowIndex,\n            borrowRateMantissa\n        );\n\n        // Check if the two latest checkpoints were within the last day\n        if (\n            interestCheckpointCount >= 2 &&\n            interestCheckpoints[\n                (interestCheckpointCount - 2) % INTEREST_CHECKPOINT_BUFFER\n            ].blockNumber >=\n            accrualBlockNumber.sub(6500)\n        ) {\n            // If yes, overwrite the last checkpoint\n            interestCheckpoints[\n                (interestCheckpointCount - 1) % INTEREST_CHECKPOINT_BUFFER\n            ] = checkpointNow;\n        } else {\n            // If not, add a fresh checkpoint\n            interestCheckpoints[\n                interestCheckpointCount % INTEREST_CHECKPOINT_BUFFER\n            ] = checkpointNow;\n            interestCheckpointCount++;\n\n            // Make sure earliest checkpoint is at least 6 days old\n            uint256 blockNumberSixDaysAgo = accrualBlockNumber.sub(6500 * 6);\n            if (\n                interestCheckpoints[\n                    interestCheckpointCount > INTEREST_CHECKPOINT_BUFFER\n                        ? interestCheckpointCount % INTEREST_CHECKPOINT_BUFFER\n                        : 0\n                ].blockNumber > blockNumberSixDaysAgo\n            ) return;\n\n            // Check interest checkpoints (assuming earliest checkpoint is at least 6 days old)\n            InterestCheckpoint memory interestCheckpoint;\n            bool checkpointNotOld = false;\n            uint256 i;\n\n            // Start looping from the oldest checkpoint\n            for (\n                i = interestCheckpointCount > INTEREST_CHECKPOINT_BUFFER\n                    ? interestCheckpointCount - INTEREST_CHECKPOINT_BUFFER\n                    : 0;\n                i < interestCheckpointCount;\n                i++\n            ) {\n                interestCheckpoint = interestCheckpoints[\n                    i % INTEREST_CHECKPOINT_BUFFER\n                ];\n\n                // If we can find a checkpoint within 1 day of a week ago (i.e., 6 to 8 days ago), use it\n                if (\n                    interestCheckpoint.blockNumber >=\n                    accrualBlockNumber.sub(6500 * 8) &&\n                    interestCheckpoint.blockNumber <= blockNumberSixDaysAgo\n                ) {\n                    checkpointNotOld = true;\n                    break;\n                }\n\n                // If we have looped too far (newer than 6 days ago), break so we use the previous (old) checkpoint\n                if (interestCheckpoint.blockNumber > blockNumberSixDaysAgo)\n                    break;\n            }\n\n            // If previous checkpoint is old (because either the loop ended or we broke the loop), find the interest rate at 7 days (using the previous checkpoint, which must be at least 8 days old given the above conditions)\n            if (!checkpointNotOld) {\n                interestCheckpoint = interestCheckpoints[\n                    (i - 1) % INTEREST_CHECKPOINT_BUFFER\n                ];\n                uint256 blockNumberOneWeekAgo = accrualBlockNumber.sub(\n                    6500 * 7\n                );\n                uint256 blockDelta = blockNumberOneWeekAgo.sub(\n                    interestCheckpoint.blockNumber\n                );\n                uint256 simpleInterestFactor = interestCheckpoint\n                    .borrowRateMantissa\n                    .mul(blockDelta);\n                interestCheckpoint = InterestCheckpoint(\n                    blockNumberOneWeekAgo,\n                    borrowIndex.add(\n                        borrowIndex.mul(simpleInterestFactor).div(1e18)\n                    ),\n                    interestCheckpoint.borrowRateMantissa\n                );\n            }\n\n            // Get average borrow rate per block over the last (roughly) one week\n            uint256 avgBorrowRateLastWeek = borrowIndex\n                .mul(1e18)\n                .div(interestCheckpoint.borrowIndex)\n                .sub(1e18);\n            uint256 avgBorrowRatePerBlock = avgBorrowRateLastWeek.div(\n                accrualBlockNumber.sub(interestCheckpoint.blockNumber)\n            );\n\n            // Get ideal JumpRateModel multiplierPerBlock param\n            uint256 idealMultiplierPerBlock = avgBorrowRatePerBlock <\n                baseRatePerBlock\n                ? 0\n                : avgBorrowRatePerBlock.sub(baseRatePerBlock).mul(1e18).div(\n                    kink.sub(0.05e18)\n                );\n\n            // Only reset params if idealMultiplierPerBlock differs from currentMultiplierPerBlock by >= 5%\n            uint256 ratio = idealMultiplierPerBlock.mul(1e18).div(\n                multiplierPerBlock\n            );\n\n            if (ratio <= 0.95e18 || ratio >= 1.05e18) {\n                // Set JumpRateModelV2 params (multiplying per-block values to per-year)\n                updateJumpRateModelInternal(\n                    baseRatePerBlock.mul(blocksPerYear),\n                    idealMultiplierPerBlock.mul(blocksPerYear.mul(kink)).div(\n                        1e18\n                    ), // Note that the JumpRateModelV2 computes multiplierPerBlock from muliplierPerYear differently than the JumpRateModel\n                    jumpMultiplierPerBlock.mul(blocksPerYear),\n                    kink\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Resets the interest checkpoint count to 0.\n     */\n    function resetInterestCheckpoints() external {\n        // Make sure the sender is the cToken\n        require(msg.sender == address(cToken));\n\n        // Reset checkpoint count to 0\n        interestCheckpointCount = 0;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title Reservoir Contract\n * @notice Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n    /// @notice The block timestamp when the Reservoir started (immutable)\n    uint256 public dripStart;\n\n    /// @notice Tokens per second that to drip to target (immutable)\n    uint256 public dripRate;\n\n    /// @notice Reference to token to drip (immutable)\n    EIP20Interface public token;\n\n    /// @notice Target to receive dripped tokens (immutable)\n    address public target;\n\n    /// @notice Amount that has already been dripped\n    uint256 public dripped;\n\n    /**\n     * @notice Constructs a Reservoir\n     * @param dripRate_ Numer of tokens per second to drip\n     * @param token_ The token to drip\n     * @param target_ The recipient of dripped tokens\n     */\n    constructor(\n        uint256 dripRate_,\n        EIP20Interface token_,\n        address target_\n    ) public {\n        require(dripRate_ > 0, \"Drip rate should be greater than 0.\");\n        require(address(token_) != address(0), \"Drip token not defined.\");\n        require(target_ != address(0), \"Drip target not defined.\");\n        dripStart = block.timestamp;\n        dripRate = dripRate_;\n        token = token_;\n        target = target_;\n        dripped = 0;\n    }\n\n    /**\n     * @notice Drips the maximum amount of tokens to match the drip rate since inception\n     * @dev Note: this will only drip up to the amount of tokens available.\n     * @return The amount of tokens dripped in this call\n     */\n    function drip() public returns (uint256) {\n        // First, read storage into memory\n        EIP20Interface token_ = token;\n        uint256 reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\n        uint256 dripRate_ = dripRate;\n        uint256 dripStart_ = dripStart;\n        uint256 dripped_ = dripped;\n        address target_ = target;\n        uint256 blockTimestamp_ = block.timestamp;\n\n        // Next, calculate intermediate values\n        uint256 dripTotal_ = mul(\n            dripRate_,\n            blockTimestamp_ - dripStart_,\n            \"dripTotal overflow\"\n        );\n        uint256 deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n        uint256 toDrip_ = min(reservoirBalance_, deltaDrip_);\n        uint256 drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n        // Finally, write new `dripped` value and transfer tokens to target\n        dripped = drippedNext_;\n        token_.transfer(target_, toDrip_);\n\n        return toDrip_;\n    }\n\n    /* Internal helper functions for safe math */\n\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n\nimport \"./EIP20Interface.sol\";\n"
    },
    "contracts/rari-fuse/src/core/RewardsDistributorDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"./Comptroller.sol\";\nimport \"./RewardsDistributorStorage.sol\";\n\n/**\n * @title RewardsDistributorDelegate (COMP distribution logic extracted from `Comptroller`)\n * @author Compound\n */\ncontract RewardsDistributorDelegate is\n    RewardsDistributorDelegateStorageV1,\n    ExponentialNoError\n{\n    /// @dev Notice that this contract is a RewardsDistributor\n    bool public constant isRewardsDistributor = true;\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompSupplySpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompBorrowSpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n    /// @notice Emitted when a new COMP speed is set for a contributor\n    event ContributorCompSpeedUpdated(\n        address indexed contributor,\n        uint256 newSpeed\n    );\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierComp(\n        CToken indexed cToken,\n        address indexed supplier,\n        uint256 compDelta,\n        uint256 compSupplyIndex\n    );\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerComp(\n        CToken indexed cToken,\n        address indexed borrower,\n        uint256 compDelta,\n        uint256 compBorrowIndex\n    );\n\n    /// @notice Emitted when COMP is granted by admin\n    event CompGranted(address recipient, uint256 amount);\n\n    /// @notice The initial COMP index for a market\n    uint216 public constant compInitialIndex = 1e36;\n\n    /// @dev Intitializer to set admin to caller and set reward token\n    function initialize(address _rewardToken) external {\n        require(msg.sender == admin, \"Only admin can initialize.\");\n        require(rewardToken == address(0), \"Already initialized.\");\n        require(\n            _rewardToken != address(0),\n            \"Cannot initialize reward token to the zero address.\"\n        );\n        rewardToken = _rewardToken;\n    }\n\n    /*** Set Admin ***/\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(\n            msg.sender == admin,\n            \"RewardsDistributor:_setPendingAdmin: admin only\"\n        );\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin  address(0)\n        require(\n            msg.sender == pendingAdmin && msg.sender != address(0),\n            \"RewardsDistributor:_acceptAdmin: pending admin only\"\n        );\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /*** Comp Distribution ***/\n\n    /**\n     * @notice Check the cToken before adding\n     * @param cToken The market to add\n     */\n    function checkCToken(CToken cToken) internal view {\n        // Make sure cToken is listed\n        Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n        (bool isListed, ) = comptroller.markets(address(cToken));\n        require(isListed == true, \"comp market is not listed\");\n\n        // Make sure distributor is added\n        bool distributorAdded = false;\n        address[] memory distributors = comptroller.getRewardsDistributors();\n        for (uint256 i = 0; i < distributors.length; i++)\n            if (distributors[i] == address(this)) distributorAdded = true;\n        require(distributorAdded == true, \"distributor not added\");\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompSupplySpeedInternal(CToken cToken, uint256 compSpeed)\n        internal\n    {\n        uint256 currentCompSpeed = compSupplySpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            updateCompSupplyIndex(address(cToken));\n        } else if (compSpeed != 0) {\n            // Make sure cToken is listed and distributor is added\n            checkCToken(cToken);\n\n            // Add the COMP market\n            if (compSupplyState[address(cToken)].index == 0) {\n                compSupplyState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe40(\n                        getBlockNumber(),\n                        \"block timestamp exceeds 40 bits\"\n                    )\n                });\n\n                // Add to allMarkets array if not already there\n                if (compBorrowState[address(cToken)].index == 0) {\n                    allMarkets.push(cToken);\n                }\n            } else {\n                // Update block number to ensure extra interest is not accrued during the prior period\n                compSupplyState[address(cToken)].block = safe40(\n                    getBlockNumber(),\n                    \"block timestamp exceeds 40 bits\"\n                );\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compSupplySpeeds[address(cToken)] = compSpeed;\n            emit CompSupplySpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function setCompBorrowSpeedInternal(CToken cToken, uint256 compSpeed)\n        internal\n    {\n        uint256 currentCompSpeed = compBorrowSpeeds[address(cToken)];\n        if (currentCompSpeed != 0) {\n            // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n            updateCompBorrowIndex(address(cToken), borrowIndex);\n        } else if (compSpeed != 0) {\n            // Make sure cToken is listed and distributor is added\n            checkCToken(cToken);\n\n            // Add the COMP market\n            if (compBorrowState[address(cToken)].index == 0) {\n                compBorrowState[address(cToken)] = CompMarketState({\n                    index: compInitialIndex,\n                    block: safe40(\n                        getBlockNumber(),\n                        \"block timestamp exceeds 40 bits\"\n                    )\n                });\n\n                // Add to allMarkets array if not already there\n                if (compSupplyState[address(cToken)].index == 0) {\n                    allMarkets.push(cToken);\n                }\n            } else {\n                // Update block number to ensure extra interest is not accrued during the prior period\n                compBorrowState[address(cToken)].block = safe40(\n                    getBlockNumber(),\n                    \"block timestamp exceeds 40 bits\"\n                );\n            }\n        }\n\n        if (currentCompSpeed != compSpeed) {\n            compBorrowSpeeds[address(cToken)] = compSpeed;\n            emit CompBorrowSpeedUpdated(cToken, compSpeed);\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     */\n    function updateCompSupplyIndex(address cToken) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        uint256 supplySpeed = compSupplySpeeds[cToken];\n        uint256 blockNumber = getBlockNumber();\n        uint256 deltaBlocks = sub_(blockNumber, uint256(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint256 supplyTokens = CToken(cToken).totalSupply();\n            uint256 compAccrued_ = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0\n                ? fraction(compAccrued_, supplyTokens)\n                : Double({mantissa: 0});\n            Double memory index = add_(\n                Double({mantissa: supplyState.index}),\n                ratio\n            );\n            compSupplyState[cToken] = CompMarketState({\n                index: safe216(index.mantissa, \"new index exceeds 216 bits\"),\n                block: safe40(blockNumber, \"block timestamp exceeds 40 bits\")\n            });\n        } else if (deltaBlocks > 0 && supplyState.index > 0) {\n            supplyState.block = safe40(\n                blockNumber,\n                \"block timestamp exceeds 40 bits\"\n            );\n        }\n    }\n\n    /**\n     * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     */\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex)\n        internal\n    {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        uint256 borrowSpeed = compBorrowSpeeds[cToken];\n        uint256 blockNumber = getBlockNumber();\n        uint256 deltaBlocks = sub_(blockNumber, uint256(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            uint256 borrowAmount = div_(\n                CToken(cToken).totalBorrows(),\n                marketBorrowIndex\n            );\n            uint256 compAccrued_ = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0\n                ? fraction(compAccrued_, borrowAmount)\n                : Double({mantissa: 0});\n            Double memory index = add_(\n                Double({mantissa: borrowState.index}),\n                ratio\n            );\n            compBorrowState[cToken] = CompMarketState({\n                index: safe216(index.mantissa, \"new index exceeds 216 bits\"),\n                block: safe40(blockNumber, \"block timestamp exceeds 40 bits\")\n            });\n        } else if (deltaBlocks > 0 && borrowState.index > 0) {\n            borrowState.block = safe40(\n                blockNumber,\n                \"block timestamp exceeds 40 bits\"\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n    function distributeSupplierComp(address cToken, address supplier) internal {\n        CompMarketState storage supplyState = compSupplyState[cToken];\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\n        Double memory supplierIndex = Double({\n            mantissa: compSupplierIndex[cToken][supplier]\n        });\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            // Set the supplier reward index to the initial reward index if it has never been set before.\n            // If it has never been set before, the supplier has not taken any action since the reward stream was set up, meaning they have been supplying the whole time, so their index should start at the beginning.\n            supplierIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint256 supplierTokens = CToken(cToken).balanceOf(supplier);\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n        uint256 supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n        compAccrued[supplier] = supplierAccrued;\n        emit DistributedSupplierComp(\n            CToken(cToken),\n            supplier,\n            supplierDelta,\n            supplyIndex.mantissa\n        );\n    }\n\n    /**\n     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n    function distributeBorrowerComp(\n        address cToken,\n        address borrower,\n        Exp memory marketBorrowIndex\n    ) internal {\n        CompMarketState storage borrowState = compBorrowState[cToken];\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\n        Double memory borrowerIndex = Double({\n            mantissa: compBorrowerIndex[cToken][borrower]\n        });\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) {\n            // Set the borrower reward index to the initial reward index if it has never been set before.\n            // If it has never been set before, the borrower has not taken any action since the reward stream was set up, meaning they have been borrowing the whole time, so their index should start at the beginning.\n            // (Originally, Compound set this up so that borrowers would not begin to accrue COMP until after the first interaction with the protocol.)\n            borrowerIndex.mantissa = compInitialIndex;\n        }\n\n        Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n        uint256 borrowerAmount = div_(\n            CToken(cToken).borrowBalanceStored(borrower),\n            marketBorrowIndex\n        );\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n        uint256 borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n        compAccrued[borrower] = borrowerAccrued;\n        emit DistributedBorrowerComp(\n            CToken(cToken),\n            borrower,\n            borrowerDelta,\n            borrowIndex.mantissa\n        );\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier)\n        external\n    {\n        if (compSupplyState[cToken].index > 0) {\n            updateCompSupplyIndex(cToken);\n            distributeSupplierComp(cToken, supplier);\n        }\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower)\n        external\n    {\n        if (compBorrowState[cToken].index > 0) {\n            Exp memory borrowIndex = Exp({\n                mantissa: CToken(cToken).borrowIndex()\n            });\n            updateCompBorrowIndex(cToken, borrowIndex);\n            distributeBorrowerComp(cToken, borrower, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Keeps the flywheel moving pre-transfer and pre-seize\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     */\n    function flywheelPreTransferAction(\n        address cToken,\n        address src,\n        address dst\n    ) external {\n        if (compSupplyState[cToken].index > 0) {\n            updateCompSupplyIndex(cToken);\n            distributeSupplierComp(cToken, src);\n            distributeSupplierComp(cToken, dst);\n        }\n    }\n\n    /**\n     * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n    function updateContributorRewards(address contributor) public {\n        uint256 compSpeed = compContributorSpeeds[contributor];\n        uint256 blockNumber = getBlockNumber();\n        uint256 deltaBlocks = sub_(\n            blockNumber,\n            lastContributorBlock[contributor]\n        );\n        if (deltaBlocks > 0 && compSpeed > 0) {\n            uint256 newAccrued = mul_(deltaBlocks, compSpeed);\n            uint256 contributorAccrued = add_(\n                compAccrued[contributor],\n                newAccrued\n            );\n\n            compAccrued[contributor] = contributorAccrued;\n            lastContributorBlock[contributor] = blockNumber;\n        }\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n    function claimRewards(address holder) public {\n        return claimRewards(holder, allMarkets);\n    }\n\n    /**\n     * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n    function claimRewards(address holder, CToken[] memory cTokens) public {\n        address[] memory holders = new address[](1);\n        holders[0] = holder;\n        claimRewards(holders, cTokens, true, true);\n    }\n\n    /**\n     * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n    function claimRewards(\n        address[] memory holders,\n        CToken[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) public {\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            if (\n                borrowers == true && compBorrowState[address(cToken)].index > 0\n            ) {\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\n                updateCompBorrowIndex(address(cToken), borrowIndex);\n                for (uint256 j = 0; j < holders.length; j++) {\n                    distributeBorrowerComp(\n                        address(cToken),\n                        holders[j],\n                        borrowIndex\n                    );\n                }\n            }\n            if (\n                suppliers == true && compSupplyState[address(cToken)].index > 0\n            ) {\n                updateCompSupplyIndex(address(cToken));\n                for (uint256 j = 0; j < holders.length; j++) {\n                    distributeSupplierComp(address(cToken), holders[j]);\n                }\n            }\n        }\n        for (uint256 j = 0; j < holders.length; j++) {\n            compAccrued[holders[j]] = grantCompInternal(\n                holders[j],\n                compAccrued[holders[j]]\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n    function grantCompInternal(address user, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n        uint256 compRemaining = comp.balanceOf(address(this));\n        if (amount > 0 && amount <= compRemaining) {\n            comp.transfer(user, amount);\n            return 0;\n        }\n        return amount;\n    }\n\n    /*** Comp Distribution Admin ***/\n\n    /**\n     * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n    function _grantComp(address recipient, uint256 amount) public {\n        require(msg.sender == admin, \"only admin can grant comp\");\n        uint256 amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompSupplySpeed(CToken cToken, uint256 compSpeed) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n        setCompSupplySpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n    function _setCompBorrowSpeed(CToken cToken, uint256 compSpeed) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n        setCompBorrowSpeedInternal(cToken, compSpeed);\n    }\n\n    /**\n     * @notice Set COMP borrow and supply speeds for the specified markets.\n     * @param cTokens The markets whose COMP speed to update.\n     * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n     * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n     */\n    function _setCompSpeeds(\n        CToken[] memory cTokens,\n        uint256[] memory supplySpeeds,\n        uint256[] memory borrowSpeeds\n    ) public {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n        uint256 numTokens = cTokens.length;\n        require(\n            numTokens == supplySpeeds.length &&\n                numTokens == borrowSpeeds.length,\n            \"RewardsDistributor::_setCompSpeeds invalid input\"\n        );\n\n        for (uint256 i = 0; i < numTokens; ++i) {\n            setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n            setCompBorrowSpeedInternal(cTokens[i], borrowSpeeds[i]);\n        }\n    }\n\n    /**\n     * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n    function _setContributorCompSpeed(address contributor, uint256 compSpeed)\n        public\n    {\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n        // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n        updateContributorRewards(contributor);\n        if (compSpeed == 0) {\n            // release storage\n            delete lastContributorBlock[contributor];\n        } else {\n            lastContributorBlock[contributor] = getBlockNumber();\n        }\n        compContributorSpeeds[contributor] = compSpeed;\n\n        emit ContributorCompSpeedUpdated(contributor, compSpeed);\n    }\n\n    /*** Helper Functions */\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     * @dev WARNING: On Citrus, it will return the timestamp instead.\n     *  It should not matter as long as you keep using this function.\n     */\n    function getBlockNumber() public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Returns an array of all markets.\n     */\n    function getAllMarkets() external view returns (CToken[] memory) {\n        return allMarkets;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/RewardsDistributorDelegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./RewardsDistributorStorage.sol\";\n\ncontract RewardsDistributorDelegator is RewardsDistributorDelegatorStorage {\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(\n        address oldImplementation,\n        address newImplementation\n    );\n\n    constructor(\n        address admin_,\n        address rewardToken_,\n        address implementation_\n    ) public {\n        // Admin set to msg.sender for initialization\n        admin = msg.sender;\n\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\"initialize(address)\", rewardToken_)\n        );\n\n        _setImplementation(implementation_);\n\n        admin = admin_;\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function _setImplementation(address implementation_) public {\n        require(\n            msg.sender == admin,\n            \"RewardsDistributorDelegator::_setImplementation: admin only\"\n        );\n        require(\n            implementation_ != address(0),\n            \"RewardsDistributorDelegator::_setImplementation: invalid implementation address\"\n        );\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function() external payable {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize)\n            }\n            default {\n                return(free_mem_ptr, returndatasize)\n            }\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/RewardsDistributorStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./CToken.sol\";\n\ncontract RewardsDistributorDelegatorStorage {\n    /// @notice Administrator for this contract\n    address public admin;\n\n    /// @notice Pending administrator for this contract\n    address public pendingAdmin;\n\n    /// @notice Active brains of RewardsDistributor\n    address public implementation;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n\n/**\n * @title Storage for RewardsDistributorDelegate\n * @notice For future upgrades, do not change RewardsDistributorDelegateStorageV1. Create a new\n * contract which implements RewardsDistributorDelegateStorageV1 and following the naming convention\n * RewardsDistributorDelegateStorageVX.\n */\ncontract RewardsDistributorDelegateStorageV1 is\n    RewardsDistributorDelegatorStorage\n{\n    /// @dev The token to reward (i.e., COMP)\n    address public rewardToken;\n\n    struct CompMarketState {\n        /// @notice The market's last updated compBorrowIndex or compSupplyIndex\n        uint216 index;\n        /// @notice The block number the index was last updated at\n        /// @dev WARNING: On Citrus, this is a timestamp\n        uint40 block;\n    }\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /// @notice Rewards per block that each market currently receives\n    mapping(address => uint256) public compSupplySpeeds;\n\n    /// @notice Rewards per block that each market currently receives\n    mapping(address => uint256) public compBorrowSpeeds;\n\n    /// @notice The COMP market supply state for each market\n    mapping(address => CompMarketState) public compSupplyState;\n\n    /// @notice The COMP market borrow state for each market\n    mapping(address => CompMarketState) public compBorrowState;\n\n    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n    mapping(address => mapping(address => uint256)) public compSupplierIndex;\n\n    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n    mapping(address => mapping(address => uint256)) public compBorrowerIndex;\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    mapping(address => uint256) public compAccrued;\n\n    /// @notice The portion of COMP that each contributor receives per second\n    mapping(address => uint256) public compContributorSpeeds;\n\n    /// @notice Last timestamp at which a contributor's COMP rewards have been allocated\n    /// @dev WARNING: On Citrus, this is a timestamp\n    mapping(address => uint256) public lastContributorBlock;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[10] private __gap;\n}\n"
    },
    "contracts/rari-fuse/src/core/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./PriceOracle.sol\";\nimport \"./CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n    mapping(address => uint256) prices;\n    event PricePosted(\n        address asset,\n        uint256 previousPriceMantissa,\n        uint256 requestedPriceMantissa,\n        uint256 newPriceMantissa\n    );\n\n    function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n        if (compareStrings(cToken.symbol(), \"cETH\")) {\n            return 1e18;\n        } else {\n            return prices[address(CErc20(address(cToken)).underlying())];\n        }\n    }\n\n    function setUnderlyingPrice(CToken cToken, uint256 underlyingPriceMantissa)\n        public\n    {\n        address asset = address(CErc20(address(cToken)).underlying());\n        emit PricePosted(\n            asset,\n            prices[asset],\n            underlyingPriceMantissa,\n            underlyingPriceMantissa\n        );\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint256 price) public {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    // v1 price oracle interface for use as backing of proxy\n    function assetPrices(address asset) external view returns (uint256) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return (keccak256(abi.encodePacked((a))) ==\n            keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/Timelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) public {\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setDelay: Call must come from Timelock.\"\n        );\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"Timelock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, value, signature, data, eta)\n        );\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(\n            msg.sender == admin,\n            \"Timelock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, value, signature, data, eta)\n        );\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"Timelock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, value, signature, data, eta)\n        );\n        require(\n            queuedTransactions[txHash],\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n            \"Timelock::executeTransaction: Transaction is stale.\"\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(\n                bytes4(keccak256(bytes(signature))),\n                data\n            );\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(\n            callData\n        );\n        require(\n            success,\n            \"Timelock::executeTransaction: Transaction execution reverted.\"\n        );\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is changed\n     */\n    event NewPendingImplementation(\n        address oldPendingImplementation,\n        address newPendingImplementation\n    );\n\n    /**\n     * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n     */\n    event NewImplementation(\n        address oldImplementation,\n        address newImplementation\n    );\n\n    /**\n     * @notice Event emitted when the Fuse admin rights are changed\n     */\n    event FuseAdminRightsToggled(bool hasRights);\n\n    /**\n     * @notice Event emitted when the admin rights are changed\n     */\n    event AdminRightsToggled(bool hasRights);\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() public {\n        // Set admin to caller\n        admin = msg.sender;\n        fuseAdmin = IFuseFeeDistributor(\n            0x00E4B82310d794f8312ddeC83AA594545FA8d222\n        );\n    }\n\n    /*** Admin Functions ***/\n\n    function _setPendingImplementation(address newPendingImplementation)\n        public\n        returns (uint256)\n    {\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK\n                );\n        }\n\n        if (\n            !fuseAdmin.comptrollerImplementationWhitelist(\n                comptrollerImplementation,\n                newPendingImplementation\n            )\n        ) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK\n                );\n        }\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(\n            oldPendingImplementation,\n            pendingComptrollerImplementation\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() public returns (uint256) {\n        // Check caller is pendingImplementation and pendingImplementation  address(0)\n        if (\n            msg.sender != pendingComptrollerImplementation ||\n            pendingComptrollerImplementation == address(0)\n        ) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK\n                );\n        }\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(\n            oldPendingImplementation,\n            pendingComptrollerImplementation\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Toggles Fuse admin rights.\n     * @param hasRights Boolean indicating if the Fuse admin is to have rights.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _toggleFuseAdminRights(bool hasRights) external returns (uint256) {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK\n                );\n        }\n\n        // Check that rights have not already been set to the desired value\n        if (fuseAdminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n        // Set fuseAdminHasRights\n        fuseAdminHasRights = hasRights;\n\n        // Emit FuseAdminRightsToggled()\n        emit FuseAdminRightsToggled(fuseAdminHasRights);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Toggles admin rights.\n     * @param hasRights Boolean indicating if the admin is to have rights.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _toggleAdminRights(bool hasRights) external returns (uint256) {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK\n                );\n        }\n\n        // Check that rights have not already been set to the desired value\n        if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n        // Set adminHasRights\n        adminHasRights = hasRights;\n\n        // Emit AdminRightsToggled()\n        emit AdminRightsToggled(hasRights);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPendingAdmin(address newPendingAdmin)\n        public\n        returns (uint256)\n    {\n        // Check caller = admin\n        if (!hasAdminRights()) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK\n                );\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint256) {\n        // Check caller is pendingAdmin and pendingAdmin  address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return\n                fail(\n                    Error.UNAUTHORIZED,\n                    FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK\n                );\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function() external payable {\n        // Check for automatic implementation\n        if (msg.sender != address(this)) {\n            (bool callSuccess, bytes memory data) = address(this).staticcall(\n                abi.encodeWithSignature(\"autoImplementation()\")\n            );\n            bool autoImplementation;\n            if (callSuccess) (autoImplementation) = abi.decode(data, (bool));\n\n            if (autoImplementation) {\n                address latestComptrollerImplementation = fuseAdmin\n                    .latestComptrollerImplementation(comptrollerImplementation);\n\n                if (\n                    comptrollerImplementation != latestComptrollerImplementation\n                ) {\n                    address oldImplementation = comptrollerImplementation; // Save current value for inclusion in log\n                    comptrollerImplementation = latestComptrollerImplementation;\n                    emit NewImplementation(\n                        oldImplementation,\n                        comptrollerImplementation\n                    );\n                }\n            }\n        }\n\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize)\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize)\n            }\n            default {\n                return(free_mem_ptr, returndatasize)\n            }\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/core/UnitrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\n/**\n * @title UnitrollerInterface\n */\ncontract UnitrollerInterface {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Whether or not the Fuse admin has admin rights\n     */\n    bool public fuseAdminHasRights;\n\n    /**\n     * @notice Whether or not the admin has admin rights\n     */\n    bool public adminHasRights;\n\n    /**\n     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptImplementation() external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/core/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.5.17;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's WhitePaperInterestRateModel Contract\n * @author Compound\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n    using SafeMath for uint256;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock\n    );\n\n    /**\n     * @notice The approximate number of seconds per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 31536000; // 86400 seconds/day * 365 days/year\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     */\n    constructor(uint256 baseRatePerYear, uint256 multiplierPerYear) public {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public view returns (uint256) {\n        uint256 ur = utilizationRate(cash, borrows, reserves);\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(\n            reserveFactorMantissa\n        );\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return\n            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
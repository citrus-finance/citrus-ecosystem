{
  "language": "Solidity",
  "sources": {
    "contracts/ERC4626-router/lib/solmate/src/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    event Debug(bool one, bool two, uint256 retsize);\n\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/ERC4626-router/src/xERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../lib/solmate/src/mixins/ERC4626.sol\";\nimport \"../lib/solmate/src/utils/SafeCastLib.sol\";\n\nimport \"./interfaces/IxERC4626.sol\";\n\n/** \n @title  An xERC4626 Single Staking Contract\n @notice This contract allows users to autocompound rewards denominated in an underlying reward token. \n         It is fully compatible with [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) allowing for DeFi composability.\n         It maintains balances using internal accounting to prevent instantaneous changes in the exchange rate.\n         NOTE: an exception is at contract creation, when a reward cycle begins before the first deposit. After the first deposit, exchange rate updates smoothly.\n\n         Operates on \"cycles\" which distribute the rewards surplus over the internal balance to users linearly over the remainder of the cycle window.\n*/\nabstract contract xERC4626 is IxERC4626, ERC4626 {\n    using SafeCastLib for *;\n\n    /// @notice the maximum length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    /// @notice the effective start of the current cycle\n    uint32 public lastSync;\n\n    /// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n    uint32 public rewardsCycleEnd;\n\n    /// @notice the amount of rewards distributed in a the most recent cycle.\n    uint192 public lastRewardAmount;\n\n    uint256 internal storedTotalAssets;\n\n    constructor(uint32 _rewardsCycleLength) {\n        rewardsCycleLength = _rewardsCycleLength;\n        // seed initial rewardsCycleEnd\n        rewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n    }\n\n    /// @notice Compute the amount of tokens available to share holders.\n    ///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n    function totalAssets() public view override returns (uint256) {\n        // cache global vars\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 rewardsCycleEnd_ = rewardsCycleEnd;\n        uint32 lastSync_ = lastSync;\n\n        if (block.timestamp >= rewardsCycleEnd_) {\n            // no rewards or rewards fully unlocked\n            // entire reward amount is available\n            return storedTotalAssets_ + lastRewardAmount_;\n        }\n\n        // rewards not fully unlocked\n        // add unlocked rewards to stored total\n        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n        return storedTotalAssets_ + unlockedRewards;\n    }\n\n    // Update storedTotalAssets on withdraw/redeem\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n        super.beforeWithdraw(amount, shares);\n        storedTotalAssets -= amount;\n    }\n\n    // Update storedTotalAssets on deposit/mint\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual override {\n        storedTotalAssets += amount;\n        super.afterDeposit(amount, shares);\n    }\n\n    /// @notice Distributes rewards to xERC4626 holders.\n    /// All surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n    function syncRewards() public virtual {\n        uint192 lastRewardAmount_ = lastRewardAmount;\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        if (timestamp < rewardsCycleEnd) revert SyncError();\n\n        uint256 storedTotalAssets_ = storedTotalAssets;\n        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;\n\n        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n\n        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n        // Combined single SSTORE\n        lastRewardAmount = nextRewards.safeCastTo192();\n        lastSync = timestamp;\n        rewardsCycleEnd = end;\n\n        emit NewRewardsCycle(end, nextRewards);\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/ERC4626-router/src/interfaces/IxERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../lib/solmate/src/mixins/ERC4626.sol\";\nimport \"../../lib/solmate/src/utils/SafeCastLib.sol\";\n\n/** \n @title  An xERC4626 Single Staking Contract Interface\n @notice This contract allows users to autocompound rewards denominated in an underlying reward token. \n         It is fully compatible with [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) allowing for DeFi composability.\n         It maintains balances using internal accounting to prevent instantaneous changes in the exchange rate.\n         NOTE: an exception is at contract creation, when a reward cycle begins before the first deposit. After the first deposit, exchange rate updates smoothly.\n\n         Operates on \"cycles\" which distribute the rewards surplus over the internal balance to users linearly over the remainder of the cycle window.\n*/\ninterface IxERC4626 {\n    /*////////////////////////////////////////////////////////\n                        Custom Errors\n    ////////////////////////////////////////////////////////*/\n\n    /// @dev thrown when syncing before cycle ends.\n    error SyncError();\n\n    /*////////////////////////////////////////////////////////\n                            Events\n    ////////////////////////////////////////////////////////*/\n\n    /// @dev emit every time a new rewards cycle starts\n    event NewRewardsCycle(uint32 indexed cycleEnd, uint256 rewardAmount);\n\n    /*////////////////////////////////////////////////////////\n                        View Methods\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice the maximum length of a rewards cycle\n    function rewardsCycleLength() external view returns (uint32);\n\n    /// @notice the effective start of the current cycle\n    /// NOTE: This will likely be after `rewardsCycleEnd - rewardsCycleLength` as this is set as block.timestamp of the last `syncRewards` call.\n    function lastSync() external view returns (uint32);\n\n    /// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n    function rewardsCycleEnd() external view returns (uint32);\n\n    /// @notice the amount of rewards distributed in a the most recent cycle\n    function lastRewardAmount() external view returns (uint192);\n\n    /*////////////////////////////////////////////////////////\n                    State Changing Methods\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice Distributes rewards to xERC4626 holders.\n    /// All surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n    function syncRewards() external;\n}\n"
    },
    "contracts/ERC4626-router/src/external/PeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n @title Periphery Payments\n @notice Immutable state used by periphery contracts\n Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol \n Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n*/ \nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    IWETH9 public immutable WETH9;\n\n    constructor(IWETH9 _WETH9) {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {}\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            recipient.safeTransferETH(balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) WETH9.deposit{value: address(this).balance}(); // wrap everything\n    }\n\n    function pullToken(ERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(\n        ERC20 token,\n        uint256 amountMinimum,\n        address recipient\n    ) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n}\n\nabstract contract IWETH9 is ERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable virtual;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external virtual;\n}"
    },
    "contracts/ERC4626-router/src/external/Multicall.sol": {
      "content": "// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.6;\n\nimport './interfaces/IMulticall.sol';\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}"
    },
    "contracts/ERC4626-router/src/external/interfaces/IMulticall.sol": {
      "content": "// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IMulticall.sol\n   \n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/ERC4626-router/src/external/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {ERC20} from \"../../lib/solmate/src/tokens/ERC20.sol\";\n\nimport './interfaces/ISelfPermit.sol';\nimport './interfaces/IERC20PermitAllowed.sol';\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\n/// that requires an approval in a single transaction.\nabstract contract SelfPermit is ISelfPermit {\n    /// @inheritdoc ISelfPermit\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        ERC20(token).permit(msg.sender, address(this), value, deadline, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        if (ERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        if (ERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\n    }\n}\n"
    },
    "contracts/ERC4626-router/src/external/interfaces/ISelfPermit.sol": {
      "content": "// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISelfPermit.sol\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/ERC4626-router/src/external/interfaces/IERC20PermitAllowed.sol": {
      "content": "// forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC20PermitAllowed.sol\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for permit\n/// @notice Interface used by DAI/CHAI for permit\ninterface IERC20PermitAllowed {\n    /// @notice Approve the spender to spend some tokens via the holder signature\n    /// @dev This is the permit interface used by DAI and CHAI\n    /// @param holder The address of the token holder, the token owner\n    /// @param spender The address of the token spender\n    /// @param nonce The holder's nonce, increases at each call to permit\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
    },
    "contracts/ERC4626-router/lib/solmate/src/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/ERC4626-router/lib/solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    },
    "contracts/ERC4626-router/src/utils/ENSReverseRecord.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\ninterface IReverseRegistrar {\n    /**\n     @notice sets reverse ENS Record\n     @param name the ENS record to set\n     After calling this, a user has a fully configured reverse record claiming the provided name as that account's canonical name.\n     */\n    function setName(string memory name) external returns (bytes32);\n}\n\n/**\n @title helper contract to set reverse ens record \n @notice sets reverse ENS record against canonical ReverseRegistrar https://docs.ens.domains/contract-api-reference/reverseregistrar.\n*/\nabstract contract ENSReverseRecord {\n\n    /// @notice the ENS Reverse Registrar\n    IReverseRegistrar public constant REVERSE_REGISTRAR = IReverseRegistrar(0x084b1c3C81545d370f3634392De611CaaBFf8148);\n\n    constructor(string memory name) {\n        if (bytes(name).length != 0) setENSName(name);\n    }\n\n    function setENSName(string memory name) private {\n        REVERSE_REGISTRAR.setName(name);\n    }\n}"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract BaseBoringBatchable {\n    error BatchError(bytes innerError);\n\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure{\n        // If the _res length is less than 68, then\n        // the transaction failed with custom error or silently (without a revert message)\n        if (_returnData.length < 68) revert BatchError(_returnData);\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                _getRevertMsg(result);\n            }\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/citrus-vaults/src/Aave2LeveragedVault.sol": {
      "content": "// SPDX-License-Identifier: None\npragma solidity >=0.8.0;\n\nimport \"../lib/BoringSolidity/contracts/interfaces/IERC20.sol\";\n\nimport \"./external/aave-v2/IAToken.sol\";\nimport \"./external/aave-v2/ILendingPool.sol\";\nimport \"./external/aave-v2/IAaveIncentivesController.sol\";\n\nimport \"./mixins/LeveragedLendingVault.sol\";\n\n\ncontract Aave2LeveragedVault is LeveragedLendingVault {\n    ILendingPool lendingPool;\n    \n    IAaveIncentivesController incentivesController;\n\n    IERC20 aToken;\n    \n    IERC20 debtToken;\n    \n    constructor(\n        ERC20 asset,\n        string memory name,\n        string memory symbol,\n        ILendingPool _lendingPool,\n        IAaveIncentivesController _incentivesController\n    ) LeveragedLendingVault(asset, name, symbol) {\n        lendingPool = _lendingPool;\n        incentivesController = _incentivesController;\n\n        DataTypes.ReserveData memory data = lendingPool.getReserveData(address(asset));\n\n        aToken = IERC20(data.aTokenAddress);\n        debtToken = IERC20(data.variableDebtTokenAddress);\n\n        asset.approve(address(lendingPool), type(uint256).max);\n    }\n\n    function getSuppliedToProtocol() public override view returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function getBorrowedFromProtocol() public override view returns (uint256) {\n        return debtToken.balanceOf(address(this));\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        lendingPool.deposit(address(asset), amount, address(this), 0);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        lendingPool.withdraw(address(asset), amount, address(this));\n    }\n\n    function borrowFromProtocol(uint256 amount) internal override {\n        lendingPool.borrow(address(asset), amount, 2, 0, address(this));\n    }\n\n    function repayToProtocol(uint256 amount) internal override {\n        lendingPool.repay(address(asset), amount, 2, address(this));\n    }\n\n    function getProtocolLiquidity() public override view returns (uint256) {\n        return aToken.totalSupply() - debtToken.totalSupply();\n    }\n\n    function getRemainingProtocolSupplyCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function getRemainingProtocolBorrowCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function collectHarvest() internal override {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        incentivesController.claimRewards(\n            assets,\n            incentivesController.getRewardsBalance(assets, address(this)),\n            address(this)\n        );\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory) {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        address rewardToken = incentivesController.REWARD_TOKEN();\n        uint256 amount = incentivesController.getRewardsBalance(assets, address(this));\n\n        Harvestable[] memory arr = new Harvestable[](1);\n        arr[0] = Harvestable({\n            token: rewardToken,\n            amount: amount\n        });\n        return arr;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/external/aave-v2/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nimport \"./IAaveIncentivesController.sol\";\n\ninterface IAToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param from The address performing the mint\n   * @param value The amount being\n   * @param index The new liquidity index of the reserve\n   **/\n  event Mint(address indexed from, uint256 value, uint256 index);\n\n  /**\n   * @dev Mints `amount` aTokens to `user`\n   * @param user The address receiving the minted tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address user,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted after aTokens are burned\n   * @param from The owner of the aTokens, getting them burned\n   * @param target The address that will receive the underlying\n   * @param value The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The amount being transferred\n   * @param index The new liquidity index of the reserve\n   **/\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @param user The owner of the aTokens, getting them burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The new liquidity index of the reserve\n   **/\n  function burn(\n    address user,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @dev Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The new liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   **/\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n   * assets in borrow(), withdraw() and flashLoan()\n   * @param user The recipient of the underlying\n   * @param amount The amount getting transferred\n   * @return The amount transferred\n   **/\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev Invoked to execute actions on the aToken side after a repayment.\n   * @param user The user executing the repayment\n   * @param amount The amount getting repaid\n   **/\n  function handleRepayment(address user, uint256 amount) external;\n\n  /**\n   * @dev Returns the address of the incentives controller contract\n   **/\n  function getIncentivesController() external view returns (IAaveIncentivesController);\n\n  /**\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   **/\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\ninterface IAaveIncentivesController {\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  event RewardsClaimed(\n    address indexed user,\n    address indexed to,\n    address indexed claimer,\n    uint256 amount\n  );\n\n  event ClaimerSet(address indexed user, address indexed claimer);\n\n  /*\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function getAssetData(address asset)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /*\n   * LEGACY **************************\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function assets(address asset)\n    external\n    view\n    returns (\n      uint128,\n      uint128,\n      uint256\n    );\n\n  /**\n   * @dev Whitelists an address to claim the rewards on behalf of another address\n   * @param user The address of the user\n   * @param claimer The address of the claimer\n   */\n  function setClaimer(address user, address claimer) external;\n\n  /**\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n   * @param user The address of the user\n   * @return The claimer address\n   */\n  function getClaimer(address user) external view returns (address);\n\n  /**\n   * @dev Configure assets for a certain rewards emission\n   * @param assets The assets to incentivize\n   * @param emissionsPerSecond The emission for each asset\n   */\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param asset The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleAction(\n    address asset,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @param asset The asset to incentivize\n   * @return the user index for the asset\n   */\n  function getUserAssetData(address user, address asset) external view returns (uint256);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function REWARD_TOKEN() external view returns (address);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function PRECISION() external view returns (uint8);\n\n  /**\n   * @dev Gets the distribution end timestamp of the emissions\n   */\n  function DISTRIBUTION_END() external view returns (uint256);\n}"
    },
    "contracts/citrus-vaults/src/mixins/LeveragedLendingVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./Vault.sol\";\n\nabstract contract LeveragedLendingVault is Vault {\n    uint256 targetCollateralRatio;\n\n    uint256 maxCollateralRatio;\n\n    event TargetCollateralRatioUpdated(uint256 oldTargetCollateralRatio, uint256 newTargetCollateralRatio);\n\n    event MaxCollateralRatioUpdated(uint256 oldMaxCollateralRatio, uint256 newMaxCollateralRatio);\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) Vault(_asset, _name, _symbol) {}\n\n    /////  Leverage logic  /////\n\n    function rebalance(uint256 amountToFreeUp, bool totalRampUp) internal {\n        uint256 assetBalance = asset.balanceOf(address(this));\n\n        if (assetBalance > 0) {\n            supplyToProtocol(assetBalance);\n        }\n\n        uint256 borrowed = getBorrowedFromProtocol();\n        uint256 supplied = getSuppliedToProtocol();\n        uint256 targetBorrow =  FixedPointMathLib.mulDivDown(targetCollateralRatio, supplied - borrowed - amountToFreeUp, 1e18 - targetCollateralRatio);\n\n        if (borrowed < targetBorrow) {\n            // ramp up\n            while(borrowed * 1e18 < targetBorrow * 0.995e18) {\n                uint256 toBorrow = targetBorrow - borrowed;\n                uint256 maxBorrow = FixedPointMathLib.mulDivDown(supplied, maxCollateralRatio, 1e18) - borrowed;\n\n                if (toBorrow > maxBorrow) {\n                    toBorrow = maxBorrow;\n                }\n\n                borrowFromProtocol(toBorrow);\n                supplyToProtocol(toBorrow);\n\n                if (!totalRampUp) {\n                    break;\n                }\n\n                borrowed = getBorrowedFromProtocol();\n                supplied = getSuppliedToProtocol();\n            }\n        } else if (borrowed > targetBorrow) {\n            // ramp down\n            while(borrowed * 1e18 > targetBorrow * 1.005e18) {\n                uint256 toRepay = borrowed - targetBorrow;\n                uint256 maxRepay = FixedPointMathLib.mulDivDown(supplied, maxCollateralRatio, 1e18) - borrowed;\n\n                if (toRepay > maxRepay) {\n                    toRepay = maxRepay;\n                }\n                \n                redeemFromProtocol(toRepay);\n                repayToProtocol(toRepay);\n\n                borrowed = getBorrowedFromProtocol();\n                supplied = getSuppliedToProtocol();\n            }\n        }\n\n        if (amountToFreeUp > 0) {\n            redeemFromProtocol(amountToFreeUp);\n        }\n    }\n\n    function rebalance() public {\n        rebalance(0, true);\n    }\n\n    /////  Vault hooks  /////\n\n    function onDeposit(uint256) internal override {\n        rebalance(0, false);\n    }\n\n    function onWithdraw(uint256 assets) internal override {\n        rebalance(assets, false);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) + getSuppliedToProtocol() - getBorrowedFromProtocol();\n    }\n\n    function onHarvest() internal override {\n        collectHarvest();\n    }\n\n    function afterHarvest() internal override {\n        rebalance(0, true);\n    }\n\n    /////  Collateral ratios  /////\n\n    function setMaxCollateralRatio(uint256 newMaxCollateralRatio) public onlyManagerOrOwner {\n        uint oldMaxCollateralRatio = maxCollateralRatio;\n\n        require(msg.sender == owner || newMaxCollateralRatio < oldMaxCollateralRatio, \"Only Owner can raise maxCollateralRatio\");\n\n        maxCollateralRatio = newMaxCollateralRatio;\n        emit MaxCollateralRatioUpdated(oldMaxCollateralRatio, newMaxCollateralRatio);\n    }\n\n    function setTargetCollateralRatio(uint256 newTargetCollateralRatio) public onlyManagerOrOwner {\n        require(newTargetCollateralRatio < maxCollateralRatio, \"Cannot set targetCollateralRatio over maxCollateralRatio\");\n        emit TargetCollateralRatioUpdated(targetCollateralRatio, newTargetCollateralRatio);\n        targetCollateralRatio = newTargetCollateralRatio;\n    }\n\n    /////  Hooks  /////\n\n    /**\n     * @notice Get amount of assets supplied to the protocol by the vault\n     * @return Assets supplied\n     */\n    function getSuppliedToProtocol() public virtual view returns (uint256);\n\n    /**\n     * @notice Get amount of assets borrowed from the protocol by the vault\n     * @return Assets borrowed\n     */\n    function getBorrowedFromProtocol() public virtual view returns (uint256);\n\n    /**\n     * @notice Supply assets to protocol\n     * @param amount Assets to supply to the protocol\n     */\n    function supplyToProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Withdraw assets from protocol\n     * @param amount Assets to redeem from the protocol\n     */\n    function redeemFromProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Borrow assets from protocol\n     * @param amount Assets to borrow from the protocol\n     */\n    function borrowFromProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Repay debt to protocol\n     * @param amount Assets to repay to the protocol\n     */\n    function repayToProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Get liquidity availailable in the protocol\n     * @return liquidity The diff\n     * @dev ignored on this version\n     */\n    function getProtocolLiquidity() public virtual view returns (uint256);\n\n    /**\n     * @notice Get remaining supply cap in the protocol\n     * @return remainingSupplyCap\n     * @dev ignored on this version\n     * @dev should return 0 if the supply cap is exhausted\n     */\n    function getRemainingProtocolSupplyCap() public virtual view returns (uint256);\n\n    /**\n     * @notice Get remaining borrow cap in the protocol\n     * @return remainingBorrowCap\n     * @dev ignored on this version\n     * @dev should return 0 if the borrow cap is exhausted\n     */\n    function getRemainingProtocolBorrowCap() public virtual view returns (uint256);\n\n    /**\n     * @notice Colect rewards token from protocol\n     */\n    function collectHarvest() internal virtual {}\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}"
    },
    "contracts/citrus-vaults/src/mixins/Vault.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"../../lib/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"../../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"../../lib/BoringSolidity/contracts/BoringOwnable.sol\";\n\nstruct HarvestCall {\n    address target;\n    bytes callData;\n}\n\nstruct Harvestable {\n    address token;\n    uint256 amount;\n}\n\nstruct HarvestCheckpoint {\n    // rolling block timestamp\n    uint32 blockTimestamp;\n\n    // rolling amount of assets per share\n    uint224 assetsPerShare;\n}\n\nabstract contract Vault is ERC4626, BoringOwnable {\n    using FixedPointMathLib for uint256;\n\n    event UpdateFeeExclusion(address user, bool excluded);\n    event UpdateHarvestCallAuthorisation(address target, bytes4 sig, bool allowed);\n    event Harvest(uint assetsPerShare, uint sharesToHarvester);\n\n    // @notice The manager is allowed to perform some privileged actions on the vault, \n    address public manager;\n\n    // @notice This address receive all fees captured by this vault\n    address public feeTaker;\n\n    // @notice Percentage the user has to pay to withdraw. 1e18 is 100%\n    uint256 public withdrawalFee;\n\n    // @notice Harvesting generate . 1e18 is 100%\n    uint256 public harvestFee;\n\n    HarvestCheckpoint[] public harvestCheckpoints;\n\n    mapping(address => bool) public excludedFromFees;\n\n    mapping(address=> mapping(bytes4 => bool)) harvesAllowedCalls;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_asset, _name, _symbol) {\n        harvestCheckpoints.push(HarvestCheckpoint({\n            blockTimestamp: uint32(block.timestamp),\n            assetsPerShare: uint224(convertToAssets(10 ** decimals))\n        }));\n    }\n\n    /////  Harvest  /////\n\n    // modified version of: https://github.com/makerdao/multicall/blob/1e1b44362640820bef92d0ccf5eeee25d9b41474/src/Multicall.sol#L17-L25\n    // @dev The caller could steal the harvest but should not be able to steal any of the deposited funds.\n    // Stealing the harvest would result in bad PR and users withdrawing their funds without losing their principal.\n    function harvest(HarvestCall[] memory calls) public virtual onlyManager returns (bytes[] memory returnData) {\n        uint256 balanceBefore = totalAssets();\n\n        onHarvest();\n\n        returnData = new bytes[](calls.length);\n        for(uint256 i = 0; i < calls.length; i++) {\n            require(harvesAllowedCalls[calls[i].target][bytes4(calls[i].callData)], \"method not whitelisted\");\n\n            bool success;\n            bytes memory ret;\n\n            (success, ret) = calls[i].target.delegatecall(calls[i].callData);\n            \n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (ret.length < 68) revert();\n                assembly {\n                    ret := add(ret, 0x04)\n                }\n                revert(abi.decode(ret, (string)));\n            }\n\n            returnData[i] = ret;\n        }\n\n        uint256 balanceAfter = totalAssets();\n\n        require(balanceAfter >= balanceBefore, \"negative harvest\");\n        uint256 diffBalance;\n        unchecked {\n          diffBalance = balanceAfter - balanceBefore;\n        }\n\n        uint256 denom = balanceBefore + (diffBalance.mulDivUp(1e18 - harvestFee, 1e18));\n        uint256 harveterShares = totalSupply.mulDivDown(balanceAfter, denom) - totalSupply;\n\n        _mint(feeTaker, harveterShares);\n\n        uint256 assetsPerShare = convertToAssets(10 ** decimals);\n        harvestCheckpoints.push(HarvestCheckpoint({\n            blockTimestamp: uint32(block.timestamp),\n            assetsPerShare: uint224(assetsPerShare)\n        }));\n        emit Harvest(assetsPerShare, harveterShares);\n\n        afterHarvest();\n    }\n\n    function allowHarvestCall(address target, bytes4 sig, bool allowed) public onlyOwner {\n        harvesAllowedCalls[target][sig] = allowed;\n        emit UpdateHarvestCallAuthorisation(target, sig, allowed);\n    }\n\n    function increaseAllowance(ERC20 token, address spender) public onlyOwner returns (bool) {\n        return token.approve(spender, type(uint256).max);\n    }\n\n    /////  Checkpoints  /////\n\n    function harvestCheckpointsLength() public view returns (uint256) {\n        return harvestCheckpoints.length;\n    }\n\n    function invertedHarvestCheckpoints(uint256 index) public view returns (HarvestCheckpoint memory) {\n        return harvestCheckpoints[harvestCheckpoints.length - 1 - index];\n    }\n\n    function selectHarvestCheckpoints(uint256 start, uint256 end) public view returns (HarvestCheckpoint[] memory) {\n        uint256 length = end - start + 1;\n\n        HarvestCheckpoint[] memory arr = new HarvestCheckpoint[](length);\n        for (uint256 i = 0; i < length; i++) {\n            arr[i] = harvestCheckpoints[start + i];\n        }\n        return arr;\n    }\n\n    function selectInvertedHarvestCheckpoints(uint256 start, uint256 end) public view returns (HarvestCheckpoint[] memory) {\n        uint256 length = end - start + 1;\n        uint256 lastIndex = harvestCheckpoints.length - 1;\n\n        HarvestCheckpoint[] memory arr = new HarvestCheckpoint[](length);\n        for (uint256 i = 0; i < length; i++) {\n            arr[i] = harvestCheckpoints[lastIndex - i];\n        }\n        return arr;\n    }\n\n    function yield() public view virtual returns (uint256 diffTimestamp, int256 diffAssetsPerShare) {\n        uint lastHarvestCheckpointsIndex = harvestCheckpoints.length - 1;\n\n        if (lastHarvestCheckpointsIndex < 1) {\n            return (1 days, 0);\n        }\n\n        HarvestCheckpoint memory lastCheckpoint = harvestCheckpoints[lastHarvestCheckpointsIndex];\n        HarvestCheckpoint memory beforeLastCheckpoint = harvestCheckpoints[lastHarvestCheckpointsIndex - 1];\n\n        unchecked { // timestamp is allowed to overflow\n            diffTimestamp = lastCheckpoint.blockTimestamp - beforeLastCheckpoint.blockTimestamp;\n        }\n        diffAssetsPerShare = int256(((int224(lastCheckpoint.assetsPerShare) - int224(beforeLastCheckpoint.assetsPerShare)) * 1e18) / int224(beforeLastCheckpoint.assetsPerShare));\n    }\n\n    /////  Admin  /////\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n\n    /////  Fees  /////\n\n    function excludeFromFees(address user, bool exclude) public onlyOwner {\n        excludedFromFees[user] = exclude;\n        emit UpdateFeeExclusion(user, exclude);\n    }\n\n    function setFeeTaker(address _feeTaker) public onlyOwner {\n        feeTaker = _feeTaker;\n    }\n\n    function setWithdrawalFee(uint256 _withdrawalFee) public onlyOwner {\n        withdrawalFee = _withdrawalFee;\n    }\n\n    function setHarvestFee(uint256 _harvestFee) public onlyOwner {\n        harvestFee = _harvestFee;\n    }\n\n    /////  ERC4626 hooks  /////\n\n    function afterDeposit(uint256 assets, uint256) internal override {\n        onDeposit(assets);\n    }\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n        if (!excludedFromFees[msg.sender]) {\n            _mint(feeTaker, shares.mulDivDown(withdrawalFee, 1e18));\n        }\n        onWithdraw(assets);\n    }\n\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        uint256 _withdrawalFee = withdrawalFee;\n\n        if (excludedFromFees[msg.sender]) {\n            _withdrawalFee = 0;\n        } \n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        uint shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n        return shares.mulDivUp(1e18, 1e18 - _withdrawalFee);\n    }\n\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        uint256 _withdrawalFee = withdrawalFee;\n\n        if (excludedFromFees[msg.sender]) {\n            _withdrawalFee = 0;\n        } \n\n        return convertToAssets(shares).mulDivDown(1e18 - _withdrawalFee, 1e18);\n    }\n\n    ///// Modifiers  /////\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"Only manager is allowed to call\");\n        _;\n    }\n\n    modifier onlyManagerOrOwner() {\n        require(msg.sender == manager || msg.sender == owner, \"Only manager or Owner is allowed to call\");\n        _;\n    }\n\n    /////  Hooks  /////\n\n    function onDeposit(uint256 assets) internal virtual {}\n\n    function onWithdraw(uint256 assets) internal virtual {}\n\n    function onHarvest() internal virtual {}\n\n    function afterHarvest() internal virtual {}\n\n    function harvestable() public virtual view returns (Harvestable[] memory);\n}"
    },
    "contracts/citrus-vaults/lib/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Simplified by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/Aave2LeveragedVault.t.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"../lib/forge-std/src/Test.sol\";\n\nimport \"./external/aave-v2/IAToken.sol\";\nimport \"./external/aave-v2/ILendingPool.sol\";\nimport \"./external/aave-v2/IAaveIncentivesController.sol\";\nimport \"./external/balancer-v2/IBalancerV2WeightedPool.sol\";\nimport \"./external/balancer-v2/IBalancerV2Vault.sol\";\nimport \"./external/uniswap-v2/IUniswapV2Router02.sol\";\n\nimport \"./harvesters/BalancerPoolManager.sol\";\nimport \"./harvesters/Swapper.sol\";\n\nimport \"./Aave2LeveragedVault.sol\";\n\ncontract Aave2LeveragedVaultTest is Test {\n    ERC20 wxdai = ERC20(0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d);\n\n    Aave2LeveragedVault vault;\n    BalancerPoolManager balancerPoolManager;\n    Swapper swapper;\n\n    function setUp() public {\n        vm.createSelectFork(vm.envString(\"GNOSIS_RPC\"));\n        vault = new Aave2LeveragedVault(\n            ERC20(wxdai),\n            \"Agave xDai\",\n            \"AXDAI\",\n            ILendingPool(0x5E15d5E33d318dCEd84Bfe3F4EACe07909bE6d9c),\n            IAaveIncentivesController(0xfa255f5104f129B78f477e9a6D050a02f31A5D86)\n        );\n        balancerPoolManager = new BalancerPoolManager();\n        swapper = new Swapper();\n        vault.setMaxCollateralRatio(0.8e18);\n        vault.setTargetCollateralRatio(0.78e18);\n        vault.setManager(address(this));\n        wxdai.approve(address(vault), type(uint256).max);\n        vault.setHarvestFee(0.05e18);\n    }\n\n    function testAgave() public {\n        deal(address(wxdai), address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        vault.rebalance();\n\n        vm.warp(block.timestamp + 1 days);\n        vm.roll(block.number + 17280);\n\n        Harvestable[] memory harvestables = vault.harvestable();\n\n        IBalancerV2WeightedPool balancerPool = IBalancerV2WeightedPool(harvestables[0].token);\n        IBalancerV2Vault balancerVault = IBalancerV2Vault(balancerPool.getVault());\n        (\n            address[] memory tokens, ,\n        ) = balancerVault.getPoolTokens(balancerPool.getPoolId());\n\n        IUniswapV2Router02 honeyswapRouter = IUniswapV2Router02(0x1C232F01118CB8B424793ae03F870aa7D0ac7f77);\n\n        vault.increaseAllowance(ERC20(tokens[0]), address(honeyswapRouter));\n        vault.increaseAllowance(ERC20(tokens[1]), address(honeyswapRouter));\n\n        address[] memory agveSwapPath = new address[](3);\n        agveSwapPath[0] = tokens[0];\n        agveSwapPath[1] = address(0x6A023CCd1ff6F2045C3309768eAd9E68F978f6e1);\n        agveSwapPath[2] = address(wxdai);\n\n        address[] memory gnoSwapPath = new address[](2);\n        gnoSwapPath[0] = tokens[1];\n        gnoSwapPath[1] = address(wxdai);\n\n        vault.allowHarvestCall(address(balancerPoolManager), 0x37a31fb6, true);\n        vault.allowHarvestCall(address(swapper), 0x0004a85b, true);\n\n        uint256[] memory minAmountsOut = new uint256[](2);\n\n        HarvestCall[] memory calls = new HarvestCall[](3);\n        calls[0] = HarvestCall({\n            target: address(balancerPoolManager),\n            callData: abi.encodeWithSelector(\n                balancerPoolManager.exitPool.selector,\n                address(balancerPool),\n                minAmountsOut\n            )\n        });\n        calls[1] = HarvestCall({\n            target: address(swapper),\n            callData: abi.encodeWithSelector(\n                swapper.uniswapSwap.selector,\n                honeyswapRouter,\n                agveSwapPath,\n                minAmountsOut[0]\n            )\n        });\n        calls[2] = HarvestCall({\n            target: address(swapper),\n            callData: abi.encodeWithSelector(\n                swapper.uniswapSwap.selector,\n                honeyswapRouter,\n                gnoSwapPath,\n                minAmountsOut[0]\n            )\n        });\n        vault.harvest(calls);\n\n        console.log(\"profit\", vault.totalAssets());\n    }\n}"
    },
    "contracts/citrus-vaults/lib/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"../../../lib/ds-test/src/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/external/balancer-v2/IBalancerV2WeightedPool.sol": {
      "content": "pragma solidity >=0.8.0;\n\ninterface IBalancerV2WeightedPool {\n    function getPoolId() external view returns (bytes32);\n    function getVault() external view returns (address);\n    function getNormalizedWeights() external view returns (uint256[] memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n}"
    },
    "contracts/citrus-vaults/src/external/balancer-v2/IBalancerV2Vault.sol": {
      "content": "pragma solidity >=0.8.0;\n\ninterface IBalancerV2Vault {\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    function getPoolTokens(bytes32 poolId) external view returns (\n        address[] memory tokens,\n        uint256[] memory balances,\n        uint256 lastChangeBlock\n    );\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n}"
    },
    "contracts/citrus-vaults/src/external/uniswap-v2/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.8.0;\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/citrus-vaults/src/harvesters/BalancerPoolManager.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"../external/balancer-v2/IBalancerV2Vault.sol\";\nimport \"../external/balancer-v2/IBalancerV2WeightedPool.sol\";\n\ncontract BalancerPoolManager {\n    function exitPool(address pool, uint256[] memory minAmountsOut) public {\n        IBalancerV2WeightedPool balancerPool = IBalancerV2WeightedPool(pool);\n        IBalancerV2Vault balancerVault = IBalancerV2Vault(\n            balancerPool.getVault()\n        );\n        bytes32 poolId = balancerPool.getPoolId();\n\n        (address[] memory tokens, , ) = balancerVault.getPoolTokens(poolId);\n\n        IBalancerV2Vault.ExitPoolRequest memory request = IBalancerV2Vault\n            .ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: minAmountsOut,\n                userData: abi.encode(1, balancerPool.balanceOf(address(this))),\n                toInternalBalance: false\n            });\n\n        balancerVault.exitPool(\n            poolId,\n            address(this),\n            payable(address(this)),\n            request\n        );\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/harvesters/Swapper.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"../../lib/solmate/src/tokens/ERC20.sol\";\n\nimport \"../external/uniswap-v2/IUniswapV2Router02.sol\";\n\ncontract Swapper {\n    function uniswapSwap(\n        address router,\n        address[] memory path,\n        uint256 minAmountOut\n    ) public {\n        IUniswapV2Router02 honeyswapRouter = IUniswapV2Router02(router);\n        honeyswapRouter.swapExactTokensForTokens(\n            ERC20(path[0]).balanceOf(address(this)),\n            minAmountOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/transmissions11/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns(uint256);\n    // Revert the state of the evm to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256) external returns(bool);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata,uint256) external returns(uint256);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata) external returns(uint256);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256) external;\n    /// Returns the currently active fork\n    /// Reverts if no fork is currently active\n    function activeFork() external returns(uint256);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    /// Returns the RPC url for the given alias\n\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address) external;\n    function makePersistent(address, address) external;\n    function makePersistent(address, address, address) external;\n    function makePersistent(address[] calldata) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address) external;\n    function revokePersistent(address[] calldata) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address) external returns (bool);\n\n    function rpcUrl(string calldata) external returns(string memory);\n    /// Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external returns(string[2][] memory);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata, uint32) external returns (uint256);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "contracts/citrus-vaults/lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "contracts/citrus-vaults/lib/solmate/src/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/WETH.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        depositAmount = bound(depositAmount, 0, address(this).balance);\n        withdrawAmount = bound(withdrawAmount, 0, depositAmount);\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/DSTestPlus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {DSTest} from \"../../../../../lib/ds-test/src/test.sol\";\n\nimport {Hevm} from \"./Hevm.sol\";\n\n/// @notice Extended testing framework for DappTools projects.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/test/utils/DSTestPlus.sol)\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    string private checkpointLabel;\n    uint256 private checkpointGasLeft = 1; // Start the slot warm.\n\n    modifier brutalizeMemory(bytes memory brutalizeWith) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Fill the 64 bytes of scratch space with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    64, // Copy enough to only fill the scratch space.\n                    0, // Store the return value in the scratch space.\n                    64 // Scratch space is only 64 bytes in size, we don't want to write further.\n                )\n            )\n\n            let size := add(mload(brutalizeWith), 32) // Add 32 to include the 32 byte length slot.\n\n            // Fill the free memory pointer's destination with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    size, // We want to pass the length of the bytes.\n                    mload(0x40), // Store the return value at the free memory pointer.\n                    size // Since the precompile just returns its input, we reuse size.\n                )\n            )\n        }\n\n        _;\n    }\n\n    function startMeasuringGas(string memory label) internal virtual {\n        checkpointLabel = label;\n\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        // Subtract 100 to account for the warm SLOAD in startMeasuringGas.\n        uint256 gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;\n\n        emit log_named_uint(string(abi.encodePacked(checkpointLabel, \" Gas\")), gasDelta);\n    }\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBoolEq(bool a, bool b) internal virtual {\n        b ? assertTrue(a) : assertFalse(a);\n    }\n\n    function assertApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = a > b ? a - b : b - a;\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertRelApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = ((a > b ? a - b : b - a) * 1e18) / b;\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"    Expected\", b);\n            emit log_named_uint(\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertUintArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        require(a.length == b.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < a.length; i++) {\n            assertEq(a[i], b[i]);\n        }\n    }\n\n    function bound(\n        uint256 x,\n        uint256 min,\n        uint256 max\n    ) internal virtual returns (uint256 result) {\n        require(max >= min, \"MAX_LESS_THAN_MIN\");\n\n        uint256 size = max - min;\n\n        if (size == 0) result = min;\n        else if (size == type(uint256).max) result = x;\n        else {\n            ++size; // Make max inclusive.\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    function min3(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return a > b ? (b > c ? c : b) : (a > c ? c : a);\n    }\n\n    function min2(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/DSInvariantTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, \"NO_TARGET_CONTRACTS\");\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/Hevm.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface Hevm {\n    /// @notice Sets the block timestamp.\n    function warp(uint256) external;\n\n    /// @notice Sets the block height.\n    function roll(uint256) external;\n\n    /// @notice Sets the block base fee.\n    function fee(uint256) external;\n\n    /// @notice Loads a storage slot from an address.\n    function load(address, bytes32) external returns (bytes32);\n\n    /// @notice Stores a value to an address' storage slot.\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    /// @notice Signs a digest with a private key, returns v r s.\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    /// @notice Gets address for a given private key.\n    function addr(uint256) external returns (address);\n\n    /// @notice Performs a foreign function call via a terminal call.\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    /// @notice Sets the next call's msg.sender to be the input address.\n    function prank(address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address until stopPrank is called.\n    function startPrank(address) external;\n\n    /// @notice Sets the next call's msg.sender to be the input address and the tx.origin to be the second input.\n    function prank(address, address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address and\n    /// sets tx.origin to be the second address inputted until stopPrank is called.\n    function startPrank(address, address) external;\n\n    /// @notice Resets msg.sender to its original value before a prank.\n    function stopPrank() external;\n\n    /// @notice Sets an address' balance.\n    function deal(address, uint256) external;\n\n    /// @notice Sets an address' code.\n    function etch(address, bytes calldata) external;\n\n    /// @notice Expects an error from the next call.\n    function expectRevert(bytes calldata) external;\n\n    /// @notice Expects a revert from the next call.\n    function expectRevert(bytes4) external;\n\n    /// @notice Record all storage reads and writes.\n    function record() external;\n\n    /// @notice Gets all accessed reads and write slots from a recording session, for a given address.\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n\n    /// @notice Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    /// @notice Call this function, then emit an event, then call a function. Internally after the call, we check\n    /// if logs were emitted in the expected order with the expected topics and data as specified by the booleans.\n    function expectEmit(\n        bool,\n        bool,\n        bool,\n        bool\n    ) external;\n\n    /// @notice Mocks the behavior of a contract call, setting the input and output for a function.\n    /// @notice Calldata can either be strict or a partial match, e.g. if only passed\n    /// a selector to the expected calldata, then the entire function will be mocked.\n    function mockCall(\n        address,\n        bytes calldata,\n        bytes calldata\n    ) external;\n\n    /// @notice Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// @notice Expect a call to an address with the specified calldata.\n    /// @notice Calldata can either be strict or a partial match.\n    function expectCall(address, bytes calldata) external;\n\n    /// @notice Fetches the contract bytecode from its artifact file.\n    function getCode(string calldata) external returns (bytes memory);\n\n    /// @notice Label an address in test traces.\n    function label(address addr, string calldata label) external;\n\n    /// @notice When fuzzing, generate new inputs if the input conditional is not met.\n    function assume(bool) external;\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/ERC721.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"../../../tokens/ERC721.sol\";\n\ncontract MockERC721 is ERC721 {\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n    function tokenURI(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(address to, uint256 tokenId) public virtual {\n        _mint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public virtual {\n        _burn(tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        _safeMint(to, tokenId, data);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/mixins/Vault.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"../../lib/forge-std/src/Test.sol\";\nimport \"../../lib/solmate/src/test/utils/mocks/MockERC20.sol\";\n\nimport \"./Vault.sol\";\n\ncontract MockVault is Vault {\n    constructor(\n        MockERC20 asset\n    ) Vault(asset, \"Vault Test\", \"VTest\") {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory harvestables) {}\n}\n\ncontract VaultTest is Test {\n    MockERC20 public token;\n    Vault public vault;\n    address public feeTaker = makeAddr(\"fee taker\");\n\n    function setUp() public {\n        token = new MockERC20(\"Test\", \"TST\", 18);\n        vault = new MockVault(\n            token\n        );\n\n        vault.setManager(address(this));\n\n        token.approve(address(vault), type(uint256).max);\n\n        vault.setFeeTaker(feeTaker);\n        \n        vault.allowHarvestCall(address(token), 0x40c10f19, true);\n    }\n\n    function testFeeOnWithdrawal() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 1000e18);\n\n        assertEq(vault.balanceOf(address(this)), 0);\n\n        vault.deposit(900e18, makeAddr(\"user 1\"));\n        vault.deposit(100e18, address(this));\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(address(this)), 100e18);\n\n        vault.withdraw(99e18, address(this), address(this));\n\n        assertEq(token.balanceOf(address(this)), 99e18);\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(feeTaker), 1e18);\n    }\n\n    function testFeeOnRedeem() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 1000e18);\n\n        assertEq(vault.balanceOf(address(this)), 0);\n\n        vault.deposit(900e18, makeAddr(\"user 1\"));\n        vault.deposit(100e18, address(this));\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(address(this)), 100e18);\n\n        vault.redeem(100e18, address(this), address(this));\n\n        assertEq(token.balanceOf(address(this)), 99e18);\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(vault)), 901e18);\n        assertEq(vault.balanceOf(feeTaker), 1e18);\n    }\n\n    function testExcludedFromFeeOnWithdrawal() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n        vault.excludeFromFees(address(this), true);\n\n        token.mint(address(this), 1000e18);\n\n        assertEq(vault.balanceOf(address(this)), 0);\n\n        vault.deposit(900e18, makeAddr(\"user 1\"));\n        vault.deposit(100e18, address(this));\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(address(this)), 100e18);\n\n        vault.withdraw(100e18, address(this), address(this));\n\n        assertEq(token.balanceOf(address(this)), 100e18);\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(feeTaker), 0);\n    }\n\n    function testExcludedFromFeeOnRedeem() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n        vault.excludeFromFees(address(this), true);\n\n        token.mint(address(this), 1000e18);\n\n        assertEq(vault.balanceOf(address(this)), 0);\n\n        vault.deposit(900e18, makeAddr(\"user 1\"));\n        vault.deposit(100e18, address(this));\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(vault.balanceOf(address(this)), 100e18);\n\n        vault.redeem(100e18, address(this), address(this));\n\n        assertEq(token.balanceOf(address(this)), 100e18);\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(vault)), 900e18);\n        assertEq(vault.balanceOf(feeTaker), 0);\n    } \n\n    function testPreviewWithdraw() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        token.mint(address(vault), 100e18);\n\n        assertEq(vault.previewWithdraw(198e18), 100e18);\n    }\n\n    function testPreviewRedeem() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        token.mint(address(vault), 100e18);\n\n        assertEq(vault.previewRedeem(100e18), 198e18);\n    }\n\n    function testConvertToShares() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        token.mint(address(vault), 100e18);\n\n        assertEq(vault.convertToShares(200e18), 100e18);\n    }\n\n    function testConvertToAssets() public {\n        vault.setWithdrawalFee(0.01e18); // 1%\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        token.mint(address(vault), 100e18);\n\n        assertEq(vault.convertToAssets(100e18), 200e18);\n    }\n\n    function testHarvest() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 100e18);\n\n        HarvestCall[] memory calls = new HarvestCall[](0);\n        token.mint(address(vault), 1e18);\n        vault.harvest(calls);\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 101e18);\n    }\n\n    function testHarvestWithFees() public {\n        vault.setHarvestFee(0.1e18); // 10%\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 100e18);\n\n        HarvestCall[] memory calls = new HarvestCall[](0);\n        token.mint(address(vault), 9e18);\n        vault.harvest(calls);\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 109e18);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 109e18);\n    }\n\n    function testNotOnHarvestWhitelist() public {\n        vault.allowHarvestCall(address(token), 0x40c10f19, false);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 100e18);\n\n        HarvestCall[] memory calls = new HarvestCall[](1);\n        calls[0] = HarvestCall({\n            target: address(token),\n            callData: abi.encodeWithSignature(\"mint(address,uint256)\", address(vault), 1e18)\n        });\n        vm.expectRevert(bytes(\"method not whitelisted\"));\n        vault.harvest(calls);\n\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 100e18);\n    }\n\n    function testCheckpoints() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertEq(vault.convertToAssets(1e18), 1e18);\n\n        skip(999);\n\n        HarvestCall[] memory calls = new HarvestCall[](0);\n        token.mint(address(vault), 10e18);\n        vault.harvest(calls);\n\n        assertEq(vault.convertToAssets(1e18), 1.1e18);\n\n        assertEq(vault.harvestCheckpointsLength(), 2);\n        \n        HarvestCheckpoint[] memory checkpoints = vault.selectHarvestCheckpoints(0, 1);\n        \n        assertEq(checkpoints.length, 2);\n        assertEq(checkpoints[0].blockTimestamp, 1);\n        assertEq(checkpoints[0].assetsPerShare, 1e18);\n        assertEq(checkpoints[1].blockTimestamp, 1000);\n        assertEq(checkpoints[1].assetsPerShare, 1.1e18);\n\n        HarvestCheckpoint[] memory invertedCheckpoints = vault.selectInvertedHarvestCheckpoints(0, 1);\n\n        assertEq(invertedCheckpoints.length, 2);\n        assertEq(invertedCheckpoints[0].blockTimestamp, 1000);\n        assertEq(invertedCheckpoints[0].assetsPerShare, 1.1e18);\n        assertEq(invertedCheckpoints[1].blockTimestamp, 1);\n        assertEq(invertedCheckpoints[1].assetsPerShare, 1e18);\n    }\n\n    function testYield() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        skip(1 days);\n\n        token.mint(address(vault), 0.04e18);\n        \n        vault.harvest(calls);\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n\n        assertEq(diffTimestamp, 1 days);\n        assertEq(diffAssetsPerShare, 0.0004e18);\n    }\n\n    function testYieldWithRollingTimestamp() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 90e18);\n        vault.deposit(90e18, address(this));\n\n        skip(type(uint32).max - 50);\n\n        token.mint(address(vault), 10e18);\n\n        vault.harvest(calls);\n\n        skip(1 days);\n\n        token.mint(address(vault), 0.04e18);\n\n        vault.harvest(calls);\n\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n\n        assertEq(diffTimestamp, 1 days);\n        assertApproxEqAbs(diffAssetsPerShare, 0.0004e18, 1);\n    }\n\n    function testNegativeYield() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        token.burn(address(vault), 0.04e18);\n\n        skip(1 days);\n\n        token.mint(address(vault), 1);\n\n        vault.harvest(calls);\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n\n        assertEq(diffTimestamp, 1 days);\n        assertApproxEqAbs(diffAssetsPerShare, -0.0004e18, 1);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringGenerativeNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport \"./BoringMultipleNFT.sol\";\nimport \"./BoringOwnable.sol\";\nimport \"./libraries/Base64.sol\";\nimport \"./interfaces/IBoringGenerativeNFT.sol\";\n\ncontract BoringGenerativeNFT is IBoringGenerativeNFT, BoringMultipleNFT, BoringOwnable {\n    using Base64 for bytes;\n\n    ITrait[] private _traits;\n\n    function traits(uint256 index) external view override returns (ITrait trait) {\n        return _traits[index];\n    }\n\n    constructor(string memory name, string memory symbol) BoringMultipleNFT(name, symbol) {\n        this; // Hide empty code block warning\n    }\n\n    function traitsCount() public view override returns (uint256 count) {\n        count = _traits.length;\n    }\n\n    function addTrait(string calldata name, ITrait trait) public override onlyOwner {\n        uint8 gene = uint8(_traits.length);\n        require(_traits.length < 9, \"Traits full\");\n        _traits.push(trait);\n        require(_traits[gene].setName(gene, name) == bytes4(keccak256(\"setName(uint8,string)\")), \"Bad return\");\n    }\n\n    function addTraitData(uint8 trait, bytes calldata data) public onlyOwner {\n        // Return value is checked to ensure only real Traits contracts are called\n        require(_traits[trait].addData(trait, data) == bytes4(keccak256(\"addData(address,uint8,bytes)\")), \"Bad return\");\n    }\n\n    function tokenSVG(uint256 tokenId) public view returns (string memory) {\n        TraitsData memory genes = _tokens[tokenId].data;\n        uint256 traitCount = _traits.length;\n\n        return\n            abi\n                .encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" viewBox=\"0 0 120.7 103.2\">',\n                traitCount > 0 ? _traits[0].renderSVG(this, tokenId, 0, genes.trait0) : \"\",\n                traitCount > 1 ? _traits[1].renderSVG(this, tokenId, 1, genes.trait1) : \"\",\n                traitCount > 2 ? _traits[2].renderSVG(this, tokenId, 2, genes.trait2) : \"\",\n                traitCount > 3 ? _traits[3].renderSVG(this, tokenId, 3, genes.trait3) : \"\",\n                traitCount > 4 ? _traits[4].renderSVG(this, tokenId, 4, genes.trait4) : \"\",\n                traitCount > 5 ? _traits[5].renderSVG(this, tokenId, 5, genes.trait5) : \"\",\n                traitCount > 6 ? _traits[6].renderSVG(this, tokenId, 6, genes.trait6) : \"\",\n                traitCount > 7 ? _traits[7].renderSVG(this, tokenId, 7, genes.trait7) : \"\",\n                traitCount > 8 ? _traits[8].renderSVG(this, tokenId, 8, genes.trait8) : \"\",\n                \"</svg>\"\n            )\n                .encode();\n    }\n\n    function _renderTrait(\n        uint256 tokenId,\n        uint256 traitCount,\n        uint8 trait,\n        uint8 gene\n    ) internal view returns (bytes memory) {\n        return abi.encodePacked(traitCount > trait ? _traits[0].renderTrait(this, tokenId, trait, gene) : \"\", traitCount > trait + 1 ? \",\" : \"\");\n    }\n\n    function _renderTraits(uint256 tokenId) internal view returns (bytes memory) {\n        TraitsData memory genes = _tokens[tokenId].data;\n        uint256 traitCount = _traits.length;\n\n        return\n            abi.encodePacked(\n                _renderTrait(tokenId, traitCount, 0, genes.trait0),\n                _renderTrait(tokenId, traitCount, 1, genes.trait1),\n                _renderTrait(tokenId, traitCount, 2, genes.trait2),\n                _renderTrait(tokenId, traitCount, 3, genes.trait3),\n                _renderTrait(tokenId, traitCount, 4, genes.trait4),\n                _renderTrait(tokenId, traitCount, 5, genes.trait5),\n                _renderTrait(tokenId, traitCount, 6, genes.trait6),\n                _renderTrait(tokenId, traitCount, 7, genes.trait7),\n                traitCount > 8 ? _traits[8].renderTrait(this, tokenId, 8, genes.trait8) : \"\"\n            );\n    }\n\n    function _tokenURI(uint256 tokenId) internal view override returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    abi\n                        .encodePacked(\n                        '{\"image\":\"data:image/svg+xml;base64,',\n                        tokenSVG(tokenId),\n                        '\",\"attributes\":[',\n                        _renderTraits(tokenId),\n                        \"]}\"\n                    )\n                        .encode()\n                )\n            );\n    }\n\n    function mint(TraitsData calldata genes, address to) public override onlyOwner {\n        _mint(to, genes);\n    }\n\n    function batchMint(TraitsData[] calldata genes, address[] calldata to) public override onlyOwner {\n        uint256 len = genes.length;\n        require(len == to.length, \"Length mismatch\");\n        for (uint256 i = 0; i < len; i++) {\n            _mint(to[i], genes[i]);\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringMultipleNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/IERC721TokenReceiver.sol\";\nimport \"./libraries/BoringAddress.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nstruct TraitsData {\n    uint8 trait0;\n    uint8 trait1;\n    uint8 trait2;\n    uint8 trait3;\n    uint8 trait4;\n    uint8 trait5;\n    uint8 trait6;\n    uint8 trait7;\n    uint8 trait8;\n}\n\nabstract contract BoringMultipleNFT is IERC721, IERC721Metadata, IERC721Enumerable {\n    /// This contract is an EIP-721 compliant contract with enumerable support\n    /// To optimize for gas, tokenId is sequential and start at 0. Also, tokens can't be removed/burned.\n    using BoringAddress for address;\n\n    string public name;\n    string public symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    uint256 public totalSupply = 0;\n\n    struct TokenInfo {\n        // There 3 pack into a single storage slot 160 + 24 + 9*8 = 256 bits\n        address owner;\n        uint24 index; // index in the tokensOf array, one address can hold a maximum of 16,777,216 tokens\n        TraitsData data; // data field can be used to store traits\n    }\n\n    // operator mappings as per usual\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    mapping(address => uint256[]) public tokensOf; // Array of tokens owned by\n    mapping(uint256 => TokenInfo) internal _tokens; // The index in the tokensOf array for the token, needed to remove tokens from tokensOf\n    mapping(uint256 => address) internal _approved; // keep track of approved nft\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == this.supportsInterface.selector || // EIP-165\n            interfaceID == 0x80ac58cd || // EIP-721\n            interfaceID == 0x5b5e139f || // EIP-721 metadata extension\n            interfaceID == 0x780e9d63; // EIP-721 enumeration extension\n    }\n\n    function approve(address approved, uint256 tokenId) public payable {\n        address owner = _tokens[tokenId].owner;\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"Not allowed\");\n        _approved[tokenId] = approved;\n        emit Approval(owner, approved, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address approved) {\n        require(tokenId < totalSupply, \"Invalid tokenId\");\n        return _approved[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokens[tokenId].owner;\n        require(owner != address(0), \"No owner\");\n        return owner;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"No 0 owner\");\n        return tokensOf[owner].length;\n    }\n\n    function _transferBase(\n        uint256 tokenId,\n        address from,\n        address to,\n        TraitsData memory data\n    ) internal {\n        address owner = _tokens[tokenId].owner;\n        require(from == owner, \"From not owner\");\n\n        uint24 index;\n        // Remove the token from the current owner's tokensOf array\n        if (from != address(0)) {\n            index = _tokens[tokenId].index; // The index of the item to remove in the array\n            data = _tokens[tokenId].data;\n            uint256 last = tokensOf[from].length - 1;\n            uint256 lastTokenId = tokensOf[from][last];\n            tokensOf[from][index] = lastTokenId; // Copy the last item into the slot of the one to be removed\n            _tokens[lastTokenId].index = index; // Update the token index for the last item that was moved\n            tokensOf[from].pop(); // Delete the last item\n        }\n\n        index = uint24(tokensOf[to].length);\n        tokensOf[to].push(tokenId);\n        _tokens[tokenId] = TokenInfo({owner: to, index: index, data: data});\n\n        // EIP-721 seems to suggest not to emit the Approval event here as it is indicated by the Transfer event.\n        _approved[tokenId] = address(0);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(msg.sender == from || msg.sender == _approved[tokenId] || isApprovedForAll[from][msg.sender], \"Transfer not allowed\");\n        require(to != address(0), \"No zero address\");\n        // check for owner == from is in base\n        _transferBase(tokenId, from, to, TraitsData(0, 0, 0, 0, 0, 0, 0, 0, 0));\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) {\n            require(\n                IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) ==\n                    bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(tokenId < totalSupply, \"Not minted\");\n        return _tokenURI(tokenId);\n    }\n\n    function _tokenURI(uint256 tokenId) internal view virtual returns (string memory);\n\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply, \"Out of bounds\");\n        return index; // This works due the optimization of sequential tokenIds and no burning\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\n        return tokensOf[owner][index];\n    }\n\n    //\n    function _mint(address owner, TraitsData memory data) internal returns (uint256 tokenId) {\n        tokenId = totalSupply;\n        _transferBase(tokenId, address(0), owner, data);\n        totalSupply++;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n// solhint-disable no-empty-blocks\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n                case 1 {\n                    mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n                }\n                case 2 {\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\n                }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IBoringGenerativeNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport \"../BoringMultipleNFT.sol\";\n\nstruct GeneInfo {\n    ITrait trait;\n    string name;\n}\n\ninterface ITrait {\n    // Should return bytes4(keccak256(\"setName(uint8,string)\"))\n    function setName(uint8 trait, string calldata name) external returns (bytes4);\n\n    // Should return bytes4(keccak256(\"addData(address,uint8,bytes)\"))\n    function addData(uint8 trait, bytes calldata data) external returns (bytes4);\n\n    function renderTrait(\n        IBoringGenerativeNFT nft,\n        uint256 tokenId,\n        uint8 trait,\n        uint8 gene\n    ) external view returns (string memory output);\n\n    function renderSVG(\n        IBoringGenerativeNFT nft,\n        uint256 tokenId,\n        uint8 trait,\n        uint8 gene\n    ) external view returns (string memory output);\n}\n\ninterface IBoringGenerativeNFT {\n    function traits(uint256 index) external view returns (ITrait trait);\n\n    function traitsCount() external view returns (uint256 count);\n\n    function addTrait(string calldata name, ITrait trait) external;\n\n    function mint(TraitsData calldata genes, address to) external;\n\n    function batchMint(TraitsData[] calldata genes, address[] calldata to) external;\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is ERC165 */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata /* is ERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable /* is ERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/libraries/BoringAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\nlibrary BoringAddress {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendNative(address to, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"BoringAddress: transfer failed\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libraries/BoringAddress.sol\";\nimport \"./interfaces/IERC1155.sol\";\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\n\n// Written by OreNoMochi (https://github.com/OreNoMochii)\n\nabstract contract ERC1155 is IERC1155 {\n    using BoringAddress for address;\n\n    // mappings\n    mapping(address => mapping(address => bool)) public override isApprovedForAll; // map of operator approval\n    mapping(address => mapping(uint256 => uint256)) public override balanceOf; // map of tokens owned by\n\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\n        return\n            interfaceID == this.supportsInterface.selector || // EIP-165\n            interfaceID == 0xd9b67a26 || // ERC-1155\n            interfaceID == 0x0e89341c; // EIP-1155 Metadata\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view override returns (uint256[] memory balances) {\n        uint256 len = owners.length;\n        require(len == ids.length, \"ERC1155: Length mismatch\");\n\n        balances = new uint256[](len);\n\n        for (uint256 i = 0; i < len; i++) {\n            balances[i] = balanceOf[owners[i]][ids[i]];\n        }\n    }\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal {\n        balanceOf[from][id] += value;\n\n        emit TransferSingle(msg.sender, from, address(0), id, value);\n    }\n\n    function _transferSingle(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        balanceOf[from][id] -= value;\n        balanceOf[to][id] += value;\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n    }\n\n    function _transferBatch(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) internal {\n        require(to != address(0), \"No 0 address\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            balanceOf[from][id] -= value;\n            balanceOf[to][id] += value;\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n    }\n\n    function _requireTransferAllowed(address from) internal view {\n        require(from == msg.sender || isApprovedForAll[from][msg.sender] == true, \"Transfer not allowed\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        _requireTransferAllowed(from);\n\n        _transferSingle(from, to, id, value);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, value, data) ==\n                    bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override {\n        require(ids.length == values.length, \"ERC1155: Length mismatch\");\n        _requireTransferAllowed(from);\n\n        _transferBatch(from, to, ids, values);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, values, data) ==\n                    bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external override {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function uri(\n        uint256 /*assetId*/\n    ) external pure returns (string memory) {\n        return \"\";\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IERC165.sol\";\n\ninterface IERC1155 is IERC165 {\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringSingleNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IERC721.sol\";\nimport \"./libraries/BoringAddress.sol\";\n\n// solhint-disable avoid-low-level-calls\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n\nabstract contract BoringSingleNFT is IERC721, IERC721Metadata {\n    /// This contract is an EIP-721 compliant contract that holds only a single NFT (totalSupply = 1)\n    using BoringAddress for address;\n\n    // hodler must be set in derived contract\n    // Since there is only one NFT, we only track single holder and allowed\n    address public hodler;\n    address public allowed;\n    // solhint-disable-next-line const-name-snakecase\n    uint256 public constant totalSupply = 1;\n\n    // operator mappings as per usual\n    mapping(address => mapping(address => bool)) public operators;\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == this.supportsInterface.selector || // EIP-165\n            interfaceID == 0x80ac58cd; // EIP-721\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        require(user != address(0), \"No zero address\");\n        return user == hodler ? 1 : 0;\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        require(tokenId == 0, \"Invalid token ID\");\n        require(hodler != address(0), \"No owner\");\n        return hodler;\n    }\n\n    function approve(address approved, uint256 tokenId) public payable {\n        require(tokenId == 0, \"Invalid token ID\");\n        require(msg.sender == hodler || operators[hodler][msg.sender], \"Not allowed\");\n        allowed = approved;\n        emit Approval(msg.sender, approved, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(tokenId == 0, \"Invalid token ID\");\n        return allowed;\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _transferBase(address to) internal {\n        emit Transfer(hodler, to, 0);\n        hodler = to;\n        // EIP-721 seems to suggest not to emit the Approval event here as it is indicated by the Transfer event.\n        allowed = address(0);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(tokenId == 0, \"Invalid token ID\");\n        require(from == hodler, \"From not owner\");\n        require(msg.sender == hodler || msg.sender == allowed || operators[hodler][msg.sender], \"Transfer not allowed\");\n        require(to != address(0), \"No zero address\");\n        _transferBase(to);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) {\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) ==\n                    bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function tokenURI(uint256 tokenId) public pure returns (string memory) {\n        require(tokenId == 0, \"Invalid token ID\");\n        return _tokenURI();\n    }\n\n    function _tokenURI() internal pure virtual returns (string memory);\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/FixedTrait.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IBoringGenerativeNFT.sol\";\n\ncontract FixedTrait is ITrait {\n    struct Option {\n        string name;\n        string svg;\n    }\n\n    mapping(IBoringGenerativeNFT => mapping(uint8 => string)) public names;\n    mapping(IBoringGenerativeNFT => mapping(uint8 => Option[])) public options;\n\n    function setName(uint8 trait, string calldata name) external override returns (bytes4) {\n        names[IBoringGenerativeNFT(msg.sender)][trait] = name;\n\n        return bytes4(keccak256(\"setName(uint8,string)\"));\n    }\n\n    function addData(uint8 trait, bytes calldata data) external override returns (bytes4) {\n        Option memory option = abi.decode(data, (Option));\n        options[IBoringGenerativeNFT(msg.sender)][trait].push(option);\n\n        return bytes4(keccak256(\"addData(address,uint8,bytes)\"));\n    }\n\n    function renderTrait(\n        IBoringGenerativeNFT nft,\n        uint256,\n        uint8 trait,\n        uint8 gene\n    ) external view override returns (string memory output) {\n        return string(abi.encodePacked('{\"trait_type\":\"', names[nft][trait], '\",\"value\":\"', options[nft][trait][gene].name, '\"}'));\n    }\n\n    function renderSVG(\n        IBoringGenerativeNFT nft,\n        uint256,\n        uint8 trait,\n        uint8 gene\n    ) external view override returns (string memory output) {\n        return options[nft][trait][gene].svg;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/FixedPointMathLib.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\ncontract FixedPointMathLibTest is DSTestPlus {\n    function testMulWadDown() public {\n        assertEq(FixedPointMathLib.mulWadDown(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadDown(369, 271), 0);\n    }\n\n    function testMulWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadDown(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadDown(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadDown(0, 0), 0);\n    }\n\n    function testMulWadUp() public {\n        assertEq(FixedPointMathLib.mulWadUp(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadUp(369, 271), 1);\n    }\n\n    function testMulWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadUp(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadUp(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadUp(0, 0), 0);\n    }\n\n    function testDivWadDown() public {\n        assertEq(FixedPointMathLib.divWadDown(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadDown(2, 100000000000000e18), 0);\n    }\n\n    function testDivWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadDown(0, 1e18), 0);\n    }\n\n    function testFailDivWadDownZeroDenominator() public pure {\n        FixedPointMathLib.divWadDown(1e18, 0);\n    }\n\n    function testDivWadUp() public {\n        assertEq(FixedPointMathLib.divWadUp(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n    }\n\n    function testDivWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadUp(0, 1e18), 0);\n    }\n\n    function testFailDivWadUpZeroDenominator() public pure {\n        FixedPointMathLib.divWadUp(1e18, 0);\n    }\n\n    function testMulDivDown() public {\n        assertEq(FixedPointMathLib.mulDivDown(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivDown(369, 271, 1e2), 999);\n\n        assertEq(FixedPointMathLib.mulDivDown(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivDown(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivDown(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivDown(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivDown(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivDown(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivDownZeroDenominator() public pure {\n        FixedPointMathLib.mulDivDown(1e18, 1e18, 0);\n    }\n\n    function testMulDivUp() public {\n        assertEq(FixedPointMathLib.mulDivUp(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivUp(369, 271, 1e2), 1000);\n\n        assertEq(FixedPointMathLib.mulDivUp(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivUp(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivUp(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivUp(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivUp(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivUp(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivUpZeroDenominator() public pure {\n        FixedPointMathLib.mulDivUp(1e18, 1e18, 0);\n    }\n\n    function testRPow() public {\n        assertEq(FixedPointMathLib.rpow(2e27, 2, 1e27), 4e27);\n        assertEq(FixedPointMathLib.rpow(2e18, 2, 1e18), 4e18);\n        assertEq(FixedPointMathLib.rpow(2e8, 2, 1e8), 4e8);\n        assertEq(FixedPointMathLib.rpow(8, 3, 1), 512);\n    }\n\n    function testSqrt() public {\n        assertEq(FixedPointMathLib.sqrt(0), 0);\n        assertEq(FixedPointMathLib.sqrt(1), 1);\n        assertEq(FixedPointMathLib.sqrt(2704), 52);\n        assertEq(FixedPointMathLib.sqrt(110889), 333);\n        assertEq(FixedPointMathLib.sqrt(32239684), 5678);\n    }\n\n    function testMulWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadDown(x, y), (x * y) / 1e18);\n    }\n\n    function testFailMulWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadDown(x, y);\n    }\n\n    function testMulWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadUp(x, y), x * y == 0 ? 0 : (x * y - 1) / 1e18 + 1);\n    }\n\n    function testFailMulWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadUp(x, y);\n    }\n\n    function testDivWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadDown(x, y), (x * 1e18) / y);\n    }\n\n    function testFailDivWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadDown(x, y);\n    }\n\n    function testFailDivWadDownZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadDown(x, 0);\n    }\n\n    function testDivWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadUp(x, y), x == 0 ? 0 : (x * 1e18 - 1) / y + 1);\n    }\n\n    function testFailDivWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadUp(x, y);\n    }\n\n    function testFailDivWadUpZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadUp(x, 0);\n    }\n\n    function testMulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivDown(x, y, denominator), (x * y) / denominator);\n    }\n\n    function testFailMulDivDownOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivDown(x, y, denominator);\n    }\n\n    function testFailMulDivDownZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivDown(x, y, 0);\n    }\n\n    function testMulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivUp(x, y, denominator), x * y == 0 ? 0 : (x * y - 1) / denominator + 1);\n    }\n\n    function testFailMulDivUpOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivUp(x, y, denominator);\n    }\n\n    function testFailMulDivUpZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivUp(x, y, 0);\n    }\n\n    function testSqrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.sqrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where next * next overflows.\n        unchecked {\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root <= x && next * next > x);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\nimport {ERC4626} from \"../../../mixins/ERC4626.sol\";\n\ncontract MockERC4626 is ERC4626 {\n    uint256 public beforeWithdrawHookCalledCounter = 0;\n    uint256 public afterDepositHookCalledCounter = 0;\n\n    constructor(\n        ERC20 _underlying,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_underlying, _name, _symbol) {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function beforeWithdraw(uint256, uint256) internal override {\n        beforeWithdrawHookCalledCounter++;\n    }\n\n    function afterDeposit(uint256, uint256) internal override {\n        afterDepositHookCalledCounter++;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/ERC4626.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockERC4626} from \"./utils/mocks/MockERC4626.sol\";\n\ncontract ERC4626Test is DSTestPlus {\n    MockERC20 underlying;\n    MockERC4626 vault;\n\n    function setUp() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(underlying, \"Mock Token Vault\", \"vwTKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(vault.name(), \"Mock Token Vault\");\n        assertEq(vault.symbol(), \"vwTKN\");\n        assertEq(vault.decimals(), 18);\n    }\n\n    function testMetadata(string calldata name, string calldata symbol) public {\n        MockERC4626 vlt = new MockERC4626(underlying, name, symbol);\n        assertEq(vlt.name(), name);\n        assertEq(vlt.symbol(), symbol);\n        assertEq(address(vlt.asset()), address(underlying));\n    }\n\n    function testSingleDepositWithdraw(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        assertEq(aliceUnderlyingAmount, aliceShareAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testSingleMintRedeem(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        assertEq(aliceShareAmount, aliceUnderlyingAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testMultipleMintDepositRedeemWithdraw() public {\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |========================================================|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n\n        uint256 mutationUnderlyingAmount = 3000;\n\n        underlying.mint(alice, 4000);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(alice, address(vault)), 4000);\n\n        underlying.mint(bob, 7001);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(bob, address(vault)), 7001);\n\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(2000, alice);\n\n        uint256 aliceShareAmount = vault.previewDeposit(aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(aliceUnderlyingAmount), vault.balanceOf(alice));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        hevm.prank(bob);\n        uint256 bobShareAmount = vault.deposit(4000, bob);\n        uint256 bobUnderlyingAmount = vault.previewWithdraw(bobShareAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n        // Expect to have received the requested underlying amount.\n        assertEq(bobUnderlyingAmount, 4000);\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount);\n        assertEq(vault.convertToShares(bobUnderlyingAmount), vault.balanceOf(bob));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(bobShareAmount, bobUnderlyingAmount);\n\n        // Sanity check.\n        uint256 preMutationShareBal = aliceShareAmount + bobShareAmount;\n        uint256 preMutationBal = aliceUnderlyingAmount + bobUnderlyingAmount;\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal);\n        assertEq(vault.totalSupply(), 6000);\n        assertEq(vault.totalAssets(), 6000);\n\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal + mutationUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(\n            vault.convertToAssets(vault.balanceOf(alice)),\n            aliceUnderlyingAmount + (mutationUnderlyingAmount / 3) * 1\n        );\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount + (mutationUnderlyingAmount / 3) * 2);\n\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        hevm.prank(alice);\n        vault.deposit(2000, alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 4999);\n        assertEq(vault.balanceOf(bob), 4000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 6000);\n\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        hevm.prank(bob);\n        vault.mint(2000, bob);\n\n        assertEq(vault.totalSupply(), 9333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 5000);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 9000);\n\n        // Sanity checks:\n        // Alice and bob should have spent all their tokens now\n        assertEq(underlying.balanceOf(alice), 0);\n        assertEq(underlying.balanceOf(bob), 0);\n        // Assets in vault: 4k (alice) + 7k (bob) + 3k (yield) + 1 (round up)\n        assertEq(vault.totalAssets(), 14001);\n\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalAssets(), 17001);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 6071);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 7. Alice redeem 1333 shares (2428 assets)\n        hevm.prank(alice);\n        vault.redeem(1333, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 2428);\n        assertEq(vault.totalSupply(), 8000);\n        assertEq(vault.totalAssets(), 14573);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        hevm.prank(bob);\n        vault.withdraw(2929, bob, bob);\n\n        assertEq(underlying.balanceOf(bob), 2929);\n        assertEq(vault.totalSupply(), 6392);\n        assertEq(vault.totalAssets(), 11644);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8000);\n\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        hevm.prank(alice);\n        vault.withdraw(3643, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 6071);\n        assertEq(vault.totalSupply(), 4392);\n        assertEq(vault.totalAssets(), 8001);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8001);\n\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        hevm.prank(bob);\n        vault.redeem(4392, bob, bob);\n        assertEq(underlying.balanceOf(bob), 10930);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 0);\n\n        // Sanity check\n        assertEq(underlying.balanceOf(address(vault)), 0);\n    }\n\n    function testFailDepositWithNotEnoughApproval() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n        assertEq(underlying.allowance(address(this), address(vault)), 0.5e18);\n\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailWithdrawWithNotEnoughUnderlyingAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNotEnoughShareAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailWithdrawWithNoUnderlyingAmount() public {\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNoShareAmount() public {\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailDepositWithNoApproval() public {\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailMintWithNoApproval() public {\n        vault.mint(1e18, address(this));\n    }\n\n    function testFailDepositZero() public {\n        vault.deposit(0, address(this));\n    }\n\n    function testMintZero() public {\n        vault.mint(0, address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testFailRedeemZero() public {\n        vault.redeem(0, address(this), address(this));\n    }\n\n    function testWithdrawZero() public {\n        vault.withdraw(0, address(this), address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testVaultInteractionsForSomeoneElse() public {\n        // init 2 users with a 1e18 balance\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n        underlying.mint(alice, 1e18);\n        underlying.mint(bob, 1e18);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 1e18);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 1e18);\n\n        // alice deposits 1e18 for bob\n        hevm.prank(alice);\n        vault.deposit(1e18, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(alice), 0);\n\n        // bob mint 1e18 for alice\n        hevm.prank(bob);\n        vault.mint(1e18, alice);\n        assertEq(vault.balanceOf(alice), 1e18);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 0);\n\n        // alice redeem 1e18 for bob\n        hevm.prank(alice);\n        vault.redeem(1e18, bob, alice);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 1e18);\n\n        // bob withdraw 1e18 for alice\n        hevm.prank(bob);\n        vault.withdraw(1e18, alice, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(underlying.balanceOf(alice), 1e18);\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/mixins/LeveragedLendingVault.t.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"../../lib/forge-std/src/Test.sol\";\nimport \"../../lib/solmate/src/test/utils/mocks/MockERC20.sol\";\n\nimport \"./LeveragedLendingVault.sol\";\n\ncontract MockLeveragedLendingVault is LeveragedLendingVault {\n    constructor(\n        MockERC20 asset\n    ) LeveragedLendingVault(asset, \"Vault Test\", \"VTest\") {}\n\n    uint256 private supplied;\n\n    uint256 private borrowed;\n\n    uint256 private supplyCap = type(uint256).max;\n\n    uint256 private borrowCap = type(uint256).max;\n\n    function getSuppliedToProtocol() public override view returns (uint256) {\n        return supplied;\n    }\n\n    function getBorrowedFromProtocol() public override view returns (uint256) {\n        return borrowed;\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        supplied += amount;\n        supplyCap -= amount;\n        MockERC20(address(asset)).burn(address(this), amount);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        supplied -= amount;\n        supplyCap += amount;\n        MockERC20(address(asset)).mint(address(this), amount);\n\n        require((borrowed == 0 && supplied == 0) || (borrowed * 1e18) / supplied <= 0.95e18, \"redeemed too much\");\n    }\n\n    function borrowFromProtocol(uint256 amount) internal override {        \n        borrowed += amount;\n        borrowCap -= amount;\n        MockERC20(address(asset)).mint(address(this), amount);\n\n        require(supplied != 0, \"not enough supply\");\n        require((borrowed * 1e18) / supplied <= 0.95e18, \"borrowed too much\");\n    }\n\n    function repayToProtocol(uint256 amount) internal override {\n        borrowed -= amount;\n        borrowCap += amount;\n        MockERC20(address(asset)).burn(address(this), amount);\n    }\n\n    function getProtocolLiquidity() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function getRemainingProtocolSupplyCap() public override view returns (uint256) {\n        return supplyCap;\n    }\n\n    function getRemainingProtocolBorrowCap() public override view returns (uint256) {\n        return borrowCap;\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory harvestables) {}\n\n    function harnestSetSupplied(uint256 value) public {\n        supplied = value;\n    }\n\n    function harnestSetBorrowed(uint256 value) public {\n        borrowed = value;\n    }\n\n    function harnessSetSupplyCap(uint256 value) public {\n        supplyCap = value;\n    }\n\n    function harnessSetBorrowCap(uint256 value) public {\n        borrowCap = value;\n    }\n}\n\ncontract LeveragedLendingVaultTest is Test {\n    MockERC20 public token;\n    MockLeveragedLendingVault public vault;\n\n    function setUp() public {\n        token = new MockERC20(\"Test\", \"TST\", 18);\n        vault = new MockLeveragedLendingVault(\n            token\n        );\n\n        token.approve(address(vault), type(uint256).max);\n        vault.setMaxCollateralRatio(0.95e18);\n        vault.setTargetCollateralRatio(0.90e18);\n    }\n\n    function testDeposit() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertApproxEqAbs(vault.getSuppliedToProtocol(), 195e18, 1);\n        assertApproxEqAbs(vault.getBorrowedFromProtocol(), 95e18, 1);\n        assertEq(vault.totalAssets(), 100e18);\n    }\n\n    function testRebalance() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        vault.rebalance();\n\n        assertApproxEqAbs(vault.getSuppliedToProtocol(), 1000e18, 1);\n        assertApproxEqAbs(vault.getBorrowedFromProtocol(), 900e18, 1);\n        assertEq(vault.totalAssets(), 100e18);\n    }\n\n    function testWithdrawal() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        vault.rebalance();\n        \n        vault.withdraw(10e18, address(this), address(this));\n\n        assertApproxEqAbs(vault.getSuppliedToProtocol(), 900e18, 1);\n        assertApproxEqAbs(vault.getBorrowedFromProtocol(), 810e18, 1);\n        assertEq(vault.totalAssets(), 90e18);\n    }\n\n    function testTotalWithdrawal() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        \n        vault.rebalance();\n\n        vault.withdraw(100e18, address(this), address(this));\n\n        assertEq(vault.getSuppliedToProtocol(), 0);\n        assertEq(vault.getBorrowedFromProtocol(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function _testBorrowCap() public {\n        vault.harnessSetBorrowCap(200e18);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        assertEq(vault.getSuppliedToProtocol(), 300e18);\n        assertEq(vault.getBorrowedFromProtocol(), 200e18);\n        assertEq(vault.totalAssets(), 100e18);\n\n        vault.withdraw(100e18, address(this), address(this));\n\n        assertEq(vault.getSuppliedToProtocol(), 0);\n        assertEq(vault.getBorrowedFromProtocol(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function _testSupplyCap() public {\n        vault.harnessSetSupplyCap(200e18);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        \n        assertEq(vault.getSuppliedToProtocol(), 200e18);\n        assertEq(vault.getBorrowedFromProtocol(), 100e18);\n        assertEq(vault.totalAssets(), 100e18);\n\n        vault.withdraw(100e18, address(this), address(this));\n\n        assertEq(vault.getSuppliedToProtocol(), 0);\n        assertEq(vault.getBorrowedFromProtocol(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function _testHitSupplyCapOnDeposit() public {\n        vault.harnessSetSupplyCap(50e18);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n        \n        assertEq(vault.getSuppliedToProtocol(), 50e18);\n        assertEq(vault.getBorrowedFromProtocol(), 0);\n        assertEq(vault.totalAssets(), 100e18);\n\n        vault.withdraw(100e18, address(this), address(this));\n\n        assertEq(vault.getSuppliedToProtocol(), 0);\n        assertEq(vault.getBorrowedFromProtocol(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testSettingMaxCollateralHigherByOwner() public {\n        address manager = makeAddr(\"manager\");\n        vault.setManager(manager);\n\n        vault.setMaxCollateralRatio(1e18);\n    }\n\n    function testSettingMaxCollateralHigherByManager() public {\n        address manager = makeAddr(\"manager\");\n        vault.setManager(manager);\n\n        vm.expectRevert(bytes(\"Only Owner can raise maxCollateralRatio\"));\n        vm.prank(manager);\n        vault.setMaxCollateralRatio(1e18);\n    }\n\n    function testSettingMaxCollateralLowerByOwner() public {\n        address manager = makeAddr(\"manager\");\n        vault.setManager(manager);\n\n        vault.setMaxCollateralRatio(0.5e18);\n    }\n\n    function testSettingMaxCollateralLowerByManager() public {\n        address manager = makeAddr(\"manager\");\n        vault.setManager(manager);\n\n        vm.prank(manager);\n        vault.setMaxCollateralRatio(0.5e18);\n    }\n\n    function testSettingTargetCollateralLowerOverMax() public {\n        vm.expectRevert(bytes(\"Cannot set targetCollateralRatio over maxCollateralRatio\"));\n        vault.setTargetCollateralRatio(1e18);\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/VaultLens.t.sol": {
      "content": "pragma solidity >= 0.8.0;\n\nimport \"../lib/forge-std/src/Test.sol\";\n\nimport \"../lib/solmate/src/test/utils/mocks/MockERC20.sol\";\n\nimport \"./mixins/Vault.sol\";\nimport \"./VaultLens.sol\";\n\ncontract MockVault is Vault {\n    using stdStorage for StdStorage;\n\n    constructor(\n        MockERC20 asset\n    ) Vault(asset, \"Vault Test\", \"VTest\") {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory harvestables) {}\n}\n\ncontract VaultLensTest is Test {\n    using stdStorage for StdStorage;\n\n    MockERC20 public token;\n    Vault public vault;\n    VaultLens public lens = new VaultLens();\n\n    function setUp() public {\n        token = new MockERC20(\"Test\", \"TST\", 18);\n        vault = new MockVault(\n            token\n        );\n\n        vault.setManager(address(this));\n\n        token.approve(address(vault), type(uint256).max);\n        vault.allowHarvestCall(address(token), 0x40c10f19, true);\n    }\n\n    function testVaultMetadata() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        VaultLens.VaultMetadata memory metadata = lens.getVaultMetadata(vault);\n\n        assertEq(metadata.vault, address(vault));\n        assertEq(metadata.asset, address(token));\n        assertEq(metadata.apy, 0);\n    }\n\n    function testAPY() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        skip(1 days);\n\n        token.mint(address(vault), 0.04e18);\n\n        vault.harvest(calls);\n\n        VaultLens.VaultMetadata memory metadata = lens.getVaultMetadata(vault);\n\n        assertApproxEqAbs(metadata.apy, 15.7e18, 0.1e18);\n    }\n\n    function testAPYWithRollingTimestamp() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 90e18);\n        vault.deposit(90e18, address(this));\n\n        skip(type(uint32).max - 50);\n\n        token.mint(address(vault), 10e18);\n\n        vault.harvest(calls);\n\n        skip(1 days);\n\n        token.mint(address(vault), 0.04e18);\n\n        vault.harvest(calls);\n\n        VaultLens.VaultMetadata memory metadata = lens.getVaultMetadata(vault);\n\n        assertApproxEqAbs(metadata.apy, 15.7e18, 0.1e18);\n    }\n\n    function testNegativeAPY() public {\n        HarvestCall[] memory calls = new HarvestCall[](0);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        token.burn(address(vault), 0.04e18);\n\n        skip(1 days);\n\n        vault.harvest(calls);\n\n        VaultLens.VaultMetadata memory metadata = lens.getVaultMetadata(vault);\n\n        assertApproxEqAbs(metadata.apy, -13.6e18, 0.1e18);\n    }\n\n    function testVaultsMetadata() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        Vault[] memory vaults = new Vault[](1);\n        vaults[0] = vault;\n        VaultLens.VaultMetadata[] memory metadataArr = lens.getVaultsMetadata(vaults);\n\n        assertEq(metadataArr[0].vault, address(vault));\n        assertEq(metadataArr[0].asset, address(token));\n        assertEq(metadataArr[0].apy, 0);\n    }\n\n    function testUserVaultMetadata() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        VaultLens.UserVaultMetadata memory metadata = lens.getUserVaultMetadata(address(this), vault);\n\n        assertEq(metadata.vault, address(vault));\n        assertEq(metadata.asset, address(token));\n        assertEq(metadata.apy, 0);\n        assertEq(metadata.balance, 100e18);\n    }\n\n    function testUserVaultsMetadata() public {\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        Vault[] memory vaults = new Vault[](1);\n        vaults[0] = vault;\n        VaultLens.UserVaultMetadata[] memory metadata = lens.getUserVaultsMetadata(address(this), vaults);\n\n        assertEq(metadata[0].vault, address(vault));\n        assertEq(metadata[0].asset, address(token));\n        assertEq(metadata[0].apy, 0);\n        assertEq(metadata[0].balance, 100e18);\n    }\n\n    function testUserVaultsMetadataWithMoreAssetsInVault() public {\n        token.mint(address(vault), 10e18);\n\n        token.mint(address(this), 100e18);\n        vault.deposit(100e18, address(this));\n\n        Vault[] memory vaults = new Vault[](1);\n        vaults[0] = vault;\n        VaultLens.UserVaultMetadata[] memory metadata = lens.getUserVaultsMetadata(address(this), vaults);\n\n        assertEq(metadata[0].vault, address(vault));\n        assertEq(metadata[0].asset, address(token));\n        assertEq(metadata[0].apy, 0);\n        assertEq(metadata[0].balance, 110e18);\n    }\n}\n\n"
    },
    "contracts/citrus-vaults/src/VaultLens.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"./mixins/Vault.sol\";\n\nimport \"./utils/LogExpMath.sol\";\n\ncontract VaultLens {\n    struct VaultMetadata {\n        address vault;\n        address asset;\n        int256 apy;\n        Harvestable[] harvestable;\n    }\n\n    struct UserVaultMetadata {\n        address vault;\n        address asset;\n        int apy;\n        uint8 decimals;\n        uint balance;\n    }\n\n    function getVaultMetadata(Vault vault) public view returns (VaultMetadata memory) {\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n        int256 apy = (int256(LogExpMath.pow(uint256(diffAssetsPerShare + 1e18), (365.25 days / diffTimestamp) * 1e18)) - 1e18) * 100;\n\n        return VaultMetadata({\n            vault: address(vault),\n            asset: address(vault.asset()),\n            apy: apy,\n            harvestable: vault.harvestable()\n        });\n    }\n\n    function getVaultsMetadata(Vault[] calldata vaults) public view returns (VaultMetadata[] memory) {\n        VaultMetadata[] memory arr = new VaultMetadata[](vaults.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            arr[i] = getVaultMetadata(vaults[i]);\n        }\n        return arr;\n    }\n\n    function getUserVaultMetadata(address user, Vault vault) public view returns (UserVaultMetadata memory) {\n        uint balance = vault.convertToAssets(vault.balanceOf(user));\n        uint8 decimals = vault.decimals();\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n        int256 apy = (int256(LogExpMath.pow(uint256(diffAssetsPerShare + 1e18), (365.25 days / diffTimestamp) * 1e18)) - 1e18) * 100;\n\n        return UserVaultMetadata({\n            vault: address(vault),\n            asset: address(vault.asset()),\n            apy: apy,\n            decimals: decimals,\n            balance: balance\n        });\n    }\n\n    function getUserVaultsMetadata(address user, Vault[] calldata vaults) public view returns (UserVaultMetadata[] memory) {\n        UserVaultMetadata[] memory arr = new UserVaultMetadata[](vaults.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            arr[i] = getUserVaultMetadata(user, vaults[i]);\n        }\n        return arr;\n    }\n}"
    },
    "contracts/citrus-vaults/src/utils/LogExpMath.sol": {
      "content": "// Copied from https://github.com/balancer-labs/balancer-v2-monorepo/blob/d2794ef7d8f6d321cde36b7c536e8d51971688bd/pkg/solidity-utils/contracts/math/LogExpMath.sol\n// Changes:\n// - solidity version: ^0.7.0 to >=0.8.0\n// - custom Balancer _require() to solidty require()\n\n// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity >=0.8.0;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        require(x < 2**255, \"LogExpMath: X_OUT_OF_BOUNDS\");\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        require(y < MILD_EXPONENT_BOUND, \"LogExpMath: Y_OUT_OF_BOUNDS\");\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            \"LogExpMath: PRODUCT_OUT_OF_BOUNDS\"\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"LogExpMath: INVALID_EXPONENT\");\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        require(a > 0, \"LogExpMath: OUT_OF_BOUNDS\");\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/SafeTransferLib.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {RevertingToken} from \"./utils/weird-tokens/RevertingToken.sol\";\nimport {ReturnsTwoToken} from \"./utils/weird-tokens/ReturnsTwoToken.sol\";\nimport {ReturnsFalseToken} from \"./utils/weird-tokens/ReturnsFalseToken.sol\";\nimport {MissingReturnToken} from \"./utils/weird-tokens/MissingReturnToken.sol\";\nimport {ReturnsTooMuchToken} from \"./utils/weird-tokens/ReturnsTooMuchToken.sol\";\nimport {ReturnsGarbageToken} from \"./utils/weird-tokens/ReturnsGarbageToken.sol\";\nimport {ReturnsTooLittleToken} from \"./utils/weird-tokens/ReturnsTooLittleToken.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\ncontract SafeTransferLibTest is DSTestPlus {\n    RevertingToken reverting;\n    ReturnsTwoToken returnsTwo;\n    ReturnsFalseToken returnsFalse;\n    MissingReturnToken missingReturn;\n    ReturnsTooMuchToken returnsTooMuch;\n    ReturnsGarbageToken returnsGarbage;\n    ReturnsTooLittleToken returnsTooLittle;\n\n    MockERC20 erc20;\n\n    function setUp() public {\n        reverting = new RevertingToken();\n        returnsTwo = new ReturnsTwoToken();\n        returnsFalse = new ReturnsFalseToken();\n        missingReturn = new MissingReturnToken();\n        returnsTooMuch = new ReturnsTooMuchToken();\n        returnsGarbage = new ReturnsGarbageToken();\n        returnsTooLittle = new ReturnsTooLittleToken();\n\n        erc20 = new MockERC20(\"StandardToken\", \"ST\", 18);\n        erc20.mint(address(this), type(uint256).max);\n    }\n\n    function testTransferWithMissingReturn() public {\n        verifySafeTransfer(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithStandardERC20() public {\n        verifySafeTransfer(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithReturnsTooMuch() public {\n        verifySafeTransfer(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithNonContract() public {\n        SafeTransferLib.safeTransfer(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn() public {\n        verifySafeTransferFrom(address(missingReturn), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithStandardERC20() public {\n        verifySafeTransferFrom(address(erc20), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithReturnsTooMuch() public {\n        verifySafeTransferFrom(address(returnsTooMuch), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithNonContract() public {\n        SafeTransferLib.safeTransferFrom(ERC20(address(0xBADBEEF)), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithMissingReturn() public {\n        verifySafeApprove(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithStandardERC20() public {\n        verifySafeApprove(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithReturnsTooMuch() public {\n        verifySafeApprove(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithNonContract() public {\n        SafeTransferLib.safeApprove(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferETH() public {\n        SafeTransferLib.safeTransferETH(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsFalse() public {\n        verifySafeTransfer(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReverting() public {\n        verifySafeTransfer(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsTooLittle() public {\n        verifySafeTransfer(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsFalse() public {\n        verifySafeTransferFrom(address(returnsFalse), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReverting() public {\n        verifySafeTransferFrom(address(reverting), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle() public {\n        verifySafeTransferFrom(address(returnsTooLittle), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsFalse() public {\n        verifySafeApprove(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReverting() public {\n        verifySafeApprove(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsTooLittle() public {\n        verifySafeApprove(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(missingReturn), to, amount);\n    }\n\n    function testTransferWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(erc20), to, amount);\n    }\n\n    function testTransferWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooMuch), to, amount);\n    }\n\n    function testTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testTransferWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransfer(ERC20(nonContract), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback() public {\n        SafeTransferLib.safeTransferETH(address(this), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(missingReturn), from, to, amount);\n    }\n\n    function testTransferFromWithStandardERC20(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(erc20), from, to, amount);\n    }\n\n    function testTransferFromWithReturnsTooMuch(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooMuch), from, to, amount);\n    }\n\n    function testTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testTransferFromWithNonContract(\n        address nonContract,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransferFrom(ERC20(nonContract), from, to, amount);\n    }\n\n    function testApproveWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(missingReturn), to, amount);\n    }\n\n    function testApproveWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(erc20), to, amount);\n    }\n\n    function testApproveWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooMuch), to, amount);\n    }\n\n    function testApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testApproveWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeApprove(ERC20(nonContract), to, amount);\n    }\n\n    function testTransferETH(\n        address recipient,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        // Transferring to msg.sender can fail because it's possible to overflow their ETH balance as it begins non-zero.\n        if (recipient.code.length > 0 || uint256(uint160(recipient)) <= 18 || recipient == msg.sender) return;\n\n        amount = bound(amount, 0, address(this).balance);\n\n        SafeTransferLib.safeTransferETH(recipient, amount);\n    }\n\n    function testFailTransferWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsFalse), to, amount);\n    }\n\n    function testFailTransferWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(reverting), to, amount);\n    }\n\n    function testFailTransferWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailTransferWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTwo), to, amount);\n    }\n\n    function testFailTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferFromWithReturnsFalse(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsFalse), from, to, amount);\n    }\n\n    function testFailTransferFromWithReverting(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(reverting), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooLittle), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTwo(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTwo), from, to, amount);\n    }\n\n    function testFailTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testFailApproveWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsFalse), to, amount);\n    }\n\n    function testFailApproveWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(reverting), to, amount);\n    }\n\n    function testFailApproveWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailApproveWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTwo), to, amount);\n    }\n\n    function testFailApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback(uint256 amount, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        SafeTransferLib.safeTransferETH(address(this), amount);\n    }\n\n    function verifySafeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransfer(ERC20(address(token)), to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (to == address(this)) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        forceApprove(token, from, address(this), amount);\n\n        // We cast to MissingReturnToken here because it won't check\n        // that there was return data, which accommodates all tokens.\n        MissingReturnToken(token).transfer(from, amount);\n\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransferFrom(ERC20(token), from, to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (from == to) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeTransferLib.safeApprove(ERC20(address(token)), to, amount);\n\n        assertEq(ERC20(token).allowance(address(this), to), amount);\n    }\n\n    function forceApprove(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 slot = token == address(erc20) ? 4 : 2; // Standard ERC20 name and symbol aren't constant.\n\n        hevm.store(\n            token,\n            keccak256(abi.encode(to, keccak256(abi.encode(from, uint256(slot))))),\n            bytes32(uint256(amount))\n        );\n\n        assertEq(ERC20(token).allowance(from, to), amount, \"wrong allowance\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/RevertingToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract RevertingToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"RevertingToken\";\n\n    string public constant symbol = \"RT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        revert();\n    }\n\n    function transfer(address, uint256) public virtual {\n        revert();\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        revert();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/ReturnsTwoToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTwoToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RTT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transfer(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/ReturnsFalseToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsFalseToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RFT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transfer(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/MissingReturnToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract MissingReturnToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"MissingReturnToken\";\n\n    string public constant symbol = \"MRT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/ReturnsTooMuchToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooMuchToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooMuchToken\";\n\n    string public constant symbol = \"RTMT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/ReturnsGarbageToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsGarbageToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsGarbageToken\";\n\n    string public constant symbol = \"RGT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes garbage;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setGarbage(bytes memory _garbage) public virtual {\n        garbage = _garbage;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/weird-tokens/ReturnsTooLittleToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooLittleToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooLittleToken\";\n\n    string public constant symbol = \"RTLT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transfer(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/ERC20.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp - 1))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp - 1, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/CREATE3.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {WETH} from \"../tokens/WETH.sol\";\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\n\nimport {CREATE3} from \"../utils/CREATE3.sol\";\n\ncontract CREATE3Test is DSTestPlus {\n    function testDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testFailDoubleDeploySameBytecode() public {\n        bytes32 salt = keccak256(bytes(\"Salty...\"));\n\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode() public {\n        bytes32 salt = keccak256(bytes(\"and sweet!\"));\n\n        CREATE3.deploy(salt, type(WETH).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testDeployERC20(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)), 0)\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), name);\n        assertEq(deployed.symbol(), symbol);\n        assertEq(deployed.decimals(), decimals);\n    }\n\n    function testFailDoubleDeploySameBytecode(bytes32 salt, bytes calldata bytecode) public {\n        CREATE3.deploy(salt, bytecode, 0);\n        CREATE3.deploy(salt, bytecode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode(\n        bytes32 salt,\n        bytes calldata bytecode1,\n        bytes calldata bytecode2\n    ) public {\n        CREATE3.deploy(salt, bytecode1, 0);\n        CREATE3.deploy(salt, bytecode2, 0);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockAuthChild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthChild is Auth(msg.sender, Authority(address(0))) {\n    bool public flag;\n\n    function updateFlag() public virtual requiresAuth {\n        flag = true;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/Bytes32AddressLib.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {Bytes32AddressLib} from \"../utils/Bytes32AddressLib.sol\";\n\ncontract Bytes32AddressLibTest is DSTestPlus {\n    function testFillLast12Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fillLast12Bytes(0xfEEDFaCEcaFeBEEFfEEDFACecaFEBeeFfeEdfAce),\n            0xfeedfacecafebeeffeedfacecafebeeffeedface000000000000000000000000\n        );\n    }\n\n    function testFromLast20Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fromLast20Bytes(0xfeedfacecafebeeffeedfacecafebeeffeedfacecafebeeffeedfacecafebeef),\n            0xCAfeBeefFeedfAceCAFeBEEffEEDfaCecafEBeeF\n        );\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthority is Authority {\n    bool immutable allowCalls;\n\n    constructor(bool _allowCalls) {\n        allowCalls = _allowCalls;\n    }\n\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public view override returns (bool) {\n        return allowCalls;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/RolesAuthority.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {RolesAuthority} from \"../auth/authorities/RolesAuthority.sol\";\n\ncontract RolesAuthorityTest is DSTestPlus {\n    RolesAuthority rolesAuthority;\n\n    function setUp() public {\n        rolesAuthority = new RolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n    }\n\n    function testSetPublicCapabilities(address target, bytes4 functionSig) public {\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/MultiRolesAuthority.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {MultiRolesAuthority} from \"../auth/authorities/MultiRolesAuthority.sol\";\n\ncontract MultiRolesAuthorityTest is DSTestPlus {\n    MultiRolesAuthority multiRolesAuthority;\n\n    function setUp() public {\n        multiRolesAuthority = new MultiRolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n    }\n\n    function testSetTargetCustomAuthority() public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0xCAFE)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0xCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthority() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(uint8 role, bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n    }\n\n    function testSetPublicCapabilities(bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n    }\n\n    function testSetTargetCustomAuthority(address user, Authority customAuthority) public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, customAuthority);\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(customAuthority));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthority(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/Auth.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\ncontract OutOfOrderAuthority is Authority {\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public pure override returns (bool) {\n        revert(\"OUT_OF_ORDER\");\n    }\n}\n\ncontract AuthTest is DSTestPlus {\n    MockAuthChild mockAuthChild;\n\n    function setUp() public {\n        mockAuthChild = new MockAuthChild();\n    }\n\n    function testSetOwnerAsOwner() public {\n        mockAuthChild.setOwner(address(0xBEEF));\n        assertEq(mockAuthChild.owner(), address(0xBEEF));\n    }\n\n    function testSetAuthorityAsOwner() public {\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n        assertEq(address(mockAuthChild.authority()), address(0xBEEF));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetOwnerWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setOwner(address(this));\n    }\n\n    function testSetAuthorityWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testCallFunctionWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetAuthorityAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setAuthority(new MockAuthority(true));\n    }\n\n    function testFailSetOwnerAsNonOwner() public {\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setOwner(address(0xBEEF));\n    }\n\n    function testFailSetAuthorityAsNonOwner() public {\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionAsNonOwner() public {\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailSetOwnerWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setOwner(address(this));\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailSetOwnerAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setOwner(address(0));\n    }\n\n    function testFailCallFunctionAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetOwnerAsOwner(address newOwner) public {\n        mockAuthChild.setOwner(newOwner);\n        assertEq(mockAuthChild.owner(), newOwner);\n    }\n\n    function testSetAuthorityAsOwner(Authority newAuthority) public {\n        mockAuthChild.setAuthority(newAuthority);\n        assertEq(address(mockAuthChild.authority()), address(newAuthority));\n    }\n\n    function testSetOwnerWithPermissiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setOwner(newOwner);\n    }\n\n    function testSetAuthorityWithPermissiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testCallFunctionWithPermissiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailSetOwnerAsNonOwner(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setOwner(newOwner);\n    }\n\n    function testFailSetAuthorityAsNonOwner(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionAsNonOwner(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailSetOwnerWithRestrictiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setOwner(newOwner);\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.setOwner(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailSetOwnerAsOwnerWithOutOfOrderAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setOwner(deadOwner);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/StdStorage.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdStorageTest is Test {\n    using stdStorage for StdStorage;\n\n    StorageTest test;\n\n    function setUp() public {\n        test = new StorageTest();\n    }\n\n    function testStorageHidden() public {\n        assertEq(uint256(keccak256(\"my.random.var\")), stdstore.target(address(test)).sig(\"hidden()\").find());\n    }\n\n    function testStorageObvious() public {\n        assertEq(uint256(0), stdstore.target(address(test)).sig(\"exists()\").find());\n    }\n\n    function testStorageCheckedWriteHidden() public {\n        stdstore.target(address(test)).sig(test.hidden.selector).checked_write(100);\n        assertEq(uint256(test.hidden()), 100);\n    }\n\n    function testStorageCheckedWriteObvious() public {\n        stdstore.target(address(test)).sig(test.exists.selector).checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    function testStorageMapStructA() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.map_struct.selector)\n            .with_key(address(this))\n            .depth(0)\n            .find();\n        assertEq(uint256(keccak256(abi.encode(address(this), 4))), slot);\n    }\n\n    function testStorageMapStructB() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.map_struct.selector)\n            .with_key(address(this))\n            .depth(1)\n            .find();\n       assertEq(uint256(keccak256(abi.encode(address(this), 4))) + 1, slot);\n    }\n\n    function testStorageDeepMap() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.deep_map.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .find();\n        assertEq(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint(5)))))), slot);\n    }\n\n    function testStorageCheckedWriteDeepMap() public {\n        stdstore\n            .target(address(test))\n            .sig(test.deep_map.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .checked_write(100);\n        assertEq(100, test.deep_map(address(this), address(this)));\n    }\n\n    function testStorageDeepMapStructA() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.deep_map_struct.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .depth(0)\n            .find();\n        assertEq(bytes32(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint(6)))))) + 0), bytes32(slot));\n    }\n\n    function testStorageDeepMapStructB() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.deep_map_struct.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .depth(1)\n            .find();\n        assertEq(bytes32(uint256(keccak256(abi.encode(address(this), keccak256(abi.encode(address(this), uint(6)))))) + 1), bytes32(slot));\n    }\n\n    function testStorageCheckedWriteDeepMapStructA() public {\n        stdstore\n            .target(address(test))\n            .sig(test.deep_map_struct.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .depth(0)\n            .checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(100, a);\n        assertEq(0, b);\n    }\n\n    function testStorageCheckedWriteDeepMapStructB() public {\n        stdstore\n            .target(address(test))\n            .sig(test.deep_map_struct.selector)\n            .with_key(address(this))\n            .with_key(address(this))\n            .depth(1)\n            .checked_write(100);\n        (uint256 a, uint256 b) = test.deep_map_struct(address(this), address(this));\n        assertEq(0, a);\n        assertEq(100, b);\n    }\n\n    function testStorageCheckedWriteMapStructA() public {\n        stdstore\n            .target(address(test))\n            .sig(test.map_struct.selector)\n            .with_key(address(this))\n            .depth(0)\n            .checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 100);\n        assertEq(b, 0);\n    }\n\n    function testStorageCheckedWriteMapStructB() public {\n        stdstore\n            .target(address(test))\n            .sig(test.map_struct.selector)\n            .with_key(address(this))\n            .depth(1)\n            .checked_write(100);\n        (uint256 a, uint256 b) = test.map_struct(address(this));\n        assertEq(a, 0);\n        assertEq(b, 100);\n    }\n\n    function testStorageStructA() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(0).find();\n        assertEq(uint256(7), slot);\n    }\n\n    function testStorageStructB() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.basic.selector).depth(1).find();\n        assertEq(uint256(7) + 1, slot);\n    }\n\n    function testStorageCheckedWriteStructA() public {\n        stdstore.target(address(test)).sig(test.basic.selector).depth(0).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 100);\n        assertEq(b, 1337);\n    }\n\n    function testStorageCheckedWriteStructB() public {\n         stdstore.target(address(test)).sig(test.basic.selector).depth(1).checked_write(100);\n        (uint256 a, uint256 b) = test.basic();\n        assertEq(a, 1337);\n        assertEq(b, 100);\n    }\n\n    function testStorageMapAddrFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).find();\n        assertEq(uint256(keccak256(abi.encode(address(this), uint(1)))), slot);\n    }\n\n    function testStorageMapUintFound() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).find();\n        assertEq(uint256(keccak256(abi.encode(100, uint(2)))), slot);\n    }\n\n    function testStorageCheckedWriteMapUint() public {\n        stdstore.target(address(test)).sig(test.map_uint.selector).with_key(100).checked_write(100);\n        assertEq(100, test.map_uint(100));\n    }\n\n    function testStorageCheckedWriteMapAddr() public {\n        stdstore.target(address(test)).sig(test.map_addr.selector).with_key(address(this)).checked_write(100);\n        assertEq(100, test.map_addr(address(this)));\n    }\n\n    function testStorageCheckedWriteMapBool() public {\n        stdstore.target(address(test)).sig(test.map_bool.selector).with_key(address(this)).checked_write(true);\n        assertTrue(test.map_bool(address(this)));\n    }\n\n    function testFailStorageCheckedWriteMapPacked() public {\n        // expect PackedSlot error but not external call so cant expectRevert\n        stdstore.target(address(test)).sig(test.read_struct_lower.selector).with_key(address(uint160(1337))).checked_write(100);\n    }\n\n    function testStorageCheckedWriteMapPackedSuccess() public {\n        uint256 full = test.map_packed(address(1337));\n        // keep upper 128, set lower 128 to 1337\n        full = (full & (uint256((1 << 128) - 1) << 128)) | 1337;\n        stdstore.target(address(test)).sig(test.map_packed.selector).with_key(address(uint160(1337))).checked_write(full);\n        assertEq(1337, test.read_struct_lower(address(1337)));\n    }\n\n    function testFailStorageConst() public {\n        // vm.expectRevert(abi.encodeWithSignature(\"NotStorage(bytes4)\", bytes4(keccak256(\"const()\"))));\n        stdstore.target(address(test)).sig(\"const()\").find();\n    }\n\n    function testFailStorageNativePack() public {\n        stdstore.target(address(test)).sig(test.tA.selector).find();\n        stdstore.target(address(test)).sig(test.tB.selector).find();\n        \n        // these both would fail\n        stdstore.target(address(test)).sig(test.tC.selector).find();\n        stdstore.target(address(test)).sig(test.tD.selector).find();\n    }\n\n    function testStorageReadBytes32() public {\n        bytes32 val = stdstore.target(address(test)).sig(test.tE.selector).read_bytes32();\n        assertEq(val, hex\"1337\");\n    }\n\n    function testStorageReadBool_False() public {\n        bool val = stdstore.target(address(test)).sig(test.tB.selector).read_bool();\n        assertEq(val, false);\n    }\n\n    function testStorageReadBool_True() public {\n        bool val = stdstore.target(address(test)).sig(test.tH.selector).read_bool();\n        assertEq(val, true);\n    }\n\n    function testStorageReadBool_Revert() public {\n        vm.expectRevert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n        this.readNonBoolValue();\n    }\n\n    function readNonBoolValue() public {\n        stdstore.target(address(test)).sig(test.tE.selector).read_bool();\n    }\n\n    function testStorageReadAddress() public {\n        address val = stdstore.target(address(test)).sig(test.tF.selector).read_address();\n        assertEq(val, address(1337));\n    }\n\n    function testStorageReadUint() public {\n        uint256 val = stdstore.target(address(test)).sig(test.exists.selector).read_uint();\n        assertEq(val, 1);\n    }\n\n    function testStorageReadInt() public {\n        int256 val = stdstore.target(address(test)).sig(test.tG.selector).read_int();\n        assertEq(val, type(int256).min);\n    }\n}\n\ncontract StorageTest {\n    uint256 public exists = 1;\n    mapping(address => uint256) public map_addr;\n    mapping(uint256 => uint256) public map_uint;\n    mapping(address => uint256) public map_packed;\n    mapping(address => UnpackedStruct) public map_struct;\n    mapping(address => mapping(address => uint256)) public deep_map;\n    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;\n    UnpackedStruct public basic;\n\n    uint248 public tA;\n    bool public tB;\n\n\n    bool public tC = false;\n    uint248 public tD = 1;    \n\n\n    struct UnpackedStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    mapping(address => bool) public map_bool;\n\n    bytes32 public tE = hex\"1337\";\n    address public tF = address(1337);\n    int256 public tG = type(int256).min;\n    bool public tH = true;\n\n    constructor() {\n        basic = UnpackedStruct({\n            a: 1337,\n            b: 1337\n        });\n\n        uint256 two = (1<<128) | 1;\n        map_packed[msg.sender] = two;\n        map_packed[address(bytes20(uint160(1337)))] = 1<<128;\n    }\n\n    function read_struct_upper(address who) public view returns (uint256) {\n        return map_packed[who] >> 128;\n    }\n\n    function read_struct_lower(address who) public view returns (uint256) {\n        return map_packed[who] & ((1 << 128) - 1);\n    }\n\n    function hidden() public view returns (bytes32 t) {\n        bytes32 slot = keccak256(\"my.random.var\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := sload(slot)\n        }\n    }\n\n    function const() public pure returns (bytes32 t) {\n        t = bytes32(hex\"1337\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/StdMath.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdMathTest is Test\n{\n    function testGetAbs() external {\n        assertEq(stdMath.abs(-50),      50);\n        assertEq(stdMath.abs(50),       50);\n        assertEq(stdMath.abs(-1337),    1337);\n        assertEq(stdMath.abs(0),        0);\n\n        assertEq(stdMath.abs(type(int256).min), (type(uint256).max >> 1) + 1);\n        assertEq(stdMath.abs(type(int256).max), (type(uint256).max >> 1));\n    }\n\n    function testGetAbs_Fuzz(int256 a) external {\n        uint256 manualAbs = getAbs(a);\n\n        uint256 abs = stdMath.abs(a);\n\n        assertEq(abs, manualAbs);\n    }\n\n    function testGetDelta_Uint() external {\n        assertEq(stdMath.delta(uint256(0),          uint256(0)),        0);\n        assertEq(stdMath.delta(uint256(0),          uint256(1337)),     1337);\n        assertEq(stdMath.delta(uint256(0),          type(uint64).max),  type(uint64).max);\n        assertEq(stdMath.delta(uint256(0),          type(uint128).max), type(uint128).max);\n        assertEq(stdMath.delta(uint256(0),          type(uint256).max), type(uint256).max);\n\n        assertEq(stdMath.delta(0,                   uint256(0)),        0);\n        assertEq(stdMath.delta(1337,                uint256(0)),        1337);\n        assertEq(stdMath.delta(type(uint64).max,    uint256(0)),        type(uint64).max);\n        assertEq(stdMath.delta(type(uint128).max,   uint256(0)),        type(uint128).max);\n        assertEq(stdMath.delta(type(uint256).max,   uint256(0)),        type(uint256).max);\n\n        assertEq(stdMath.delta(1337,                uint256(1337)),     0);\n        assertEq(stdMath.delta(type(uint256).max,   type(uint256).max), 0);\n        assertEq(stdMath.delta(5000,                uint256(1250)),     3750);\n    }\n\n    function testGetDelta_Uint_Fuzz(uint256 a, uint256 b) external {\n        uint256 manualDelta;\n        if (a > b) {\n            manualDelta = a - b;\n        } else {\n            manualDelta = b - a;\n        }\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function testGetDelta_Int() external {\n        assertEq(stdMath.delta(int256(0),           int256(0)),         0);\n        assertEq(stdMath.delta(int256(0),           int256(1337)),      1337);\n        assertEq(stdMath.delta(int256(0),           type(int64).max),   type(uint64).max >> 1);\n        assertEq(stdMath.delta(int256(0),           type(int128).max),  type(uint128).max >> 1);\n        assertEq(stdMath.delta(int256(0),           type(int256).max),  type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(0,                   int256(0)),         0);\n        assertEq(stdMath.delta(1337,                int256(0)),         1337);\n        assertEq(stdMath.delta(type(int64).max,     int256(0)),         type(uint64).max >> 1);\n        assertEq(stdMath.delta(type(int128).max,    int256(0)),         type(uint128).max >> 1);\n        assertEq(stdMath.delta(type(int256).max,    int256(0)),         type(uint256).max >> 1);\n\n        assertEq(stdMath.delta(-0,                  int256(0)),         0);\n        assertEq(stdMath.delta(-1337,               int256(0)),         1337);\n        assertEq(stdMath.delta(type(int64).min,     int256(0)),         (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int128).min,    int256(0)),         (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(type(int256).min,    int256(0)),         (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(int256(0),           -0),                0);\n        assertEq(stdMath.delta(int256(0),           -1337),             1337);\n        assertEq(stdMath.delta(int256(0),           type(int64).min),   (type(uint64).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0),           type(int128).min),  (type(uint128).max >> 1) + 1);\n        assertEq(stdMath.delta(int256(0),           type(int256).min),  (type(uint256).max >> 1) + 1);\n\n        assertEq(stdMath.delta(1337,                int256(1337)),      0);\n        assertEq(stdMath.delta(type(int256).max,    type(int256).max),  0);\n        assertEq(stdMath.delta(type(int256).min,    type(int256).min),  0);\n        assertEq(stdMath.delta(type(int256).min,    type(int256).max),  type(uint256).max);\n        assertEq(stdMath.delta(5000,                int256(1250)),      3750);\n    }\n\n    function testGetDelta_Int_Fuzz(int256 a, int256 b) external {\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB\n            ? absA - absB\n            : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 delta = stdMath.delta(a, b);\n\n        assertEq(delta, manualDelta);\n    }\n\n    function testGetPercentDelta_Uint() external {\n        assertEq(stdMath.percentDelta(uint256(0),           uint256(1337)),     1e18);\n        assertEq(stdMath.percentDelta(uint256(0),           type(uint64).max),  1e18);\n        assertEq(stdMath.percentDelta(uint256(0),           type(uint128).max), 1e18);\n        assertEq(stdMath.percentDelta(uint256(0),           type(uint192).max), 1e18);\n\n        assertEq(stdMath.percentDelta(1337,                 uint256(1337)),     0);\n        assertEq(stdMath.percentDelta(type(uint192).max,    type(uint192).max), 0);\n        assertEq(stdMath.percentDelta(0,                    uint256(2500)),     1e18);\n        assertEq(stdMath.percentDelta(2500,                 uint256(2500)),     0);\n        assertEq(stdMath.percentDelta(5000,                 uint256(2500)),     1e18);\n        assertEq(stdMath.percentDelta(7500,                 uint256(2500)),     2e18);\n\n        vm.expectRevert(stdError.divisionError);\n        stdMath.percentDelta(uint256(1), 0);\n    }\n\n    function testGetPercentDelta_Uint_Fuzz(uint192 a, uint192 b) external {\n        vm.assume(b != 0);\n        uint256 manualDelta;\n        if (a > b) {\n            manualDelta = a - b;\n        } else {\n            manualDelta = b - a;\n        }\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / b;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    function testGetPercentDelta_Int() external {\n        assertEq(stdMath.percentDelta(int256(0),        int256(1337)),      1e18);\n        assertEq(stdMath.percentDelta(int256(0),        -1337),             1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int64).min),   1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int128).min),  1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int192).min),  1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int64).max),   1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int128).max),  1e18);\n        assertEq(stdMath.percentDelta(int256(0),        type(int192).max),  1e18);\n\n        assertEq(stdMath.percentDelta(1337,             int256(1337)),      0);\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).max),  0);\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).min),  0);\n\n        assertEq(stdMath.percentDelta(type(int192).min, type(int192).max),  2e18); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(type(int192).max, type(int192).min),  2e18 - 1); // rounds the 1 wei diff down\n        assertEq(stdMath.percentDelta(0,                int256(2500)),      1e18);\n        assertEq(stdMath.percentDelta(2500,             int256(2500)),      0);\n        assertEq(stdMath.percentDelta(5000,             int256(2500)),      1e18);\n        assertEq(stdMath.percentDelta(7500,             int256(2500)),      2e18);\n\n        vm.expectRevert(stdError.divisionError);\n        stdMath.percentDelta(int256(1), 0);\n    }\n\n    function testGetPercentDelta_Int_Fuzz(int192 a, int192 b) external {\n        vm.assume(b != 0);\n        uint256 absA = getAbs(a);\n        uint256 absB = getAbs(b);\n        uint256 absDelta = absA > absB\n            ? absA - absB\n            : absB - absA;\n\n        uint256 manualDelta;\n        if ((a >= 0 && b >= 0) || (a < 0 && b < 0)) {\n            manualDelta = absDelta;\n        }\n        // (a < 0 && b >= 0) || (a >= 0 && b < 0)\n        else {\n            manualDelta = absA + absB;\n        }\n\n        uint256 manualPercentDelta = manualDelta * 1e18 / absB;\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        assertEq(percentDelta, manualPercentDelta);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   HELPERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function getAbs(int256 a) private pure returns (uint256) {\n        if (a < 0)\n            return a == type(int256).min ? uint256(type(int256).max) + 1 : uint256(-a);\n\n        return uint256(a);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/StdError.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.10 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdErrorsTest is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function testExpectAssertion() public {\n        vm.expectRevert(stdError.assertionError);\n        test.assertionError();\n    }\n\n    function testExpectArithmetic() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n\n    function testExpectDiv() public {\n        vm.expectRevert(stdError.divisionError);\n        test.divError(0);\n    }\n\n    function testExpectMod() public {\n        vm.expectRevert(stdError.divisionError);\n        test.modError(0);\n    }\n\n    function testExpectEnum() public {\n        vm.expectRevert(stdError.enumConversionError);\n        test.enumConversion(1);\n    }\n\n    function testExpectEncodeStg() public {\n        vm.expectRevert(stdError.encodeStorageError);\n        test.encodeStgError();\n    }\n\n    function testExpectPop() public {\n        vm.expectRevert(stdError.popError);\n        test.pop();\n    }\n\n    function testExpectOOB() public {\n        vm.expectRevert(stdError.indexOOBError);\n        test.indexOOBError(1);\n    }\n\n    function testExpectMem() public {\n        vm.expectRevert(stdError.memOverflowError);\n        test.mem();\n    }\n\n    function testExpectIntern() public {\n        vm.expectRevert(stdError.zeroVarError);\n        test.intern();\n    }\n\n    function testExpectLowLvl() public {\n        vm.expectRevert(stdError.lowLevelError);\n        test.someArr(0);\n    }\n}\n\ncontract ErrorsTest {\n    enum T {\n        T1\n    }\n\n    uint256[] public someArr;\n    bytes someBytes;\n\n    function assertionError() public pure {\n        assert(false);\n    }\n\n    function arithmeticError(uint256 a) public pure {\n        a -= 100;\n    }\n\n    function divError(uint256 a) public pure {\n        100 / a;\n    }\n\n    function modError(uint256 a) public pure {\n        100 % a;\n    }\n\n    function enumConversion(uint256 a) public pure {\n        T(a);\n    }\n\n    function encodeStgError() public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(someBytes.slot, 1)\n        }\n        keccak256(someBytes);\n    }\n\n    function pop() public {\n        someArr.pop();\n    }\n\n    function indexOOBError(uint256 a) public pure {\n        uint256[] memory t = new uint256[](0);\n        t[a];\n    }\n\n    function mem() public pure {\n        uint256 l = 2**256 / 32;\n        new uint256[](l);\n    }\n\n    function intern() public returns (uint256) {\n        function(uint256) internal returns (uint256) x;\n        x(2);\n        return 7;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/StdCheats.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testSkip() public {\n        vm.warp(100);\n        skip(25);\n        assertEq(block.timestamp, 125);\n    }\n\n    function testRewind() public {\n        vm.warp(100);\n        rewind(25);\n        assertEq(block.timestamp, 75);\n    }\n\n    function testHoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n    }\n\n    function testHoaxOrigin() public {\n        hoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n    }\n\n    function testHoaxDifferentAddresses() public {\n        hoax(address(1337), address(7331));\n        test.origin{value: 100}(address(1337), address(7331));\n    }\n\n    function testStartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testStartHoaxOrigin() public {\n        startHoax(address(1337), address(1337));\n        test.origin{value: 100}(address(1337));\n        test.origin{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n\n    function testChangePrank() public {\n        vm.startPrank(address(1337));\n        test.bar(address(1337));\n        changePrank(address(0xdead));\n        test.bar(address(0xdead));\n        changePrank(address(1337));\n        test.bar(address(1337));\n        vm.stopPrank();\n    }\n\n    function testMakeAddrEquivalence() public {\n        (address addr, ) = makeAddrAndKey(\"1337\");\n        assertEq(makeAddr(\"1337\"), addr);\n    }\n\n    function testMakeAddrSigning() public {\n        (address addr, uint256 key) = makeAddrAndKey(\"1337\");\n        bytes32 hash = keccak256(\"some_message\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(key, hash);\n        assertEq(ecrecover(hash, v, r, s), addr);\n    }\n\n    function testDeal() public {\n        deal(address(this), 1 ether);\n        assertEq(address(this).balance, 1 ether);\n    }\n\n    function testDealToken() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n    }\n\n    function testDealTokenAdjustTS() public {\n        Bar barToken = new Bar();\n        address bar = address(barToken);\n        deal(bar, address(this), 10000e18, true);\n        assertEq(barToken.balanceOf(address(this)), 10000e18);\n        assertEq(barToken.totalSupply(), 20000e18);\n        deal(bar, address(this), 0, true);\n        assertEq(barToken.balanceOf(address(this)), 0);\n        assertEq(barToken.totalSupply(), 10000e18);\n    }\n\n    function testBound() public {\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(10, 150, 190), 160);\n        assertEq(bound(300, 2800, 3200), 3100);\n        assertEq(bound(9999, 1337, 6666), 6006);\n    }\n\n    function testCannotBoundMaxLessThanMin() public {\n        vm.expectRevert(bytes(\"Test bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(5, 100, 10);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testBoundUint256Max() public {\n        assertEq(bound(0, type(uint256).max - 1, type(uint256).max), type(uint256).max - 1);\n        assertEq(bound(1, type(uint256).max - 1, type(uint256).max), type(uint256).max);\n    }\n\n    function testCannotBoundMaxLessThanMin(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        vm.assume(min > max);\n        vm.expectRevert(bytes(\"Test bound(uint256,uint256,uint256): Max is less than min.\"));\n        bound(num, min, max);\n    }\n\n    function testDeployCode() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", bytes(\"\"));\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    function testDeployCodeNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\");\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n    }\n\n    // We need that payable constructor in order to send ETH on construction\n    constructor() payable {}\n\n    function testDeployCodeVal() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", bytes(\"\"), 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n\tassertEq(deployed.balance, 1 ether);\n    }\n\n    function testDeployCodeValNoArgs() public {\n        address deployed = deployCode(\"StdCheats.t.sol:StdCheatsTest\", 1 ether);\n        assertEq(string(getCode(deployed)), string(getCode(address(this))));\n\tassertEq(deployed.balance, 1 ether);\n    }\n\n    // We need this so we can call \"this.deployCode\" rather than \"deployCode\" directly\n    function deployCodeHelper(string memory what) external {\n        deployCode(what);\n    }\n\n    function testDeployCodeFail() public {\n        vm.expectRevert(bytes(\"Test deployCode(string): Deployment failed.\"));\n        this.deployCodeHelper(\"StdCheats.t.sol:RevertingContract\");\n    }\n\n    function getCode(address who) internal view returns (bytes memory o_code) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(who)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(who, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n\ncontract Bar {\n    constructor() {\n        /// `DEAL` STDCHEAT\n        totalSupply = 10000e18;\n        balanceOf[address(this)] = totalSupply;\n    }\n\n    /// `HOAX` STDCHEATS\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedSender, \"!prank\");\n    }\n    function origin(address expectedSender, address expectedOrigin) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n        require(tx.origin == expectedOrigin, \"!prank\");\n    }\n\n    /// `DEAL` STDCHEAT\n    mapping (address => uint256) public balanceOf;\n    uint256 public totalSupply;\n}\n\ncontract RevertingContract {\n    constructor() {\n        revert();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/StdAssertions.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract StdAssertionsTest is Test\n{\n    string constant CUSTOM_ERROR = \"guh!\";\n\n    bool constant EXPECT_PASS = false;\n    bool constant EXPECT_FAIL = true;\n\n    TestTest t = new TestTest();\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    FAIL(STRING)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testShouldFail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._fail(CUSTOM_ERROR);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_FALSE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertFalse_Pass() external {\n        t._assertFalse(false, EXPECT_PASS);\n    }\n\n    function testAssertFalse_Fail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: Assertion Failed\");\n        t._assertFalse(true, EXPECT_FAIL);\n    }\n\n    function testAssertFalse_Err_Pass() external {\n        t._assertFalse(false, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertFalse_Err_Fail() external {\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertFalse(true, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(BOOL)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_Bool_Pass(bool a, bool b) external {\n        vm.assume(a == b);\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_Bool_Fail(bool a, bool b) external {\n        vm.assume(a != b);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [bool]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_BoolErr_Pass(bool a, bool b) external {\n        vm.assume(a == b);\n\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertEq_BoolErr_Fail(bool a, bool b) external {\n        vm.assume(a != b);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(BYTES)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_Bytes_Pass(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) == keccak256(b));\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_Bytes_Fail(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) != keccak256(b));\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [bytes]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_BytesErr_Pass(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) == keccak256(b));\n\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertEq_BytesErr_Fail(bytes calldata a, bytes calldata b) external {\n        vm.assume(keccak256(a) != keccak256(b));\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    ASSERT_EQ(ARRAY)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertEq_UintArr_Pass(uint256 e0, uint256 e1, uint256 e2) public {\n        uint256[] memory a = new uint256[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        uint256[] memory b = new uint256[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_IntArr_Pass(int256 e0, int256 e1, int256 e2) public {\n        int256[] memory a = new int256[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        int256[] memory b = new int256[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_AddressArr_Pass(address e0, address e1, address e2) public {\n        address[] memory a = new address[](3);\n        a[0] = e0;\n        a[1] = e1;\n        a[2] = e2;\n        address[] memory b = new address[](3);\n        b[0] = e0;\n        b[1] = e1;\n        b[2] = e2;\n\n        t._assertEq(a, b, EXPECT_PASS);\n    }\n\n    function testAssertEq_UintArr_FailEl(uint256 e1) public {\n        vm.assume(e1 != 0);\n        uint256[] memory a = new uint256[](3);\n        uint256[] memory b = new uint256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArr_FailEl(int256 e1) public {\n        vm.assume(e1 != 0);\n        int256[] memory a = new int256[](3);\n        int256[] memory b = new int256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n\n    function testAssertEq_AddressArr_FailEl(address e1) public {\n        vm.assume(e1 != address(0));\n        address[] memory a = new address[](3);\n        address[] memory b = new address[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArrErr_FailEl(uint256 e1) public {\n        vm.assume(e1 != 0);\n        uint256[] memory a = new uint256[](3);\n        uint256[] memory b = new uint256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArrErr_FailEl(int256 e1) public {\n        vm.assume(e1 != 0);\n        int256[] memory a = new int256[](3);\n        int256[] memory b = new int256[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n\n    function testAssertEq_AddressArrErr_FailEl(address e1) public {\n        vm.assume(e1 != address(0));\n        address[] memory a = new address[](3);\n        address[] memory b = new address[](3);\n        b[1] = e1;\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        uint256[] memory a = new uint256[](lenA);\n        uint256[] memory b = new uint256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        int256[] memory a = new int256[](lenA);\n        int256[] memory b = new int256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        address[] memory a = new address[](lenA);\n        address[] memory b = new address[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, EXPECT_FAIL);\n    }\n\n    function testAssertEq_UintArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        uint256[] memory a = new uint256[](lenA);\n        uint256[] memory b = new uint256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [uint[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_IntArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        int256[] memory a = new int256[](lenA);\n        int256[] memory b = new int256[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [int[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    function testAssertEq_AddressArrErr_FailLen(uint256 lenA, uint256 lenB) public {\n        vm.assume(lenA != lenB);\n        vm.assume(lenA <= 10000);\n        vm.assume(lenB <= 10000);\n        address[] memory a = new address[](lenA);\n        address[] memory b = new address[](lenB);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a == b not satisfied [address[]]\");\n        t._assertEq(a, b, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbs_Uint_Pass(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_Uint_Fail(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbs_UintErr_Pass(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_UintErr_Fail(uint256 a, uint256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_ABS(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqAbs_Int_Pass(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_Int_Fail(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqAbs(a, b, maxDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqAbs_IntErr_Pass(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) <= maxDelta);\n\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqAbs_IntErr_Fail(int256 a, int256 b, uint256 maxDelta) external {\n        vm.assume(stdMath.delta(a, b) > maxDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqAbs(a, b, maxDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL(UINT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRel_Uint_Pass(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_Uint_Fail(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [uint]\");\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRel_UintErr_Pass(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_UintErr_Fail(uint256 a, uint256 b, uint256 maxPercentDelta) external {\n        vm.assume(a < type(uint128).max && b < type(uint128).max && b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    APPROX_EQ_REL(INT)\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function testAssertApproxEqRel_Int_Pass(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_Int_Fail(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log(\"Error: a ~= b not satisfied [int]\");\n        t._assertApproxEqRel(a, b, maxPercentDelta, EXPECT_FAIL);\n    }\n\n    function testAssertApproxEqRel_IntErr_Pass(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) <= maxPercentDelta);\n\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_PASS);\n    }\n\n    function testAssertApproxEqRel_IntErr_Fail(int128 a, int128 b, uint128 maxPercentDelta) external {\n        vm.assume(b != 0);\n        vm.assume(stdMath.percentDelta(a, b) > maxPercentDelta);\n\n        vm.expectEmit(false, false, false, true);\n        emit log_named_string(\"Error\", CUSTOM_ERROR);\n        t._assertApproxEqRel(a, b, maxPercentDelta, CUSTOM_ERROR, EXPECT_FAIL);\n    }\n}\n\n\ncontract TestTest is Test\n{\n    modifier expectFailure(bool expectFail) {\n        bool preState = vm.load(HEVM_ADDRESS, bytes32(\"failed\")) != bytes32(0x00);\n        _;\n        bool postState = vm.load(HEVM_ADDRESS, bytes32(\"failed\")) != bytes32(0x00);\n\n        if (preState == true) {\n            return;\n        }\n\n        if (expectFail) {\n            require(postState == true, \"expected failure not triggered\");\n\n            // unwind the expected failure\n            vm.store(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x00)));\n        } else {\n            require(postState == false, \"unexpected failure was triggered\");\n        }\n    }\n\n    function _fail(string memory err) external expectFailure(true) {\n        fail(err);\n    }\n\n    function _assertFalse(bool data, bool expectFail) external expectFailure(expectFail) {\n        assertFalse(data);\n    }\n\n    function _assertFalse(bool data, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertFalse(data, err);\n    }\n\n    function _assertEq(bool a, bool b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(bool a, bool b, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(bytes memory a, bytes memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(bytes memory a,\n        bytes memory b,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(uint256[] memory a, uint256[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(int256[] memory a, int256[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(address[] memory a, address[] memory b, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b);\n    }\n\n    function _assertEq(uint256[] memory a, uint256[] memory b, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(int256[] memory a, int256[] memory b, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n    function _assertEq(address[] memory a, address[] memory b, string memory err, bool expectFail) external expectFailure(expectFail) {\n        assertEq(a, b, err);\n    }\n\n\n    function _assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbs(a, b, maxDelta);\n    }\n\n    function _assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbs(a, b, maxDelta, err);\n    }\n\n    function _assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbs(a, b, maxDelta);\n    }\n\n    function _assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqAbs(a, b, maxDelta, err);\n    }\n\n    function _assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRel(a, b, maxPercentDelta);\n    }\n\n    function _assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRel(a, b, maxPercentDelta, err);\n    }\n\n    function _assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRel(a, b, maxPercentDelta);\n    }\n\n    function _assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err,\n        bool expectFail\n    ) external expectFailure(expectFail) {\n        assertApproxEqRel(a, b, maxPercentDelta, err);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/forge-std/src/test/Script.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../Test.sol\";\n\ncontract ScriptTest is Test\n{\n     function testGenerateCorrectAddress() external {\n        address creation = computeCreateAddress(0x6C9FC64A53c1b71FB3f9Af64d1ae3A4931A5f4E9, 14);\n        assertEq(creation, 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    }\n}"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/SafeCastLib.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\n\ncontract SafeCastLibTest is DSTestPlus {\n    function testSafeCastTo248() public {\n        assertEq(SafeCastLib.safeCastTo248(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo248(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo224() public {\n        assertEq(SafeCastLib.safeCastTo224(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo224(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo192() public {\n        assertEq(SafeCastLib.safeCastTo192(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo192(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo160() public {\n        assertEq(SafeCastLib.safeCastTo160(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo160(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo128() public {\n        assertEq(SafeCastLib.safeCastTo128(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo128(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo96() public {\n        assertEq(SafeCastLib.safeCastTo96(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo96(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo64() public {\n        assertEq(SafeCastLib.safeCastTo64(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo64(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo32() public {\n        assertEq(SafeCastLib.safeCastTo32(2.5e8), 2.5e8);\n        assertEq(SafeCastLib.safeCastTo32(2.5e7), 2.5e7);\n    }\n\n    function testSafeCastTo24() public {\n        assertEq(SafeCastLib.safeCastTo24(2.5e4), 2.5e4);\n        assertEq(SafeCastLib.safeCastTo24(2.5e3), 2.5e3);\n    }\n\n    function testSafeCastTo8() public {\n        assertEq(SafeCastLib.safeCastTo8(100), 100);\n        assertEq(SafeCastLib.safeCastTo8(250), 250);\n    }\n\n    function testFailSafeCastTo248() public pure {\n        SafeCastLib.safeCastTo248(type(uint248).max + 1);\n    }\n\n    function testFailSafeCastTo224() public pure {\n        SafeCastLib.safeCastTo224(type(uint224).max + 1);\n    }\n\n    function testFailSafeCastTo192() public pure {\n        SafeCastLib.safeCastTo192(type(uint192).max + 1);\n    }\n\n    function testFailSafeCastTo160() public pure {\n        SafeCastLib.safeCastTo160(type(uint160).max + 1);\n    }\n\n    function testFailSafeCastTo128() public pure {\n        SafeCastLib.safeCastTo128(type(uint128).max + 1);\n    }\n\n    function testFailSafeCastTo96() public pure {\n        SafeCastLib.safeCastTo96(type(uint96).max + 1);\n    }\n\n    function testFailSafeCastTo64() public pure {\n        SafeCastLib.safeCastTo64(type(uint64).max + 1);\n    }\n\n    function testFailSafeCastTo32() public pure {\n        SafeCastLib.safeCastTo32(type(uint32).max + 1);\n    }\n\n    function testFailSafeCastTo8() public pure {\n        SafeCastLib.safeCastTo8(type(uint8).max + 1);\n    }\n\n    function testSafeCastTo248(uint256 x) public {\n        x = bound(x, 0, type(uint248).max);\n\n        assertEq(SafeCastLib.safeCastTo248(x), x);\n    }\n\n    function testSafeCastTo224(uint256 x) public {\n        x = bound(x, 0, type(uint224).max);\n\n        assertEq(SafeCastLib.safeCastTo224(x), x);\n    }\n\n    function testSafeCastTo192(uint256 x) public {\n        x = bound(x, 0, type(uint192).max);\n\n        assertEq(SafeCastLib.safeCastTo192(x), x);\n    }\n\n    function testSafeCastTo160(uint256 x) public {\n        x = bound(x, 0, type(uint160).max);\n\n        assertEq(SafeCastLib.safeCastTo160(x), x);\n    }\n\n    function testSafeCastTo128(uint256 x) public {\n        x = bound(x, 0, type(uint128).max);\n\n        assertEq(SafeCastLib.safeCastTo128(x), x);\n    }\n\n    function testSafeCastTo96(uint256 x) public {\n        x = bound(x, 0, type(uint96).max);\n\n        assertEq(SafeCastLib.safeCastTo96(x), x);\n    }\n\n    function testSafeCastTo64(uint256 x) public {\n        x = bound(x, 0, type(uint64).max);\n\n        assertEq(SafeCastLib.safeCastTo64(x), x);\n    }\n\n    function testSafeCastTo32(uint256 x) public {\n        x = bound(x, 0, type(uint32).max);\n\n        assertEq(SafeCastLib.safeCastTo32(x), x);\n    }\n\n    function testSafeCastTo8(uint256 x) public {\n        x = bound(x, 0, type(uint8).max);\n\n        assertEq(SafeCastLib.safeCastTo8(x), x);\n    }\n\n    function testFailSafeCastTo248(uint256 x) public {\n        x = bound(x, type(uint248).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo248(x);\n    }\n\n    function testFailSafeCastTo224(uint256 x) public {\n        x = bound(x, type(uint224).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo224(x);\n    }\n\n    function testFailSafeCastTo192(uint256 x) public {\n        x = bound(x, type(uint192).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo192(x);\n    }\n\n    function testFailSafeCastTo160(uint256 x) public {\n        x = bound(x, type(uint160).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo160(x);\n    }\n\n    function testFailSafeCastTo128(uint256 x) public {\n        x = bound(x, type(uint128).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo128(x);\n    }\n\n    function testFailSafeCastTo96(uint256 x) public {\n        x = bound(x, type(uint96).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo96(x);\n    }\n\n    function testFailSafeCastTo64(uint256 x) public {\n        x = bound(x, type(uint64).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo64(x);\n    }\n\n    function testFailSafeCastTo32(uint256 x) public {\n        x = bound(x, type(uint32).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo32(x);\n    }\n\n    function testFailSafeCastTo24(uint256 x) public {\n        x = bound(x, type(uint24).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo24(x);\n    }\n\n    function testFailSafeCastTo8(uint256 x) public {\n        x = bound(x, type(uint8).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo8(x);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/SSTORE2.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SSTORE2} from \"../utils/SSTORE2.sol\";\n\ncontract SSTORE2Test is DSTestPlus {\n    function testWriteRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        address pointer = SSTORE2.write(testBytes);\n\n        assertBytesEq(SSTORE2.read(pointer), testBytes);\n    }\n\n    function testWriteReadFullStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 0), hex\"11223344\");\n    }\n\n    function testWriteReadCustomStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1), hex\"223344\");\n    }\n\n    function testWriteReadFullBoundedRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);\n    }\n\n    function testWriteReadCustomBounds() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1, 3), hex\"2233\");\n    }\n\n    function testWriteReadEmptyBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 3, 3);\n    }\n\n    function testFailReadInvalidPointer() public view {\n        SSTORE2.read(DEAD_ADDRESS);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound() public view {\n        SSTORE2.read(DEAD_ADDRESS, 1);\n    }\n\n    function testFailReadInvalidPointerCustomBounds() public view {\n        SSTORE2.read(DEAD_ADDRESS, 2, 4);\n    }\n\n    function testFailWriteReadOutOfStartBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000);\n    }\n\n    function testFailWriteReadEmptyOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 42000, 42000);\n    }\n\n    function testFailWriteReadOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000, 42000);\n    }\n\n    function testWriteRead(bytes calldata testBytes, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes)), testBytes);\n    }\n\n    function testWriteReadCustomStartBound(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), startIndex), bytes(testBytes[startIndex:]));\n    }\n\n    function testWriteReadCustomBounds(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        endIndex = bound(endIndex, 0, testBytes.length);\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        if (startIndex > endIndex) return;\n\n        assertBytesEq(\n            SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex),\n            bytes(testBytes[startIndex:endIndex])\n        );\n    }\n\n    function testFailReadInvalidPointer(address pointer, bytes calldata brutalizeWith)\n        public\n        view\n        brutalizeMemory(brutalizeWith)\n    {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound(\n        address pointer,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testFailReadInvalidPointerCustomBounds(\n        address pointer,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testFailWriteReadCustomStartBoundOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        startIndex = bound(startIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex);\n    }\n\n    function testFailWriteReadCustomBoundsOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        endIndex = bound(endIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/ReentrancyGuard.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\n\ncontract RiskyContract is ReentrancyGuard {\n    uint256 public enterTimes;\n\n    function unprotectedCall() public {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function protectedCall() public nonReentrant {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function overprotectedCall() public nonReentrant {}\n}\n\ncontract ReentrancyGuardTest is DSTestPlus {\n    RiskyContract riskyContract;\n\n    function setUp() public {\n        riskyContract = new RiskyContract();\n    }\n\n    function invariantReentrancyStatusAlways1() public {\n        assertEq(uint256(hevm.load(address(riskyContract), 0)), 1);\n    }\n\n    function testFailUnprotectedCall() public {\n        riskyContract.unprotectedCall();\n\n        assertEq(riskyContract.enterTimes(), 1);\n    }\n\n    function testProtectedCall() public {\n        try riskyContract.protectedCall() {\n            fail(\"Reentrancy Guard Failed To Stop Attacker\");\n        } catch {}\n    }\n\n    function testNoReentrancy() public {\n        riskyContract.overprotectedCall();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/Owned.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockOwned} from \"./utils/mocks/MockOwned.sol\";\n\ncontract OwnedTest is DSTestPlus {\n    MockOwned mockOwned;\n\n    function setUp() public {\n        mockOwned = new MockOwned();\n    }\n\n    function testSetOwner() public {\n        testSetOwner(address(0xBEEF));\n    }\n\n    function testCallFunctionAsNonOwner() public {\n        testCallFunctionAsNonOwner(address(0));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockOwned.updateFlag();\n    }\n\n    function testSetOwner(address newOwner) public {\n        mockOwned.setOwner(newOwner);\n\n        assertEq(mockOwned.owner(), newOwner);\n    }\n\n    function testCallFunctionAsNonOwner(address owner) public {\n        hevm.assume(owner != address(this));\n\n        mockOwned.setOwner(owner);\n\n        hevm.expectRevert(\"UNAUTHORIZED\");\n        mockOwned.updateFlag();\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockOwned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Owned} from \"../../../auth/Owned.sol\";\n\ncontract MockOwned is Owned(msg.sender) {\n    bool public flag;\n\n    function updateFlag() public virtual onlyOwner {\n        flag = true;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/ERC1155.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\n\nimport {ERC1155TokenReceiver} from \"../tokens/ERC1155.sol\";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;\n    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, \"testing 123\");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, \"\");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n        token.mint(address(0xCAFE), 1338, 200, \"\");\n        token.mint(address(0xFACE), 1339, 300, \"\");\n        token.mint(address(0xDEAD), 1340, 400, \"\");\n        token.mint(address(0xFEED), 1341, 500, \"\");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, \"\");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, \"\");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, \"\");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](4);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](4);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](4);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](4);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address[](minLength);\n        uint256[] memory normalizedIds = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) || tos[i].code.length > 0 ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i < normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/utils/mocks/MockERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC1155} from \"../../../tokens/ERC1155.sol\";\n\ncontract MockERC1155 is ERC1155 {\n    function uri(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        _mint(to, id, amount, data);\n    }\n\n    function batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        _batchMint(to, ids, amounts, data);\n    }\n\n    function burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) public virtual {\n        _burn(from, id, amount);\n    }\n\n    function batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) public virtual {\n        _batchBurn(from, ids, amounts);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/test/DSTestPlus.t.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\ncontract DSTestPlusTest is DSTestPlus {\n    function testBound() public {\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(9999, 1337, 6666), 6006);\n        assertEq(bound(0, type(uint256).max - 6, type(uint256).max), type(uint256).max - 6);\n        assertEq(bound(6, type(uint256).max - 6, type(uint256).max), type(uint256).max);\n    }\n\n    function testFailBoundMinBiggerThanMax() public {\n        bound(5, 100, 10);\n    }\n\n    function testRelApproxEqBothZeroesPasses() public {\n        assertRelApproxEq(0, 0, 1e18);\n        assertRelApproxEq(0, 0, 0);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testFailBoundMinBiggerThanMax(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (max == min) {\n            unchecked {\n                min++; // Overflow is handled below.\n            }\n        }\n\n        if (max > min) (min, max) = (max, min);\n\n        bound(num, min, max);\n    }\n\n    function testBrutalizeMemory() public brutalizeMemory(\"FEEDFACECAFEBEEFFEEDFACECAFEBEEF\") {\n        bytes32 scratchSpace1;\n        bytes32 scratchSpace2;\n        bytes32 freeMem1;\n        bytes32 freeMem2;\n\n        assembly {\n            scratchSpace1 := mload(0)\n            scratchSpace2 := mload(32)\n            freeMem1 := mload(mload(0x40))\n            freeMem2 := mload(add(mload(0x40), 32))\n        }\n\n        assertGt(uint256(freeMem1), 0);\n        assertGt(uint256(freeMem2), 0);\n        assertGt(uint256(scratchSpace1), 0);\n        assertGt(uint256(scratchSpace2), 0);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @return totalSupply The token totalSupply.\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\n        require(success && data.length >= 32, \"BoringERC20: totalSupply failed\");\n        totalSupply = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) internal {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n        emit Transfer(address(0), user, amount);\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n    }\n\n    constructor() {\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringCooker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable avoid-low-level-calls\n// solhint-disable not-rely-on-time\n\n// This is a work in progress\n\ncontract CookTarget {\n    function onCook(address, bytes calldata) public payable virtual returns (bool success, bytes memory result) {\n        // Check that msg.sender is the BoringCooker. If so, you can trust sender to be verified.\n        return (true, \"\");\n    }\n}\n\ncontract BoringCooker is Domain {\n    mapping(address => uint256) public nonces;\n\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    uint8 private constant ACTION_CALL = 1;\n    uint8 private constant ACTION_COOK = 2;\n    uint8 private constant ACTION_SIGNED_COOK = 3;\n\n    // keccak256(\"Cook(address sender,address target,bytes data,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant COOK_SIGNATURE_HASH = 0x22efff3742eba32ab114c316a3e6dae791aea24d5d74f889a8f67bc7d4054f24;\n\n    // Verify that the cook call was signed and pass on the cook call params. Split out for stack reasons.\n    function _verifySignature(bytes memory data)\n        internal\n        returns (\n            address,\n            CookTarget,\n            bytes memory,\n            uint256\n        )\n    {\n        (address sender, CookTarget target, bytes memory data_, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(data, (address, CookTarget, bytes, uint256, uint256, uint8, bytes32, bytes32));\n\n        require(sender != address(0), \"Cooker: Sender cannot be 0\");\n        require(block.timestamp < deadline, \"Cooker: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(COOK_SIGNATURE_HASH, data_, sender, nonces[sender]++, deadline))), v, r, s) == sender,\n            \"Cooker: Invalid Signature\"\n        );\n        return (sender, target, data_, value);\n    }\n\n    function cook(uint8[] calldata actions, bytes[] calldata datas) external payable {\n        bytes memory result;\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_CALL) {\n                // Do any call. msg.sender will be the Cooker.\n                (address target, bytes4 signature, bytes memory data, uint256 value) = abi.decode(datas[i], (address, bytes4, bytes, uint256));\n                require(signature != CookTarget.onCook.selector, \"Use action cook\");\n                (bool success, bytes memory localResult) = target.call{value: value}(abi.encodePacked(signature, data));\n                if (!success) {\n                    revert(_getRevertMsg(localResult));\n                }\n                result = localResult;\n            } else if (action == ACTION_COOK) {\n                // Contracts that support cooking can accept the passed in sender as the verified msg.sender.\n                (CookTarget target, bytes memory data, uint256 value) = abi.decode(datas[i], (CookTarget, bytes, uint256));\n                (bool success, bytes memory localResult) = target.onCook{value: value}(msg.sender, data);\n                if (!success) {\n                    revert(_getRevertMsg(localResult));\n                }\n                result = localResult;\n            } else if (action == ACTION_SIGNED_COOK) {\n                // Contracts that support cooking can accept the passed in sender as the verified msg.sender (here verified by signed message).\n                (address sender, CookTarget target, bytes memory data, uint256 value) = _verifySignature(datas[i]);\n                (bool success, bytes memory localResult) = target.onCook{value: value}(sender, data);\n                if (!success) {\n                    revert(_getRevertMsg(localResult));\n                }\n                result = localResult;\n            }\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./interfaces/IMasterContract.sol\";\n\n// solhint-disable no-inline-assembly\n\ncontract BoringFactory {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n\n    /// @notice Mapping from clone contracts to their masterContract.\n    mapping(address => address) public masterContractOf;\n\n    /// @notice Mapping from masterContract to an array of all clones\n    /// On mainnet events can be used to get this list, but events aren't always easy to retrieve and\n    /// barely work on sidechains. While this adds gas, it makes enumerating all clones much easier.\n    mapping(address => address[]) public clonesOf;\n\n    /// @notice Returns the count of clones that exists for a specific masterContract\n    /// @param masterContract The address of the master contract.\n    /// @return cloneCount total number of clones for the masterContract.\n    function clonesOfCount(address masterContract) public view returns (uint256 cloneCount) {\n        cloneCount = clonesOf[masterContract].length;\n    }\n\n    /// @notice Deploys a given master Contract as a clone.\n    /// Any ETH transferred with this call is forwarded to the new clone.\n    /// Emits `LogDeploy`.\n    /// @param masterContract The address of the contract to clone.\n    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.\n    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.\n    /// @return cloneAddress Address of the created clone contract.\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) public payable returns (address cloneAddress) {\n        require(masterContract != address(0), \"BoringFactory: No masterContract\");\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\n\n        if (useCreate2) {\n            // each masterContract has different code already. So clones are distinguished by their data only.\n            bytes32 salt = keccak256(data);\n\n            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create2(0, clone, 0x37, salt)\n            }\n        } else {\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create(0, clone, 0x37)\n            }\n        }\n        masterContractOf[cloneAddress] = masterContract;\n        clonesOf[masterContract].push(cloneAddress);\n\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\n\n        emit LogDeploy(masterContract, data, cloneAddress);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += uint128(elastic);\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= uint128(elastic);\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/external/aave-v2/ILendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ninterface ILendingPoolAddressesProviderRegistry {\n  event AddressesProviderRegistered(address indexed newAddress);\n  event AddressesProviderUnregistered(address indexed newAddress);\n\n  function getAddressesProvidersList() external view returns (address[] memory);\n\n  function getAddressesProviderIdByAddress(address addressesProvider)\n    external\n    view\n    returns (uint256);\n\n  function registerAddressesProvider(address provider, uint256 id) external;\n\n  function unregisterAddressesProvider(address provider) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363633303634343432353234"
      }
    }
  }
}
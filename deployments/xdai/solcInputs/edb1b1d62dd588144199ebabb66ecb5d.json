{
  "language": "Solidity",
  "sources": {
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Simplified by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/BoringSolidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/Aave2ERC4626LeveragedVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../lib/BoringSolidity/contracts/interfaces/IERC20.sol\";\n\nimport \"./external/aave-v2/ILendingPool.sol\";\nimport \"./external/aave-v2/IAaveIncentivesController.sol\";\nimport \"./external/erc4626/IERC4626.sol\";\n\nimport \"./mixins/LeveragedLendingVault.sol\";\n\ncontract Aave2ERC4626LeveragedVault is LeveragedLendingVault {\n    ILendingPool lendingPool;\n\n    IAaveIncentivesController incentivesController;\n\n    IERC20 aToken;\n\n    IERC20 debtToken;\n\n    IERC4626 vault;\n\n    constructor(\n        ERC20 asset,\n        string memory name,\n        string memory symbol,\n        ILendingPool _lendingPool,\n        IAaveIncentivesController _incentivesController,\n        IERC4626 _vault\n    ) LeveragedLendingVault(asset, name, symbol) {\n        lendingPool = _lendingPool;\n        incentivesController = _incentivesController;\n\n        DataTypes.ReserveData memory assetData = lendingPool.getReserveData(address(asset));\n        DataTypes.ReserveData memory debtData = lendingPool.getReserveData(address(_vault));\n\n        aToken = IERC20(assetData.aTokenAddress);\n        debtToken = IERC20(debtData.variableDebtTokenAddress);\n        vault = _vault;\n\n        asset.approve(address(lendingPool), type(uint256).max);\n        asset.approve(address(vault), type(uint256).max);\n        vault.approve(address(lendingPool), type(uint256).max);\n    }\n\n    function getSuppliedToProtocol() public override view returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function getBorrowedFromProtocol() public override view returns (uint256) {\n        return vault.previewMint(debtToken.balanceOf(address(this)));\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        lendingPool.deposit(address(asset), amount, address(this), 0);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        lendingPool.withdraw(address(asset), amount, address(this));\n    }\n\n    function borrowFromProtocol(uint256 amount) internal override {\n        uint256 shares = vault.previewWithdraw(amount);\n        lendingPool.borrow(address(vault), shares, 2, 0, address(this));\n        vault.redeem(shares, address(this), address(this));\n    }\n\n    function repayToProtocol(uint256 amount) internal override {\n        uint256 shares = vault.previewDeposit(amount);\n        vault.mint(shares, address(this));\n        lendingPool.repay(address(vault), shares, 2, address(this));\n    }\n\n    function getProtocolLiquidity() public override view returns (uint256) {\n        return aToken.totalSupply() - vault.previewMint(debtToken.totalSupply());\n    }\n\n    function getRemainingProtocolSupplyCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function getRemainingProtocolBorrowCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function collectHarvest() internal override {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        incentivesController.claimRewards(\n            assets,\n            incentivesController.getRewardsBalance(assets, address(this)),\n            address(this)\n        );\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory) {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        address rewardToken = incentivesController.REWARD_TOKEN();\n        uint256 amount = incentivesController.getRewardsBalance(assets, address(this));\n\n        Harvestable[] memory arr = new Harvestable[](1);\n        arr[0] = Harvestable({\n            token: rewardToken,\n            amount: amount\n        });\n        return arr;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/Aave2LeveragedVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../lib/BoringSolidity/contracts/interfaces/IERC20.sol\";\n\nimport \"./external/aave-v2/ILendingPool.sol\";\nimport \"./external/aave-v2/IAaveIncentivesController.sol\";\n\nimport \"./mixins/LeveragedLendingVault.sol\";\n\ncontract Aave2LeveragedVault is LeveragedLendingVault {\n    ILendingPool lendingPool;\n    \n    IAaveIncentivesController incentivesController;\n\n    IERC20 aToken;\n    \n    IERC20 debtToken;\n    \n    constructor(\n        ERC20 asset,\n        string memory name,\n        string memory symbol,\n        ILendingPool _lendingPool,\n        IAaveIncentivesController _incentivesController\n    ) LeveragedLendingVault(asset, name, symbol) {\n        lendingPool = _lendingPool;\n        incentivesController = _incentivesController;\n\n        DataTypes.ReserveData memory data = lendingPool.getReserveData(address(asset));\n\n        aToken = IERC20(data.aTokenAddress);\n        debtToken = IERC20(data.variableDebtTokenAddress);\n\n        asset.approve(address(lendingPool), type(uint256).max);\n    }\n\n    function getSuppliedToProtocol() public override view returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function getBorrowedFromProtocol() public override view returns (uint256) {\n        return debtToken.balanceOf(address(this));\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        lendingPool.deposit(address(asset), amount, address(this), 0);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        lendingPool.withdraw(address(asset), amount, address(this));\n    }\n\n    function borrowFromProtocol(uint256 amount) internal override {\n        lendingPool.borrow(address(asset), amount, 2, 0, address(this));\n    }\n\n    function repayToProtocol(uint256 amount) internal override {\n        lendingPool.repay(address(asset), amount, 2, address(this));\n    }\n\n    function getProtocolLiquidity() public override view returns (uint256) {\n        return aToken.totalSupply() - debtToken.totalSupply();\n    }\n\n    function getRemainingProtocolSupplyCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function getRemainingProtocolBorrowCap() public override pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function collectHarvest() internal override {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        incentivesController.claimRewards(\n            assets,\n            incentivesController.getRewardsBalance(assets, address(this)),\n            address(this)\n        );\n    }\n\n    function harvestable() public override view returns (Harvestable[] memory) {\n        address[] memory assets = new address[](2);\n        assets[0] = address(aToken);\n        assets[1] = address(debtToken);\n\n        address rewardToken = incentivesController.REWARD_TOKEN();\n        uint256 amount = incentivesController.getRewardsBalance(assets, address(this));\n\n        Harvestable[] memory arr = new Harvestable[](1);\n        arr[0] = Harvestable({\n            token: rewardToken,\n            amount: amount\n        });\n        return arr;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/Aave2Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../lib/BoringSolidity/contracts/interfaces/IERC20.sol\";\n\nimport \"./external/aave-v2/ILendingPool.sol\";\nimport \"./external/aave-v2/IAaveIncentivesController.sol\";\n\nimport \"./mixins/SimpleVault.sol\";\n\ncontract Aave2Vault is SimpleVault {\n    ILendingPool lendingPool;\n\n    IAaveIncentivesController incentivesController;\n\n    IERC20 aToken;\n\n    constructor(\n        ERC20 asset,\n        string memory name,\n        string memory symbol,\n        ILendingPool _lendingPool,\n        IAaveIncentivesController _incentivesController\n    ) SimpleVault(asset, name, symbol) {\n        lendingPool = _lendingPool;\n        incentivesController = _incentivesController;\n\n        DataTypes.ReserveData memory data = lendingPool.getReserveData(\n            address(asset)\n        );\n\n        aToken = IERC20(data.aTokenAddress);\n\n        asset.approve(address(lendingPool), type(uint256).max);\n    }\n\n    function getSuppliedToProtocol() public view override returns (uint256) {\n        return aToken.balanceOf(address(this));\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        lendingPool.deposit(address(asset), amount, address(this), 0);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        lendingPool.withdraw(address(asset), amount, address(this));\n    }\n\n    function getRemainingProtocolSupplyCap()\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return type(uint256).max;\n    }\n\n    function collectHarvest() internal override {\n        if (address(incentivesController) == address(0)) {\n            return;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n\n        incentivesController.claimRewards(\n            assets,\n            incentivesController.getRewardsBalance(assets, address(this)),\n            address(this)\n        );\n    }\n\n    function harvestable() public view override returns (Harvestable[] memory) {\n        if (address(incentivesController) == address(0)) {\n            return new Harvestable[](0);\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n\n        address rewardToken = incentivesController.REWARD_TOKEN();\n        uint256 amount = incentivesController.getRewardsBalance(\n            assets,\n            address(this)\n        );\n\n        Harvestable[] memory arr = new Harvestable[](1);\n        arr[0] = Harvestable({token: rewardToken, amount: amount});\n        return arr;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/external/aave-v2/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\ninterface IAaveIncentivesController {\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  event RewardsClaimed(\n    address indexed user,\n    address indexed to,\n    address indexed claimer,\n    uint256 amount\n  );\n\n  event ClaimerSet(address indexed user, address indexed claimer);\n\n  /*\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function getAssetData(address asset)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  /*\n   * LEGACY **************************\n   * @dev Returns the configuration of the distribution for a certain asset\n   * @param asset The address of the reference asset of the distribution\n   * @return The asset index, the emission per second and the last updated timestamp\n   **/\n  function assets(address asset)\n    external\n    view\n    returns (\n      uint128,\n      uint128,\n      uint256\n    );\n\n  /**\n   * @dev Whitelists an address to claim the rewards on behalf of another address\n   * @param user The address of the user\n   * @param claimer The address of the claimer\n   */\n  function setClaimer(address user, address claimer) external;\n\n  /**\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n   * @param user The address of the user\n   * @return The claimer address\n   */\n  function getClaimer(address user) external view returns (address);\n\n  /**\n   * @dev Configure assets for a certain rewards emission\n   * @param assets The assets to incentivize\n   * @param emissionsPerSecond The emission for each asset\n   */\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external;\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param asset The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleAction(\n    address asset,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param user the address of the user\n   * @param asset The asset to incentivize\n   * @return the user index for the asset\n   */\n  function getUserAssetData(address user, address asset) external view returns (uint256);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function REWARD_TOKEN() external view returns (address);\n\n  /**\n   * @dev for backward compatibility with previous implementation of the Incentives controller\n   */\n  function PRECISION() external view returns (uint8);\n\n  /**\n   * @dev Gets the distribution end timestamp of the emissions\n   */\n  function DISTRIBUTION_END() external view returns (uint256);\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}"
    },
    "contracts/citrus-vaults/src/external/aave-v2/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}"
    },
    "contracts/citrus-vaults/src/external/erc4626/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @title ERC4626 interface\n/// See: https://eips.ethereum.org/EIPS/eip-4626\nabstract contract IERC4626 is ERC20 {\n    /*////////////////////////////////////////////////////////\n                      Events\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice `sender` has exchanged `assets` for `shares`,\n    /// and transferred those `shares` to `receiver`.\n    event Deposit(address indexed sender, address indexed receiver, uint256 assets, uint256 shares);\n\n    /// @notice `sender` has exchanged `shares` for `assets`,\n    /// and transferred those `assets` to `receiver`.\n    event Withdraw(address indexed sender, address indexed receiver, uint256 assets, uint256 shares);\n\n    /*////////////////////////////////////////////////////////\n                      Vault properties\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the underlying ERC20 token used for\n    /// the Vault for accounting, depositing, and withdrawing.\n    function asset() external view virtual returns (address asset);\n\n    /// @notice Total amount of the underlying asset that\n    /// is \"managed\" by Vault.\n    function totalAssets() external view virtual returns (uint256 totalAssets);\n\n    /*////////////////////////////////////////////////////////\n                      Deposit/Withdrawal Logic\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice Mints `shares` Vault shares to `receiver` by\n    /// depositing exactly `assets` of underlying tokens.\n    function deposit(uint256 assets, address receiver) external virtual returns (uint256 shares);\n\n    /// @notice Mints exactly `shares` Vault shares to `receiver`\n    /// by depositing `assets` of underlying tokens.\n    function mint(uint256 shares, address receiver) external virtual returns (uint256 assets);\n\n    /// @notice Redeems `shares` from `owner` and sends `assets`\n    /// of underlying tokens to `receiver`.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 shares);\n\n    /// @notice Redeems `shares` from `owner` and sends `assets`\n    /// of underlying tokens to `receiver`.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external virtual returns (uint256 assets);\n\n    /*////////////////////////////////////////////////////////\n                      Vault Accounting Logic\n    ////////////////////////////////////////////////////////*/\n\n    /// @notice The amount of shares that the vault would\n    /// exchange for the amount of assets provided, in an\n    /// ideal scenario where all the conditions are met.\n    function convertToShares(uint256 assets) external view virtual returns (uint256 shares);\n\n    /// @notice The amount of assets that the vault would\n    /// exchange for the amount of shares provided, in an\n    /// ideal scenario where all the conditions are met.\n    function convertToAssets(uint256 shares) external view virtual returns (uint256 assets);\n\n    /// @notice Total number of underlying assets that can\n    /// be deposited by `owner` into the Vault, where `owner`\n    /// corresponds to the input parameter `receiver` of a\n    /// `deposit` call.\n    function maxDeposit(address owner) external view virtual returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate\n    /// the effects of their deposit at the current block, given\n    /// current on-chain conditions.\n    function previewDeposit(uint256 assets) external view virtual returns (uint256 shares);\n\n    /// @notice Total number of underlying shares that can be minted\n    /// for `owner`, where `owner` corresponds to the input\n    /// parameter `receiver` of a `mint` call.\n    function maxMint(address owner) external view virtual returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate\n    /// the effects of their mint at the current block, given\n    /// current on-chain conditions.\n    function previewMint(uint256 shares) external view virtual returns (uint256 assets);\n\n    /// @notice Total number of underlying assets that can be\n    /// withdrawn from the Vault by `owner`, where `owner`\n    /// corresponds to the input parameter of a `withdraw` call.\n    function maxWithdraw(address owner) external view virtual returns (uint256 maxAssets);\n\n    /// @notice Allows an on-chain or off-chain user to simulate\n    /// the effects of their withdrawal at the current block,\n    /// given current on-chain conditions.\n    function previewWithdraw(uint256 assets) external view virtual returns (uint256 shares);\n\n    /// @notice Total number of underlying shares that can be\n    /// redeemed from the Vault by `owner`, where `owner` corresponds\n    /// to the input parameter of a `redeem` call.\n    function maxRedeem(address owner) external view virtual returns (uint256 maxShares);\n\n    /// @notice Allows an on-chain or off-chain user to simulate\n    /// the effects of their redeemption at the current block,\n    /// given current on-chain conditions.\n    function previewRedeem(uint256 shares) external view virtual returns (uint256 assets);\n}\n"
    },
    "contracts/citrus-vaults/src/external/uniswap-v1/IStakingRewards.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface IStakingRewards {\n    // Views\n    function balanceOf(address account) external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function rewardsToken() external view returns (address);\n\n    // Mutative\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n}\n"
    },
    "contracts/citrus-vaults/src/external/uniswap-v2/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.8.0;\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/citrus-vaults/src/harvesters/Swapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../../lib/solmate/src/tokens/ERC20.sol\";\n\nimport \"../external/uniswap-v2/IUniswapV2Router02.sol\";\n\ncontract Swapper {\n    function uniswapSwap(\n        address router,\n        address[] memory path\n    ) public {\n        uint256 amountIn = ERC20(path[0]).balanceOf(address(this)) - 1;\n        ERC20(path[0]).approve(router, amountIn);\n        IUniswapV2Router02 honeyswapRouter = IUniswapV2Router02(router);\n        honeyswapRouter.swapExactTokensForTokens(\n            amountIn,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function approveAndCall(\n        address exchange,\n        bytes calldata data,\n        address inputToken\n    ) public {\n        uint256 amountIn = ERC20(inputToken).balanceOf(address(this));\n\n        ERC20(inputToken).approve(exchange, amountIn);\n\n        (bool success, bytes memory errorMessage) = address(exchange).call(data);\n        if (!success) {\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            if (errorMessage.length < 68) revert();\n            assembly {\n                errorMessage := add(errorMessage, 0x04)\n            }\n            revert(abi.decode(errorMessage, (string)));\n        }\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/HopVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../lib/BoringSolidity/contracts/interfaces/IERC20.sol\";\n\nimport \"./external/uniswap-v1/IStakingRewards.sol\";\n\nimport \"./mixins/SimpleVault.sol\";\n\ncontract HopVault is SimpleVault {\n    IStakingRewards stakingRewards;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol,\n        IStakingRewards _stakingRewards\n    ) SimpleVault(_asset, _name, _symbol) {\n        stakingRewards = _stakingRewards;\n\n        _asset.approve(address(_stakingRewards), type(uint256).max);\n    }\n\n    function getSuppliedToProtocol() public view override returns (uint256) {\n        return stakingRewards.balanceOf(address(this));\n    }\n\n    function supplyToProtocol(uint256 amount) internal override {\n        stakingRewards.stake(amount);\n    }\n\n    function redeemFromProtocol(uint256 amount) internal override {\n        stakingRewards.withdraw(amount);\n    }\n\n    function getRemainingProtocolSupplyCap()\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return type(uint256).max;\n    }\n\n    function collectHarvest() internal override {\n        stakingRewards.getReward();\n    }\n\n    function harvestable() public view override returns (Harvestable[] memory) {\n        address rewardToken = stakingRewards.rewardsToken();\n\n        Harvestable[] memory harvestables = new Harvestable[](1);\n        harvestables[0] = Harvestable({\n            token: rewardToken,\n            amount: stakingRewards.earned(address(this))\n        });\n\n        return harvestables;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/mixins/LeveragedLendingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./Vault.sol\";\n\nabstract contract LeveragedLendingVault is Vault {\n    uint256 public targetCollateralRatio;\n\n    uint256 public maxCollateralRatio;\n\n    event TargetCollateralRatioUpdated(uint256 oldTargetCollateralRatio, uint256 newTargetCollateralRatio);\n\n    event MaxCollateralRatioUpdated(uint256 oldMaxCollateralRatio, uint256 newMaxCollateralRatio);\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) Vault(_asset, _name, _symbol) {}\n\n    /////  Leverage logic  /////\n\n    function rebalance(uint256 amountToFreeUp, bool totalRampUp) internal {\n        uint256 assetBalance = asset.balanceOf(address(this));\n\n        if (assetBalance > 0) {\n            supplyToProtocol(assetBalance);\n        }\n\n        uint256 borrowed = getBorrowedFromProtocol();\n        uint256 supplied = getSuppliedToProtocol();\n        uint256 targetBorrow = FixedPointMathLib.mulDivDown(targetCollateralRatio, supplied - borrowed - amountToFreeUp, 1e18 - targetCollateralRatio);\n\n        if (borrowed < targetBorrow) {\n            // ramp up\n            while(borrowed * 1e18 < targetBorrow * 0.995e18) {\n                uint256 toBorrow = targetBorrow - borrowed;\n                uint256 maxBorrow = FixedPointMathLib.mulDivDown(supplied, maxCollateralRatio, 1e18) - borrowed;\n\n                if (toBorrow > maxBorrow) {\n                    toBorrow = maxBorrow;\n                }\n\n                borrowFromProtocol(toBorrow);\n                supplyToProtocol(toBorrow);\n\n                if (!totalRampUp) {\n                    break;\n                }\n\n                borrowed = getBorrowedFromProtocol();\n                supplied = getSuppliedToProtocol();\n            }\n        } else if (borrowed > targetBorrow) {\n            // ramp down\n            while(borrowed * 1e18 > targetBorrow * 1.005e18) {\n                uint256 toRepay = borrowed - targetBorrow;\n                uint256 maxRepay = FixedPointMathLib.mulDivDown(supplied, maxCollateralRatio, 1e18) - borrowed;\n\n                if (toRepay > maxRepay) {\n                    toRepay = maxRepay;\n                }\n                \n                redeemFromProtocol(toRepay);\n                repayToProtocol(toRepay);\n\n                borrowed = getBorrowedFromProtocol();\n                supplied = getSuppliedToProtocol();\n            }\n        }\n\n        if (amountToFreeUp > 0) {\n            redeemFromProtocol(amountToFreeUp);\n        }\n    }\n\n    function rebalance() public {\n        rebalance(0, true);\n    }\n\n    /////  Vault hooks  /////\n\n    function onDeposit(uint256) internal override {\n        rebalance(0, false);\n    }\n\n    function onWithdraw(uint256 assets) internal override {\n        rebalance(assets, false);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) + getSuppliedToProtocol() - getBorrowedFromProtocol();\n    }\n\n    function onHarvest() internal override {\n        collectHarvest();\n    }\n\n    function afterHarvest() internal override {\n        rebalance(0, true);\n    }\n\n    /////  Collateral ratios  /////\n\n    function setMaxCollateralRatio(uint256 newMaxCollateralRatio) public onlyManagerOrOwner {\n        uint oldMaxCollateralRatio = maxCollateralRatio;\n\n        require(msg.sender == owner || newMaxCollateralRatio < oldMaxCollateralRatio, \"Only Owner can raise maxCollateralRatio\");\n\n        maxCollateralRatio = newMaxCollateralRatio;\n        emit MaxCollateralRatioUpdated(oldMaxCollateralRatio, newMaxCollateralRatio);\n    }\n\n    function setTargetCollateralRatio(uint256 newTargetCollateralRatio) public onlyManagerOrOwner {\n        require(newTargetCollateralRatio < maxCollateralRatio, \"Cannot set targetCollateralRatio over maxCollateralRatio\");\n        emit TargetCollateralRatioUpdated(targetCollateralRatio, newTargetCollateralRatio);\n        targetCollateralRatio = newTargetCollateralRatio;\n    }\n\n    /////  Hooks  /////\n\n    /**\n     * @notice Get amount of assets supplied to the protocol by the vault\n     * @return Assets supplied\n     */\n    function getSuppliedToProtocol() public virtual view returns (uint256);\n\n    /**\n     * @notice Get amount of assets borrowed from the protocol by the vault\n     * @return Assets borrowed\n     */\n    function getBorrowedFromProtocol() public virtual view returns (uint256);\n\n    /**\n     * @notice Supply assets to protocol\n     * @param amount Assets to supply to the protocol\n     */\n    function supplyToProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Withdraw assets from protocol\n     * @param amount Assets to redeem from the protocol\n     */\n    function redeemFromProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Borrow assets from protocol\n     * @param amount Assets to borrow from the protocol\n     */\n    function borrowFromProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Repay debt to protocol\n     * @param amount Assets to repay to the protocol\n     */\n    function repayToProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Get liquidity availailable in the protocol\n     * @return liquidity The diff\n     * @dev ignored on this version\n     */\n    function getProtocolLiquidity() public virtual view returns (uint256);\n\n    /**\n     * @notice Get remaining supply cap in the protocol\n     * @return remainingSupplyCap\n     * @dev ignored on this version\n     * @dev should return 0 if the supply cap is exhausted\n     */\n    function getRemainingProtocolSupplyCap() public virtual view returns (uint256);\n\n    /**\n     * @notice Get remaining borrow cap in the protocol\n     * @return remainingBorrowCap\n     * @dev ignored on this version\n     * @dev should return 0 if the borrow cap is exhausted\n     */\n    function getRemainingProtocolBorrowCap() public virtual view returns (uint256);\n\n    /**\n     * @notice Colect rewards token from protocol\n     */\n    function collectHarvest() internal virtual {}\n}"
    },
    "contracts/citrus-vaults/src/mixins/SimpleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./Vault.sol\";\n\nabstract contract SimpleVault is Vault {\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) Vault(_asset, _name, _symbol) {}\n\n    /////  Vault hooks  /////\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) + getSuppliedToProtocol();\n    }\n\n    function onDeposit(uint256 assets) internal override {\n        supplyToProtocol(assets);\n    }\n\n    function onWithdraw(uint256 assets) internal override {\n        redeemFromProtocol(assets);\n    }\n\n    function onHarvest() internal override {\n        collectHarvest();\n    }\n\n    function afterHarvest() internal override {\n        uint256 assetBalance = asset.balanceOf(address(this));\n\n        if (assetBalance > 0) {\n            supplyToProtocol(assetBalance);\n        }\n    }\n\n    /////  Hooks  /////\n\n    /**\n     * @notice Get amount of assets supplied to the protocol by the vault\n     * @return Assets supplied\n     */\n    function getSuppliedToProtocol() public view virtual returns (uint256);\n\n    /**\n     * @notice Supply assets to protocol\n     * @param amount Assets to supply to the protocol\n     */\n    function supplyToProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Withdraw assets from protocol\n     * @param amount Assets to redeem from the protocol\n     */\n    function redeemFromProtocol(uint256 amount) internal virtual;\n\n    /**\n     * @notice Get remaining supply cap in the protocol\n     * @return remainingSupplyCap\n     * @dev ignored on this version\n     * @dev should return 0 if the supply cap is exhausted\n     */\n    function getRemainingProtocolSupplyCap()\n        public\n        view\n        virtual\n        returns (uint256);\n\n    /**\n     * @notice Colect rewards token from protocol\n     */\n    function collectHarvest() internal virtual {}\n}\n"
    },
    "contracts/citrus-vaults/src/mixins/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../../lib/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"../../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"../../lib/BoringSolidity/contracts/BoringOwnable.sol\";\n\nstruct HarvestCall {\n    address target;\n    bytes callData;\n}\n\nstruct Harvestable {\n    address token;\n    uint256 amount;\n}\n\nstruct HarvestCheckpoint {\n    // rolling block timestamp\n    uint32 blockTimestamp;\n\n    // rolling amount of assets per share\n    uint224 assetsPerShare;\n}\n\nabstract contract Vault is ERC4626, BoringOwnable {\n    using FixedPointMathLib for uint256;\n\n    event UpdateFeeExclusion(address user, bool excluded);\n    event UpdateAllowedHarvester(address target, bool allowed);\n    event Harvest(uint assetsPerShare, uint sharesToHarvester);\n    event UpdateWithdrawalFee(uint256 oldFee, uint256 newFee);\n    event UpdateHarvestFee(uint256 oldFee, uint256 newFee);\n\n    uint256 public constant MAX_WITHDRAWAL_FEE = 0.01e18; // 1%\n\n    // @notice The manager is allowed to perform some privileged actions on the vault, \n    address public manager;\n\n    // @notice This address receive all fees captured by this vault\n    address public feeTaker;\n\n    // @notice Percentage the user has to pay to withdraw. 1e18 is 100%\n    uint256 public withdrawalFee;\n\n    // @notice Harvesting generate . 1e18 is 100%\n    uint256 public harvestFee;\n\n    // @notice stores assetsPerShare evolution over time\n    // @dev used to calculate yield/apy\n    HarvestCheckpoint[] public harvestCheckpoints;\n\n    // @notice addresses that are excluded from fees\n    mapping(address => bool) public excludedFromFees;\n\n    // @notice address of contracts that could be called during harvest\n    mapping(address => bool) public allowedHarvesters;\n\n    // @notice array of contracts that could be called during harvest\n    // @dev only use this to check if a contract should be removed, some disabled harvesters can be in this array\n    address[] public _allHarvesters;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_asset, _name, _symbol) {\n        harvestCheckpoints.push(HarvestCheckpoint({\n            blockTimestamp: uint32(block.timestamp),\n            assetsPerShare: uint224(convertToAssets(10 ** decimals))\n        }));\n    }\n\n    /////  Harvest  /////\n\n    // modified version of: https://github.com/makerdao/multicall/blob/1e1b44362640820bef92d0ccf5eeee25d9b41474/src/Multicall.sol#L17-L25\n    // @dev The caller could steal the harvest but should not be able to steal any of the deposited funds.\n    // Stealing the harvest would result in bad PR and users withdrawing their funds without losing their principal.\n    function harvest(HarvestCall[] memory calls, uint256 amountOutMin) public virtual onlyManager returns (bytes[] memory returnData) {\n        uint256 balanceBefore = totalAssets();\n\n        onHarvest();\n\n        returnData = new bytes[](calls.length);\n        for(uint256 i = 0; i < calls.length; i++) {\n            require(allowedHarvesters[calls[i].target], \"harvestor not allowed\");\n\n            bool success;\n            bytes memory ret;\n\n            (success, ret) = calls[i].target.delegatecall(calls[i].callData);\n            \n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (ret.length < 68) revert();\n                assembly {\n                    ret := add(ret, 0x04)\n                }\n                revert(abi.decode(ret, (string)));\n            }\n\n            returnData[i] = ret;\n        }\n\n        uint256 balanceAfter = totalAssets();\n\n        require(balanceAfter >= balanceBefore, \"negative harvest\");\n        uint256 diffBalance;\n        unchecked {\n          diffBalance = balanceAfter - balanceBefore;\n        }\n\n        require(diffBalance >= amountOutMin, \"insufficient output amount\");\n\n        uint256 denom = balanceBefore + (diffBalance.mulDivUp(1e18 - harvestFee, 1e18));\n        uint256 harvesterShares = totalSupply.mulDivDown(balanceAfter, denom) - totalSupply;\n\n        _mint(feeTaker, harvesterShares);\n\n        uint256 assetsPerShare = convertToAssets(10 ** decimals);\n        harvestCheckpoints.push(HarvestCheckpoint({\n            blockTimestamp: uint32(block.timestamp),\n            assetsPerShare: uint224(assetsPerShare)\n        }));\n        emit Harvest(assetsPerShare, harvesterShares);\n\n        afterHarvest();\n    }\n\n    // @notice approve a contract to be used during harvesting\n    function allowHarvester(address target, bool allowed) public onlyOwner {\n        if (allowed) {\n            _allHarvesters.push(target);\n        }\n        allowedHarvesters[target] = allowed;\n        emit UpdateAllowedHarvester(target, allowed);\n    }\n\n    // @notive get array of all contracts ever allowed\n    // @dev could contains harvester that are now disabled\n    function allHarvesters() public view returns (address[] memory) {\n        return _allHarvesters;\n    }\n\n    /////  Checkpoints  /////\n\n    function harvestCheckpointsLength() public view returns (uint256) {\n        return harvestCheckpoints.length;\n    }\n\n    function invertedHarvestCheckpoints(uint256 index) public view returns (HarvestCheckpoint memory) {\n        return harvestCheckpoints[harvestCheckpoints.length - 1 - index];\n    }\n\n    function selectHarvestCheckpoints(uint256 start, uint256 end) public view returns (HarvestCheckpoint[] memory) {\n        uint256 length = end - start + 1;\n\n        HarvestCheckpoint[] memory arr = new HarvestCheckpoint[](length);\n        for (uint256 i = 0; i < length; i++) {\n            arr[i] = harvestCheckpoints[start + i];\n        }\n        return arr;\n    }\n\n    function selectInvertedHarvestCheckpoints(uint256 start, uint256 end) public view returns (HarvestCheckpoint[] memory) {\n        uint256 length = end - start + 1;\n        uint256 lastIndex = harvestCheckpoints.length - 1;\n\n        HarvestCheckpoint[] memory arr = new HarvestCheckpoint[](length);\n        for (uint256 i = 0; i < length; i++) {\n            arr[i] = harvestCheckpoints[lastIndex - i];\n        }\n        return arr;\n    }\n\n    function yield() public view virtual returns (uint256 diffTimestamp, int256 diffAssetsPerShare) {\n        uint lastHarvestCheckpointsIndex = harvestCheckpoints.length - 1;\n\n        if (lastHarvestCheckpointsIndex < 1) {\n            return (1 days, 0);\n        }\n\n        HarvestCheckpoint memory lastCheckpoint = harvestCheckpoints[lastHarvestCheckpointsIndex];\n        HarvestCheckpoint memory beforeLastCheckpoint = harvestCheckpoints[lastHarvestCheckpointsIndex - 1];\n\n        unchecked { // timestamp is allowed to overflow\n            diffTimestamp = lastCheckpoint.blockTimestamp - beforeLastCheckpoint.blockTimestamp;\n        }\n        diffAssetsPerShare = int256(((int224(lastCheckpoint.assetsPerShare) - int224(beforeLastCheckpoint.assetsPerShare)) * 1e18) / int224(beforeLastCheckpoint.assetsPerShare));\n    }\n\n    /////  Admin  /////\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n\n    /////  Fees  /////\n\n    function excludeFromFees(address user, bool exclude) public onlyOwner {\n        excludedFromFees[user] = exclude;\n        emit UpdateFeeExclusion(user, exclude);\n    }\n\n    function setFeeTaker(address _feeTaker) public onlyOwner {\n        feeTaker = _feeTaker;\n    }\n\n    function setWithdrawalFee(uint256 _withdrawalFee) public onlyOwner {\n        require(_withdrawalFee <= MAX_WITHDRAWAL_FEE, \"the withdrawal fee can be max 1%\");\n\n        uint256 oldFee = withdrawalFee;\n        withdrawalFee = _withdrawalFee;\n\n        emit UpdateWithdrawalFee(oldFee, _withdrawalFee);\n    }\n\n    function setHarvestFee(uint256 _harvestFee) public onlyOwner {\n        uint256 oldFee = harvestFee;\n        harvestFee = _harvestFee;\n\n        emit UpdateHarvestFee(oldFee, _harvestFee);\n    }\n\n    /////  ERC4626 hooks  /////\n\n    function afterDeposit(uint256 assets, uint256) internal override {\n        onDeposit(assets);\n    }\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n        if (withdrawalFee != 0 && !excludedFromFees[msg.sender]) {\n            _mint(feeTaker, shares.mulDivUp(withdrawalFee, 1e18));\n        }\n        onWithdraw(assets);\n    }\n\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        uint256 _withdrawalFee = withdrawalFee;\n\n        if (excludedFromFees[msg.sender]) {\n            _withdrawalFee = 0;\n        }\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        uint shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n        return shares.mulDivUp(1e18, 1e18 - _withdrawalFee);\n    }\n\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        uint256 _withdrawalFee = withdrawalFee;\n\n        if (excludedFromFees[msg.sender]) {\n            _withdrawalFee = 0;\n        }\n\n        return convertToAssets(shares).mulDivDown(1e18 - _withdrawalFee, 1e18);\n    }\n\n    ///// Modifiers  /////\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"Only manager is allowed to call\");\n        _;\n    }\n\n    modifier onlyManagerOrOwner() {\n        require(msg.sender == manager || msg.sender == owner, \"Only manager or Owner is allowed to call\");\n        _;\n    }\n\n    /////  Hooks  /////\n\n    function onDeposit(uint256 assets) internal virtual {}\n\n    function onWithdraw(uint256 assets) internal virtual {}\n\n    function onHarvest() internal virtual {}\n\n    function afterHarvest() internal virtual {}\n\n    function harvestable() public virtual view returns (Harvestable[] memory);\n}"
    },
    "contracts/citrus-vaults/src/utils/LogExpMath.sol": {
      "content": "// Copied from https://github.com/balancer-labs/balancer-v2-monorepo/blob/d2794ef7d8f6d321cde36b7c536e8d51971688bd/pkg/solidity-utils/contracts/math/LogExpMath.sol\n// Changes:\n// - solidity version: ^0.7.0 to >=0.8.0\n// - custom Balancer _require() to solidty require()\n\n// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the Software), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity >=0.8.0;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 27\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 26\n    int256 constant a1 = 6235149080811616882910000000; // e(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 25\n    int256 constant a2 = 7896296018268069516100000000000000; // e(x2)\n    int256 constant x3 = 1600000000000000000000; // 24\n    int256 constant a3 = 888611052050787263676000000; // e(x3)\n    int256 constant x4 = 800000000000000000000; // 23\n    int256 constant a4 = 298095798704172827474000; // e(x4)\n    int256 constant x5 = 400000000000000000000; // 22\n    int256 constant a5 = 5459815003314423907810; // e(x5)\n    int256 constant x6 = 200000000000000000000; // 21\n    int256 constant a6 = 738905609893065022723; // e(x6)\n    int256 constant x7 = 100000000000000000000; // 20\n    int256 constant a7 = 271828182845904523536; // e(x7)\n    int256 constant x8 = 50000000000000000000; // 2-1\n    int256 constant a8 = 164872127070012814685; // e(x8)\n    int256 constant x9 = 25000000000000000000; // 2-2\n    int256 constant a9 = 128402541668774148407; // e(x9)\n    int256 constant x10 = 12500000000000000000; // 2-3\n    int256 constant a10 = 113314845306682631683; // e(x10)\n    int256 constant x11 = 6250000000000000000; // 2-4\n    int256 constant a11 = 106449445891785942956; // e(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        require(x < 2**255, \"LogExpMath: X_OUT_OF_BOUNDS\");\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        require(y < MILD_EXPONENT_BOUND, \"LogExpMath: Y_OUT_OF_BOUNDS\");\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            \"LogExpMath: PRODUCT_OUT_OF_BOUNDS\"\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"LogExpMath: INVALID_EXPONENT\");\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        require(a > 0, \"LogExpMath: OUT_OF_BOUNDS\");\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}\n"
    },
    "contracts/citrus-vaults/src/VaultLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./mixins/Vault.sol\";\n\nimport \"./utils/LogExpMath.sol\";\n\ncontract VaultLens {\n    // @dev Instead of updating this, consider versioning it\n    struct StableVaultMetadataV1 {\n        address vault;\n        address asset;\n        int256 apy;\n        uint256 totalAssets;\n    }\n\n    struct VaultMetadata {\n        address vault;\n        address asset;\n        int256 apy;\n        uint8 decimals;\n        uint256 withdrawalFee;\n        uint256 harvestFee;\n        uint256 totalAssets;\n        Harvestable[] harvestable;\n    }\n\n    struct UserVaultMetadata {\n        address vault;\n        address asset;\n        int apy;\n        uint8 decimals;\n        uint256 withdrawalFee;\n        uint256 harvestFee;\n        uint balance;\n        uint assetBalance;\n    }\n\n    function getVaultMetadata(Vault vault) public view returns (VaultMetadata memory) {\n        uint8 decimals = vault.decimals();\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n        int256 apy = (int256(LogExpMath.pow(uint256(diffAssetsPerShare + 1e18), (365 days / diffTimestamp) * 1e18)) - 1e18) * 100;\n\n        return VaultMetadata({\n            vault: address(vault),\n            asset: address(vault.asset()),\n            apy: apy,\n            decimals: decimals,\n            withdrawalFee: vault.withdrawalFee(),\n            harvestFee: vault.harvestFee(),\n            totalAssets: vault.totalAssets(),\n            harvestable: vault.harvestable()\n        });\n    }\n\n    function getVaultMetadataV1(Vault vault) public view returns (StableVaultMetadataV1 memory) {\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n        int256 apy = (int256(LogExpMath.pow(uint256(diffAssetsPerShare + 1e18), (365 days / diffTimestamp) * 1e18)) - 1e18) * 100;\n\n        return StableVaultMetadataV1({\n            vault: address(vault),\n            asset: address(vault.asset()),\n            apy: apy,\n            totalAssets: vault.totalAssets()\n        });\n    }\n\n    function getVaultsMetadata(Vault[] calldata vaults) public view returns (VaultMetadata[] memory) {\n        VaultMetadata[] memory arr = new VaultMetadata[](vaults.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            arr[i] = getVaultMetadata(vaults[i]);\n        }\n        return arr;\n    }\n\n    function getUserVaultMetadata(address user, Vault vault) public view returns (UserVaultMetadata memory) {\n        uint8 decimals = vault.decimals();\n        uint balance = vault.convertToAssets(vault.balanceOf(user));\n        uint assetBalance = vault.asset().balanceOf(user);\n\n        (uint256 diffTimestamp, int256 diffAssetsPerShare) = vault.yield();\n        int256 apy = (int256(LogExpMath.pow(uint256(diffAssetsPerShare + 1e18), (365 days / diffTimestamp) * 1e18)) - 1e18) * 100;\n\n        return UserVaultMetadata({\n            vault: address(vault),\n            asset: address(vault.asset()),\n            apy: apy,\n            decimals: decimals,\n            withdrawalFee: vault.withdrawalFee(),\n            harvestFee: vault.harvestFee(),\n            balance: balance,\n            assetBalance: assetBalance\n        });\n    }\n\n    function getUserVaultsMetadata(address user, Vault[] calldata vaults) public view returns (UserVaultMetadata[] memory) {\n        UserVaultMetadata[] memory arr = new UserVaultMetadata[](vaults.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            arr[i] = getUserVaultMetadata(user, vaults[i]);\n        }\n        return arr;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
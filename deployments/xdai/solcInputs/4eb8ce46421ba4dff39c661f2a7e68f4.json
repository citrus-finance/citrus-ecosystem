{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/FuseFeeDistributorArbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../FuseFeeDistributor.sol\";\n\n/**\n * @title FuseFeeDistributorArbitrum\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseFeeDistributorArbitrum controls and receives protocol fees from Fuse pools and relays admin actions to Fuse pools on Arbitrum.\n */\ncontract FuseFeeDistributorArbitrum is FuseFeeDistributor {\n    /**\n     * @dev Deploys a `CEtherDelegator`.\n     * @param constructorData `CEtherDelegator` ABI-encoded constructor data.\n     */\n    function deployCEther(bytes calldata constructorData)\n        external\n        override\n        returns (address)\n    {\n        // ABI decode constructor data\n        (address comptroller, , , , address implementation, , , ) = abi.decode(\n            constructorData,\n            (address, address, string, string, address, bytes, uint256, uint256)\n        );\n\n        // Check implementation whitelist\n        require(\n            cEtherDelegateWhitelist[address(0)][implementation][false],\n            \"CEtherDelegate contract not whitelisted.\"\n        );\n\n        // Make sure comptroller == msg.sender\n        require(comptroller == msg.sender, \"Comptroller is not sender.\");\n\n        // Deploy Unitroller using msg.sender, underlying, and block.number as a salt\n        bytes\n            memory cEtherDelegatorCreationCode = hex\"608060405234801561001057600080fd5b50604051610785380380610785833981810160405261010081101561003457600080fd5b8151602083015160408085018051915193959294830192918464010000000082111561005f57600080fd5b90830190602082018581111561007457600080fd5b825164010000000081118282018810171561008e57600080fd5b82525081516020918201929091019080838360005b838110156100bb5781810151838201526020016100a3565b50505050905090810190601f1680156100e85780820380516001836020036101000a031916815260200191505b506040526020018051604051939291908464010000000082111561010b57600080fd5b90830190602082018581111561012057600080fd5b825164010000000081118282018810171561013a57600080fd5b82525081516020918201929091019080838360005b8381101561016757818101518382015260200161014f565b50505050905090810190601f1680156101945780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156101bc57600080fd5b9083019060208201858111156101d157600080fd5b82516401000000008111828201881017156101eb57600080fd5b82525081516020918201929091019080838360005b83811015610218578181015183820152602001610200565b50505050905090810190601f1680156102455780820380516001836020036101000a031916815260200191505b5060405260200180519060200190929190805190602001909291905050506103ba8489898989878760405160240180876001600160a01b03166001600160a01b03168152602001866001600160a01b03166001600160a01b031681526020018060200180602001858152602001848152602001838103835287818151815260200191508051906020019080838360005b838110156102ed5781810151838201526020016102d5565b50505050905090810190601f16801561031a5780820380516001836020036101000a031916815260200191505b50838103825286518152865160209182019188019080838360005b8381101561034d578181015183820152602001610335565b50505050905090810190601f16801561037a5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b03908116631e70b25560e21b1790915290995061049c16975050505050505050565b5061048e848560008660405160240180846001600160a01b03166001600160a01b031681526020018315151515815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561042557818101518382015260200161040d565b50505050905090810190601f1680156104525780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b039081166350d85b7360e01b1790915290955061049c169350505050565b50505050505050505061055e565b606060006060846001600160a01b0316846040518082805190602001908083835b602083106104dc5780518252601f1990920191602091820191016104bd565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461053c576040519150601f19603f3d011682016040523d82523d6000602084013e610541565b606091505b50915091506000821415610556573d60208201fd5b949350505050565b6102188061056d6000396000f3fe60806040526004361061001e5760003560e01c80635c60da1b146100e1575b6000546040805160048152602481019091526020810180516001600160e01b031663076de25160e21b17905261005d916001600160a01b031690610112565b50600080546040516001600160a01b0390911690829036908083838082843760405192019450600093509091505080830381855af49150503d80600081146100c1576040519150601f19603f3d011682016040523d82523d6000602084013e6100c6565b606091505b505090506040513d6000823e8180156100dd573d82f35b3d82fd5b3480156100ed57600080fd5b506100f66101d4565b604080516001600160a01b039092168252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b602083106101525780518252601f199092019160209182019101610133565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101b2576040519150601f19603f3d011682016040523d82523d6000602084013e6101b7565b606091505b509150915060008214156101cc573d60208201fd5b949350505050565b6000546001600160a01b03168156fea265627a7a7231582080d36dfc16f2b75d4da188aa983cd8c9d6d990a3dfadcda4c9afa32284ba80dc64736f6c63430005110032\";\n        cEtherDelegatorCreationCode = abi.encodePacked(\n            cEtherDelegatorCreationCode,\n            constructorData\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, address(0), block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(cEtherDelegatorCreationCode, 32),\n                mload(cEtherDelegatorCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"Failed to deploy CEther.\")\n            }\n        }\n\n        return proxy;\n    }\n\n    /**\n     * @dev Deploys a `CErc20Delegator`.\n     * @param constructorData `CErc20Delegator` ABI-encoded constructor data.\n     */\n    function deployCErc20(bytes calldata constructorData)\n        external\n        override\n        returns (address)\n    {\n        // ABI decode constructor data\n        (\n            address underlying,\n            address comptroller,\n            ,\n            ,\n            ,\n            address implementation,\n            ,\n            ,\n\n        ) = abi.decode(\n                constructorData,\n                (\n                    address,\n                    address,\n                    address,\n                    string,\n                    string,\n                    address,\n                    bytes,\n                    uint256,\n                    uint256\n                )\n            );\n\n        // Check implementation whitelist\n        require(\n            cErc20DelegateWhitelist[address(0)][implementation][false],\n            \"CErc20Delegate contract not whitelisted.\"\n        );\n\n        // Make sure comptroller == msg.sender\n        require(comptroller == msg.sender, \"Comptroller is not sender.\");\n\n        // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\n        bytes\n            memory cErc20DelegatorCreationCode = hex\"608060405234801561001057600080fd5b506040516107f53803806107f5833981810160405261012081101561003457600080fd5b81516020830151604080850151606086018051925194969395919493918201928464010000000082111561006757600080fd5b90830190602082018581111561007c57600080fd5b825164010000000081118282018810171561009657600080fd5b82525081516020918201929091019080838360005b838110156100c35781810151838201526020016100ab565b50505050905090810190601f1680156100f05780820380516001836020036101000a031916815260200191505b506040526020018051604051939291908464010000000082111561011357600080fd5b90830190602082018581111561012857600080fd5b825164010000000081118282018810171561014257600080fd5b82525081516020918201929091019080838360005b8381101561016f578181015183820152602001610157565b50505050905090810190601f16801561019c5780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156101c457600080fd5b9083019060208201858111156101d957600080fd5b82516401000000008111828201881017156101f357600080fd5b82525081516020918201929091019080838360005b83811015610220578181015183820152602001610208565b50505050905090810190601f16801561024d5780820380516001836020036101000a031916815260200191505b50604081815260208381015193909101516001600160a01b03808e1660248501908152818e166044860152908c16606485015260c4840185905260e4840182905260e0608485019081528b516101048601528b519597509195506103b59489948f948f948f948f948f948d948d949260a4830192610124019189019080838360005b838110156102e75781810151838201526020016102cf565b50505050905090810190601f1680156103145780820380516001836020036101000a031916815260200191505b50838103825286518152865160209182019188019080838360005b8381101561034757818101518382015260200161032f565b50505050905090810190601f1680156103745780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b0390811663a0b0d28960e01b17909152909a506104981698505050505050505050565b50610489848560008660405160240180846001600160a01b03166001600160a01b031681526020018315151515815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610420578181015183820152602001610408565b50505050905090810190601f16801561044d5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b039081166350d85b7360e01b17909152909550610498169350505050565b5050505050505050505061055a565b606060006060846001600160a01b0316846040518082805190602001908083835b602083106104d85780518252601f1990920191602091820191016104b9565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d8060008114610538576040519150601f19603f3d011682016040523d82523d6000602084013e61053d565b606091505b50915091506000821415610552573d60208201fd5b949350505050565b61028c806105696000396000f3fe60806040526004361061001e5760003560e01c80635c60da1b1461011e575b341561005b5760405162461bcd60e51b81526004018080602001828103825260378152602001806102216037913960400191505060405180910390fd5b6000546040805160048152602481019091526020810180516001600160e01b031663076de25160e21b17905261009a916001600160a01b03169061014f565b50600080546040516001600160a01b0390911690829036908083838082843760405192019450600093509091505080830381855af49150503d80600081146100fe576040519150601f19603f3d011682016040523d82523d6000602084013e610103565b606091505b505090506040513d6000823e81801561011a573d82f35b3d82fd5b34801561012a57600080fd5b50610133610211565b604080516001600160a01b039092168252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b6020831061018f5780518252601f199092019160209182019101610170565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101ef576040519150601f19603f3d011682016040523d82523d6000602084013e6101f4565b606091505b50915091506000821415610209573d60208201fd5b949350505050565b6000546001600160a01b03168156fe43457263323044656c656761746f723a66616c6c6261636b3a2063616e6e6f742073656e642076616c756520746f2066616c6c6261636ba265627a7a72315820fc5fcc16235ee4edd9b1c0ecaf05a926cd9474cdf4a7678b9c4f511421cf2ac364736f6c63430005110032\";\n        cErc20DelegatorCreationCode = abi.encodePacked(\n            cErc20DelegatorCreationCode,\n            constructorData\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, underlying, block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(cErc20DelegatorCreationCode, 32),\n                mload(cErc20DelegatorCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"Failed to deploy CErc20.\")\n            }\n        }\n\n        return proxy;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/FusePoolDirectoryArbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../FusePoolDirectory.sol\";\n\n/**\n * @title FusePoolDirectoryArbitrum\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolDirectoryArbitrum is a directory for Fuse interest rate pools on Arbitrum.\n */\ncontract FusePoolDirectoryArbitrum is FusePoolDirectory {\n    /**\n     * @dev Deploys a new Fuse pool and adds to the directory.\n     * @param name The name of the pool.\n     * @param implementation The Comptroller implementation contract address.\n     * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n     * @param closeFactor The pool's close factor (scaled by 1e18).\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n     * @param priceOracle The pool's PriceOracle contract address.\n     * @return The index of the registered Fuse pool and the Unitroller proxy address.\n     */\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external override returns (uint256, address) {\n        // Input validation\n        require(\n            implementation != address(0),\n            \"No Comptroller implementation contract address specified.\"\n        );\n        require(\n            priceOracle != address(0),\n            \"No PriceOracle contract address specified.\"\n        );\n\n        // Deploy Unitroller using msg.sender, name, and block.number as a salt\n        bytes\n            memory unitrollerCreationCode = hex\"60806040526001805460ff60a81b1960ff60a01b19909116600160a01b1716600160a81b17905534801561003257600080fd5b50600080546001600160a01b03191633179055610ae1806100546000396000f3fe6080604052600436106100a75760003560e01c8063bb82aa5e11610064578063bb82aa5e14610437578063c1e803341461044c578063dcfbc0c714610461578063e992a04114610476578063e9c714f2146104a9578063f851a440146104be576100a7565b80630225ab9d1461032b5780630a755ec21461036957806326782247146103925780632f1069ba146103c35780636f63af0b146103d8578063b71d1a0c14610404575b3330146102a85760408051600481526024810182526020810180516001600160e01b0316633757348b60e21b1781529151815160009360609330939092909182918083835b6020831061010b5780518252601f1990920191602091820191016100ec565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d806000811461016b576040519150601f19603f3d011682016040523d82523d6000602084013e610170565b606091505b5091509150600082156101975781806020019051602081101561019257600080fd5b505190505b80156102a4576002546040805163bbcdd6d360e01b81526001600160a01b03909216600483015251600091734afb2b3dc111d091ca6c46c024d1d2f17bf477e19163bbcdd6d391602480820192602092909190829003018186803b1580156101fe57600080fd5b505afa158015610212573d6000803e3d6000fd5b505050506040513d602081101561022857600080fd5b50516002549091506001600160a01b038083169116146102a257600280546001600160a01b038381166001600160a01b0319831617928390556040805192821680845293909116602083015280517fd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a9281900390910190a1505b505b5050505b6002546040516000916001600160a01b031690829036908083838082843760405192019450600093509091505080830381855af49150503d806000811461030b576040519150601f19603f3d011682016040523d82523d6000602084013e610310565b606091505b505090506040513d6000823e818015610327573d82f35b3d82fd5b34801561033757600080fd5b506103576004803603602081101561034e57600080fd5b503515156104d3565b60408051918252519081900360200190f35b34801561037557600080fd5b5061037e61056f565b604080519115158252519081900360200190f35b34801561039e57600080fd5b506103a761057f565b604080516001600160a01b039092168252519081900360200190f35b3480156103cf57600080fd5b5061037e61058e565b3480156103e457600080fd5b50610357600480360360208110156103fb57600080fd5b5035151561059e565b34801561041057600080fd5b506103576004803603602081101561042757600080fd5b50356001600160a01b031661063a565b34801561044357600080fd5b506103a76106bd565b34801561045857600080fd5b506103576106cc565b34801561046d57600080fd5b506103a76107c7565b34801561048257600080fd5b506103576004803603602081101561049957600080fd5b50356001600160a01b03166107d6565b3480156104b557600080fd5b506103576108f6565b3480156104ca57600080fd5b506103a76109dc565b60006104dd6109eb565b6104f4576104ed60016005610a46565b905061056a565b60015460ff600160a81b90910416151582151514156105145760006104ed565b60018054831515600160a81b810260ff60a81b199092169190911790915560408051918252517f10f9a0a95673b0837d1dce21fd3bffcb6d760435e9b5300b75a271182f75f8229181900360200190a160005b90505b919050565b600154600160a81b900460ff1681565b6001546001600160a01b031681565b600154600160a01b900460ff1681565b60006105a86109eb565b6105b8576104ed60016005610a46565b60015460ff600160a01b90910416151582151514156105d85760006104ed565b60018054831515600160a01b90810260ff60a01b199092169190911791829055604080519190920460ff161515815290517fabb56a15fd39488c914b324690b88f30d7daec63d2131ca0ef47e5739068c86e9181900360200190a16000610567565b60006106446109eb565b610654576104ed60016010610a46565b600180546001600160a01b038481166001600160a01b0319831681179093556040805191909216808252602082019390935281517fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a9929181900390910190a160005b9392505050565b6002546001600160a01b031681565b6003546000906001600160a01b0316331415806106f257506003546001600160a01b0316155b1561070957610702600180610a46565b90506107c4565b60028054600380546001600160a01b038082166001600160a01b031980861682179687905590921690925560408051938316808552949092166020840152815190927fd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a92908290030190a1600354604080516001600160a01b038085168252909216602083015280517fe945ccee5d701fc83f9b8aa8ca94ea4219ec1fcbd4f4cab4f0ea57c5c3e1d8159281900390910190a160005b925050505b90565b6003546001600160a01b031681565b60006107e06109eb565b6107f0576104ed60016012610a46565b60025460408051639d244f9f60e01b81526001600160a01b039283166004820152918416602483015251734afb2b3dc111d091ca6c46c024d1d2f17bf477e191639d244f9f916044808301926020929190829003018186803b15801561085557600080fd5b505afa158015610869573d6000803e3d6000fd5b505050506040513d602081101561087f57600080fd5b5051610891576104ed60016011610a46565b600380546001600160a01b038481166001600160a01b0319831617928390556040805192821680845293909116602083015280517fe945ccee5d701fc83f9b8aa8ca94ea4219ec1fcbd4f4cab4f0ea57c5c3e1d8159281900390910190a160006106b6565b6001546000906001600160a01b031633141580610911575033155b156109225761070260016000610a46565b60008054600180546001600160a01b038082166001600160a01b031980861682179687905590921690925560408051938316808552949092166020840152815190927ff9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc92908290030190a1600154604080516001600160a01b038085168252909216602083015280517fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a99281900390910190a160006107bf565b6000546001600160a01b031681565b600080546001600160a01b031633148015610a0f5750600154600160a81b900460ff165b80610a41575033734afb2b3dc111d091ca6c46c024d1d2f17bf477e1148015610a415750600154600160a01b900460ff165b905090565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa0836015811115610a7557fe5b83601b811115610a8157fe5b604080519283526020830191909152600082820152519081900360600190a18260158111156106b657fefea265627a7a72315820b43a56e6c98a4da586c0bea9fd7bf158b8665b39690ed8e5fa39d00c94c43f8364736f6c63430005110032\";\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, name, block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(unitrollerCreationCode, 32),\n                mload(unitrollerCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"Failed to deploy Unitroller.\")\n            }\n        }\n\n        // Setup Unitroller\n        Unitroller unitroller = Unitroller(proxy);\n        require(\n            unitroller._setPendingImplementation(implementation) == 0,\n            \"Failed to set pending implementation on Unitroller.\"\n        ); // Checks Comptroller implementation whitelist\n        Comptroller comptrollerImplementation = Comptroller(implementation);\n        comptrollerImplementation._become(unitroller);\n        Comptroller comptrollerProxy = Comptroller(proxy);\n\n        // Set pool parameters\n        require(\n            comptrollerProxy._setCloseFactor(closeFactor) == 0,\n            \"Failed to set pool close factor.\"\n        );\n        require(\n            comptrollerProxy._setLiquidationIncentive(liquidationIncentive) ==\n                0,\n            \"Failed to set pool liquidation incentive.\"\n        );\n        require(\n            comptrollerProxy._setPriceOracle(PriceOracle(priceOracle)) == 0,\n            \"Failed to set pool price oracle.\"\n        );\n\n        // Whitelist\n        if (enforceWhitelist)\n            require(\n                comptrollerProxy._setWhitelistEnforcement(true) == 0,\n                \"Failed to enforce supplier/borrower whitelist.\"\n            );\n\n        // Enable auto-implementation\n        require(\n            comptrollerProxy._toggleAutoImplementations(true) == 0,\n            \"Failed to enable pool auto implementations.\"\n        );\n\n        // Make msg.sender the admin\n        require(\n            unitroller._setPendingAdmin(msg.sender) == 0,\n            \"Failed to set pending admin on Unitroller.\"\n        );\n\n        // Register the pool with this FusePoolDirectory\n        return (_registerPool(name, proxy), proxy);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/FuseSafeLiquidatorArbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../FuseSafeLiquidator.sol\";\n\n/**\n * @title FuseSafeLiquidatorArbitrum\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseSafeLiquidatorArbitrum safely liquidates unhealthy borrowers (with flashloan support) on Arbitrum.\n * @dev Do not transfer ETH or tokens directly to this address. Only send ETH here when using a method, and only approve tokens for transfer to here when using a method. Direct ETH transfers will be rejected and direct token transfers will be lost.\n */\ncontract FuseSafeLiquidatorArbitrum is FuseSafeLiquidator {\n    /**\n     * @dev Constructor to set immutable variables.\n     */\n    constructor() public {\n        WETH_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n        WETH = IWETH(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n        UNISWAP_V2_ROUTER_02_ADDRESS = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506; // SushiSwap on Arbitrum\n        UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(\n            0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506\n        );\n        WETH_FLASHLOAN_BASE_TOKEN_1 = 0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A; // MIM on Arbitrum\n        WETH_FLASHLOAN_BASE_TOKEN_2 = 0x6C2C06790b3E3E3c38e12Ee22F8183b37a13EE55; // DPX on Arbitrum\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/oracles/ChainlinkPriceOracleV2Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"../../../external/chainlink/FlagsInterface.sol\";\n\nimport \"../../../oracles/ChainlinkPriceOracleV2.sol\";\n\n/**\n * @title ChainlinkPriceOracleV2Arbitrum\n * @notice Returns prices from Chainlink (checking Arbitrum Layer 2 Health Sequencer Flag).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV2Arbitrum is ChainlinkPriceOracleV2 {\n    /**\n     * @dev Identifier of the Sequencer offline flag on the Flags contract.\n     */\n    address internal constant FLAG_ARBITRUM_SEQ_OFFLINE =\n        address(\n            bytes20(\n                bytes32(\n                    uint256(keccak256(\"chainlink.flags.arbitrum-seq-offline\")) -\n                        1\n                )\n            )\n        );\n\n    /**\n     * @dev Chainlink Flags contract.\n     */\n    FlagsInterface public constant CHAINLINK_FLAGS =\n        FlagsInterface(0x3C14e07Edd0dC67442FA96f1Ec6999c57E810a83);\n\n    /**\n     * @dev Constructor to set admin and canAdminOverwrite.\n     */\n    constructor(address _admin, bool _canAdminOverwrite)\n        public\n        ChainlinkPriceOracleV2(_admin, _canAdminOverwrite)\n    {\n        ETH_USD_PRICE_FEED = AggregatorV3Interface(\n            0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612\n        );\n        BTC_ETH_PRICE_FEED = AggregatorV3Interface(\n            0xc5a90A6d7e4Af242dA238FFe279e9f2BA0c64B2e\n        );\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        bool isRaised = CHAINLINK_FLAGS.getFlag(FLAG_ARBITRUM_SEQ_OFFLINE);\n        require(!isRaised, \"Arbitrum Chainlink feeds are not being updated.\");\n        return super._price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/oracles/EthRisePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../../external/compound/IPriceOracle.sol\";\nimport \"../../../external/compound/ICErc20.sol\";\n\nimport \"../../../external/risedle/IRiseTokenVault.sol\";\n\nimport \"../../../oracles/BasePriceOracle.sol\";\n\n/**\n * @title EthRisePriceOracle\n * @notice Returns prices for Risedle's ETHRISE token based on the getNAV() vault function.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author sri yantra <sriyantra@rari.capital> (https://github.com/sriyantra)\n */\ncontract EthRisePriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Risedle Vault\n     */\n    IRiseTokenVault public rVault =\n        IRiseTokenVault(0xf7EDB240DbF7BBED7D321776AFe87D1FBcFD0A94);\n\n    /**\n     * @notice ETHRISE address\n     */\n    address public ETHRISE = 0x46D06cf8052eA6FdbF71736AF33eD23686eA1452;\n\n    /**\n     * @notice USDC address\n     */\n    address public USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == ETHRISE,\n            \"Invalid token passed to RisedlePriceOracle.\"\n        );\n        return\n            rVault\n                .getNAV(ETHRISE)\n                .mul(BasePriceOracle(msg.sender).price(USDC))\n                .div(1e6); // 1e6 = USDC decimals as returned by getNAV()\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/oracles/GOhmPriceOracleArbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../../external/compound/IPriceOracle.sol\";\nimport \"../../../external/compound/ICErc20.sol\";\n\nimport \"../../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../../../oracles/BasePriceOracle.sol\";\n\n/**\n * @title GOhmPriceOracleArbitrum\n * @notice Returns prices for gOHM based on the OHM (v2) price and the gOHM index.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author Sri Yantra <sriyantra@rari.capital>, David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GOhmPriceOracleArbitrum is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice gOHM token address.\n     */\n    address public GOHM = 0x8D9bA570D6cb60C7e3e0F31343Efe75AB8E65FB1;\n\n    /**\n     * @notice OHM (v2) token address.\n     */\n    address public OHM = 0x6E6a3D8F1AfFAc703B1aEF1F43B8D2321bE40043;\n\n    /**\n     * @notice Chainlink OHM INDEX price feed contract.\n     */\n    AggregatorV3Interface public OHM_INDEX_PRICE_FEED =\n        AggregatorV3Interface(0x48C4721354A3B29D80EF03C65E6644A37338a0B1);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(GOHM),\n            \"Invalid token passed to GOhmPriceOracle.\"\n        );\n        (\n            uint80 roundId,\n            int256 ohmIndex,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = OHM_INDEX_PRICE_FEED.latestRoundData();\n        require(answeredInRound == roundId, \"Chainlink round timed out.\");\n        return\n            uint256(ohmIndex).mul(BasePriceOracle(msg.sender).price(OHM)).div(\n                1e9\n            ); // 1e9 = OHM base unit and therefore also gOHM/OHM index base unit\n    }\n}\n"
    },
    "contracts/rari-fuse/src/chains/arbitrum/oracles/TracerPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nimport \"../../../oracles/BasePriceOracle.sol\";\nimport \"../../../external/tracer/ILeveragedPool.sol\";\n\nimport \"../../../external/compound/IPriceOracle.sol\";\nimport \"../../../external/compound/ICErc20.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * Tracer Perpetual Pool oracle\n * @notice Returns prices for Tracer Pool short and long tokens\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author Sri Yantra <sriyantra@rari.capital>, David Lucid <david@rari.capital> (https://github.com/davidlucid), raymogg\n */\ncontract TracerPoolPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    mapping(address => address) tokenToPool;\n    mapping(address => address) poolToSettlementToken;\n\n    /**\n     * @dev The administrator of this oracle.\n     */\n    address public admin;\n\n    /**\n     * @dev Constructor to set admin\n     */\n    constructor(address _admin) public {\n        admin = _admin;\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    function _price(address underlying) internal view returns (uint256) {\n        // lookup address of perpetual pool\n        address pool = tokenToPool[underlying];\n        require(pool != address(0), \"Pool not found\");\n\n        ILeveragedPool _pool = ILeveragedPool(pool);\n        address[2] memory tokens = _pool.poolTokens();\n        uint256 issuedPoolTokens = ERC20Upgradeable(underlying).totalSupply();\n\n        // underlying MUST equal tokens[0] or [1] due to the pool == addr(0) check\n        // pool token price = collateral in pool / issued pool tokens\n        if (underlying == tokens[0]) {\n            // long token\n            uint256 lPrice = _pool\n                .longBalance()\n                .mul(10**uint256(ERC20Upgradeable(underlying).decimals()))\n                .div(issuedPoolTokens);\n            return\n                lPrice\n                    .mul(\n                        BasePriceOracle(msg.sender).price(\n                            poolToSettlementToken[pool]\n                        )\n                    )\n                    .div(10**uint256(ERC20Upgradeable(underlying).decimals()));\n        } else {\n            // short token\n            uint256 sPrice = _pool\n                .shortBalance()\n                .mul(10**uint256(ERC20Upgradeable(underlying).decimals()))\n                .div(issuedPoolTokens);\n            return\n                sPrice\n                    .mul(\n                        BasePriceOracle(msg.sender).price(\n                            poolToSettlementToken[pool]\n                        )\n                    )\n                    .div(10**uint256(ERC20Upgradeable(underlying).decimals()));\n        }\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice registers a Tracer Perpetual Pool with this oracle contract\n     * @param pool pool address, settlementToken address of settlement token in Bal pool\n     */\n    function addPool(address pool, address settlementToken) public onlyAdmin {\n        require(settlementToken != address(0), \"settlement token needed\");\n\n        ILeveragedPool _pool = ILeveragedPool(pool);\n        require(_pool.poolTokens()[0] != address(0), \"Pool not valid\");\n        address[2] memory tokens = _pool.poolTokens();\n\n        // register the short and long token for this pool\n        // long token\n        tokenToPool[tokens[0]] = pool;\n        // short token\n        tokenToPool[tokens[1]] = pool;\n        // settlement token\n        poolToSettlementToken[pool] = settlementToken;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/external/aave/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\npragma solidity 0.6.12;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n}\n"
    },
    "contracts/rari-fuse/src/external/abracadabra/sSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n// modified by BoringCrypto for DictatorDAO\ninterface sSpellV1 is IERC20Upgradeable {\n    function token() external view returns (IERC20Upgradeable);\n\n    function burn(address to, uint256 shares) external returns (bool);\n}\n"
    },
    "contracts/rari-fuse/src/external/alchemix/IgALCX.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IgALCX {\n    function stake(uint256 _amount) external;\n\n    function unstake(uint256 _amount) external;\n\n    function exchangeRate() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/alpha/Bank.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface Bank is IERC20Upgradeable {\n    /// @dev Return the total ETH entitled to the token holders. Be careful of unaccrued interests.\n    function totalETH() external view returns (uint256);\n\n    /// @dev Add more ETH to the bank. Hope to get some good returns.\n    function deposit() external payable;\n\n    /// @dev Withdraw ETH from the bank by burning the share tokens.\n    function withdraw(uint256 share) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/alpha/ISafeBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBox is IERC20Upgradeable {\n    function cToken() external view returns (address);\n\n    function uToken() external view returns (address);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/alpha/ISafeBoxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBoxETH is IERC20Upgradeable {\n    function cToken() external view returns (address);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/badger/DiggSett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"./Sett.sol\";\n\ninterface DiggSett is Sett {\n    function shares() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/badger/IDigg.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface IDigg {\n    /**\n     * @param shares Share value to convert.\n     * @return The current fragment value of the specified underlying share amount.\n     */\n    function sharesToFragments(uint256 shares) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/badger/IXToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface IXToken {\n    function pricePerShare() external view returns (uint256);\n\n    function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/badger/Sett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface Sett {\n    function totalSupply() external view returns (uint256);\n\n    function withdrawAll() external;\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\ncontract BConst {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/IBalancerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\ninterface IBalancerPool {\n    function getFinalTokens() external view returns (address[] memory);\n\n    function getNormalizedWeight(address token) external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getBalance(address token) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n        external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut);\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external;\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/IBalancerPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\n *\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\n * can be used to compare two different price sources, and choose the most liquid one.\n *\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\n * is not older than the largest safe query window.\n */\ninterface IBalancerPriceOracle {\n    function getPoolId() external view returns (bytes32);\n\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(Variable variable) external view returns (uint256);\n\n    /**\n     * @dev Information for a Time Weighted Average query.\n     *\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\n     */\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\n     * able to produce a result and not revert.\n     *\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\n     * value for 'safe' queries.\n     */\n    function getLargestSafeQueryWindow() external view returns (uint256);\n\n    /**\n     * @dev Returns the accumulators corresponding to each of `queries`.\n     */\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n        external\n        view\n        returns (int256[] memory results);\n\n    /**\n     * @dev Information for an Accumulator query.\n     *\n     * Each query estimates the accumulator at a time `ago` seconds ago.\n     */\n    struct OracleAccumulatorQuery {\n        Variable variable;\n        uint256 ago;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/IBalancerV2Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IBalancerV2Vault {\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n}\n"
    },
    "contracts/rari-fuse/src/external/balancer/IStablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\ninterface IStablePool {\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    event AnswerUpdated(\n        int256 indexed current,\n        uint256 indexed roundId,\n        uint256 updatedAt\n    );\n\n    event NewRound(\n        uint256 indexed roundId,\n        address indexed startedBy,\n        uint256 startedAt\n    );\n}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is\n    AggregatorInterface,\n    AggregatorV3Interface\n{}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nlibrary Denominations {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n    address public constant USD = address(840);\n    address public constant GBP = address(826);\n    address public constant EUR = address(978);\n    address public constant JPY = address(392);\n    address public constant KRW = address(410);\n    address public constant CNY = address(156);\n    address public constant AUD = address(36);\n    address public constant CAD = address(124);\n    address public constant CHF = address(756);\n    address public constant ARS = address(32);\n    address public constant PHP = address(608);\n    address public constant NZD = address(554);\n    address public constant SGD = address(702);\n    address public constant NGN = address(566);\n    address public constant ZAR = address(710);\n    address public constant RUB = address(643);\n    address public constant INR = address(356);\n    address public constant BRL = address(986);\n}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n    struct Phase {\n        uint16 phaseId;\n        uint80 startingAggregatorRoundId;\n        uint80 endingAggregatorRoundId;\n    }\n\n    event FeedProposed(\n        address indexed asset,\n        address indexed denomination,\n        address indexed proposedAggregator,\n        address currentAggregator,\n        address sender\n    );\n    event FeedConfirmed(\n        address indexed asset,\n        address indexed denomination,\n        address indexed latestAggregator,\n        address previousAggregator,\n        uint16 nextPhaseId,\n        address sender\n    );\n\n    // V3 AggregatorV3Interface\n\n    function decimals(address base, address quote)\n        external\n        view\n        returns (uint8);\n\n    function description(address base, address quote)\n        external\n        view\n        returns (string memory);\n\n    function version(address base, address quote)\n        external\n        view\n        returns (uint256);\n\n    function latestRoundData(address base, address quote)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function getRoundData(\n        address base,\n        address quote,\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    // V2 AggregatorInterface\n\n    function latestAnswer(address base, address quote)\n        external\n        view\n        returns (int256 answer);\n\n    function latestTimestamp(address base, address quote)\n        external\n        view\n        returns (uint256 timestamp);\n\n    function latestRound(address base, address quote)\n        external\n        view\n        returns (uint256 roundId);\n\n    function getAnswer(\n        address base,\n        address quote,\n        uint256 roundId\n    ) external view returns (int256 answer);\n\n    function getTimestamp(\n        address base,\n        address quote,\n        uint256 roundId\n    ) external view returns (uint256 timestamp);\n\n    // Registry getters\n\n    function getFeed(address base, address quote)\n        external\n        view\n        returns (AggregatorV2V3Interface aggregator);\n\n    function getPhaseFeed(\n        address base,\n        address quote,\n        uint16 phaseId\n    ) external view returns (AggregatorV2V3Interface aggregator);\n\n    function isFeedEnabled(address aggregator) external view returns (bool);\n\n    function getPhase(\n        address base,\n        address quote,\n        uint16 phaseId\n    ) external view returns (Phase memory phase);\n\n    // Round helpers\n\n    function getRoundFeed(\n        address base,\n        address quote,\n        uint80 roundId\n    ) external view returns (AggregatorV2V3Interface aggregator);\n\n    function getPhaseRange(\n        address base,\n        address quote,\n        uint16 phaseId\n    ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n    function getPreviousRoundId(\n        address base,\n        address quote,\n        uint80 roundId\n    ) external view returns (uint80 previousRoundId);\n\n    function getNextRoundId(\n        address base,\n        address quote,\n        uint80 roundId\n    ) external view returns (uint80 nextRoundId);\n\n    // Feed management\n\n    function proposeFeed(\n        address base,\n        address quote,\n        address aggregator\n    ) external;\n\n    function confirmFeed(\n        address base,\n        address quote,\n        address aggregator\n    ) external;\n\n    // Proposed aggregator\n\n    function getProposedFeed(address base, address quote)\n        external\n        view\n        returns (AggregatorV2V3Interface proposedAggregator);\n\n    function proposedGetRoundData(\n        address base,\n        address quote,\n        uint80 roundId\n    )\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function proposedLatestRoundData(address base, address quote)\n        external\n        view\n        returns (\n            uint80 id,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    // Phases\n    function getCurrentPhaseId(address base, address quote)\n        external\n        view\n        returns (uint16 currentPhaseId);\n}\n"
    },
    "contracts/rari-fuse/src/external/chainlink/FlagsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface FlagsInterface {\n    function getFlag(address) external view returns (bool);\n\n    function getFlags(address[] calldata) external view returns (bool[] memory);\n\n    function raiseFlag(address) external;\n\n    function raiseFlags(address[] calldata) external;\n\n    function lowerFlags(address[] calldata) external;\n\n    function setRaisingAccessController(address) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface CErc20 is CToken {\n    function underlying() external view returns (address);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CToken cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface CEther is CToken {\n    function liquidateBorrow(address borrower, CToken cTokenCollateral)\n        external\n        payable;\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./IPriceOracle.sol\";\nimport \"./ICToken.sol\";\nimport \"./IUnitroller.sol\";\nimport \"./IRewardsDistributor.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ninterface Comptroller {\n    function admin() external view returns (address);\n\n    function adminHasRights() external view returns (bool);\n\n    function fuseAdminHasRights() external view returns (bool);\n\n    function oracle() external view returns (PriceOracle);\n\n    function closeFactorMantissa() external view returns (uint256);\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function markets(address cToken) external view returns (bool, uint256);\n\n    function getAssetsIn(address account)\n        external\n        view\n        returns (CToken[] memory);\n\n    function checkMembership(address account, CToken cToken)\n        external\n        view\n        returns (bool);\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint256);\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa)\n        external\n        returns (uint256);\n\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\n        external\n        returns (uint256);\n\n    function _become(Unitroller unitroller) external;\n\n    function borrowGuardianPaused(address cToken) external view returns (bool);\n\n    function getRewardsDistributors()\n        external\n        view\n        returns (RewardsDistributor[] memory);\n\n    function getAllMarkets() external view returns (CToken[] memory);\n\n    function getAllBorrowers() external view returns (address[] memory);\n\n    function suppliers(address account) external view returns (bool);\n\n    function enforceWhitelist() external view returns (bool);\n\n    function whitelist(address account) external view returns (bool);\n\n    function _setWhitelistEnforcement(bool enforce) external returns (uint256);\n\n    function _setWhitelistStatuses(\n        address[] calldata _suppliers,\n        bool[] calldata statuses\n    ) external returns (uint256);\n\n    function _toggleAutoImplementations(bool enabled)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface CToken {\n    function admin() external view returns (address);\n\n    function adminHasRights() external view returns (bool);\n\n    function fuseAdminHasRights() external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function comptroller() external view returns (address);\n\n    function adminFeeMantissa() external view returns (uint256);\n\n    function fuseFeeMantissa() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function totalReserves() external view returns (uint256);\n\n    function totalAdminFees() external view returns (uint256);\n\n    function totalFuseFees() external view returns (uint256);\n\n    function isCToken() external view returns (bool);\n\n    function isCEther() external view returns (bool);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./ICToken.sol\";\n\ninterface PriceOracle {\n    /**\n     * @notice Get the underlying price of a cToken asset\n     * @param cToken The cToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n    function getUnderlyingPrice(CToken cToken) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title RewardsDistributor\n * @author Compound\n */\ninterface RewardsDistributor {\n    /// @dev The token to reward (i.e., COMP)\n    function rewardToken() external view returns (address);\n\n    /// @notice The portion of compRate that each market currently receives\n    function compSupplySpeeds(address) external view returns (uint256);\n\n    /// @notice The portion of compRate that each market currently receives\n    function compBorrowSpeeds(address) external view returns (uint256);\n\n    /// @notice The COMP accrued but not yet transferred to each user\n    function compAccrued(address) external view returns (uint256);\n\n    /**\n     * @notice Keeps the flywheel moving pre-mint and pre-redeem\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param supplier The minter/redeemer\n     */\n    function flywheelPreSupplierAction(address cToken, address supplier)\n        external;\n\n    /**\n     * @notice Keeps the flywheel moving pre-borrow and pre-repay\n     * @dev Called by the Comptroller\n     * @param cToken The relevant market\n     * @param borrower The borrower\n     */\n    function flywheelPreBorrowerAction(address cToken, address borrower)\n        external;\n\n    /**\n     * @notice Returns an array of all markets.\n     */\n    function getAllMarkets() external view returns (CToken[] memory);\n}\n"
    },
    "contracts/rari-fuse/src/external/compound/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ninterface Unitroller {\n    function _setPendingImplementation(address newPendingImplementation)\n        external\n        returns (uint256);\n\n    function _setPendingAdmin(address newPendingAdmin)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveFactoryRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n\n    function get_meta_n_coins(address pool)\n        external\n        view\n        returns (uint256, uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveLiquidityGaugeV2 {\n    function lp_token() external view returns (address);\n\n    function deposit(uint256 _value) external;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveMinter {\n    function get_virtual_price() external view returns (uint256);\n\n    function lp_price() external view returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveStableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ICurveStableSwap is IERC20Upgradeable {\n    function get_balances() external view returns (uint256[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveTriCryptoLpToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveTriCryptoLpToken {\n    function minter() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/curve/ICurveTriCryptoLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface ICurveTriCryptoLpTokenOracle {\n    function lp_price() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/floor/FloorStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface FloorStaking {\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function gFloor() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/floor/IgFloor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IgFloor {\n    function index() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/fodl/FodlStake.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract FodlStake is IERC20Upgradeable {\n    IERC20Upgradeable public fodlToken;\n\n    function stake(uint256 _amount) external virtual returns (uint256 shares);\n\n    function unstake(uint256 _share) external virtual returns (uint256 amount);\n}\n"
    },
    "contracts/rari-fuse/src/external/gelato/GUniPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\ninterface GUniPool {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    /// @notice compute total underlying holdings of the G-UNI token supply\n    /// includes current liquidity invested in uniswap position, current fees earned\n    /// and any uninvested leftover (but does not include manager or gelato fees accrued)\n    /// @return amount0Current current total underlying balance of token0\n    /// @return amount1Current current total underlying balance of token1\n    function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96)\n        external\n        view\n        returns (uint256 amount0Current, uint256 amount1Current);\n\n    /// @notice burn G-UNI tokens (fractional shares of a Uniswap V3 position) and receive tokens\n    /// @param burnAmount The number of G-UNI tokens to burn\n    /// @param receiver The account to receive the underlying amounts of token0 and token1\n    /// @return amount0 amount of token0 transferred to receiver for burning `burnAmount`\n    /// @return amount1 amount of token1 transferred to receiver for burning `burnAmount`\n    /// @return liquidityBurned amount of liquidity removed from the underlying Uniswap V3 position\n    // solhint-disable-next-line function-max-lines\n    function burn(uint256 burnAmount, address receiver)\n        external\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint128 liquidityBurned\n        );\n}\n"
    },
    "contracts/rari-fuse/src/external/harvest/IFarmVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface IFarmVault {\n    function underlyingBalanceInVault() external view returns (uint256);\n\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    function governance() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function underlying() external view returns (address);\n\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator)\n        external;\n\n    function deposit(uint256 amountWei) external;\n\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256 numberOfShares) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder)\n        external\n        view\n        returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n}\n"
    },
    "contracts/rari-fuse/src/external/inverse/Stabilizer.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\ninterface Stabilizer {\n    function buyFee() external view returns (uint256);\n\n    function synth() external view returns (address);\n\n    function reserve() external view returns (address);\n\n    function buy(uint256 amount) external;\n\n    function sell(uint256 amount) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/keep3r/Keep3rV1Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nabstract contract Keep3rV1Oracle {\n    struct Observation {\n        uint256 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    function factory() external pure virtual returns (address);\n\n    mapping(address => Observation[]) public observations;\n\n    function observationLength(address pair)\n        external\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/keep3r/Keep3rV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ncontract Keep3rV2Oracle {\n    struct Observation {\n        uint32 timestamp;\n        uint112 price0Cumulative;\n        uint112 price1Cumulative;\n    }\n\n    Observation[65535] public observations;\n    uint16 public length;\n}\n"
    },
    "contracts/rari-fuse/src/external/keep3r/Keep3rV2OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Keep3rV2Oracle.sol\";\n\ncontract Keep3rV2OracleFactory {\n    mapping(address => Keep3rV2Oracle) public feeds;\n}\n"
    },
    "contracts/rari-fuse/src/external/lido/IWstETH.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\npragma solidity 0.6.12;\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH {\n    function stETH() external view returns (address);\n\n    /**\n     * @notice Get amount of wstETH for a one stETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./MassetStructs.sol\";\n\n/**\n * @title IMasset\n * @dev   (Internal) Interface for interacting with Masset\n *        VERSION: 1.0\n *        DATE:    2020-05-05\n */\ninterface IMasset is MassetStructs {\n    // Mint\n    function mint(\n        address _input,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function mintMulti(\n        address[] calldata _inputs,\n        uint256[] calldata _inputQuantities,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function getMintOutput(address _input, uint256 _inputQuantity)\n        external\n        view\n        returns (uint256 mintOutput);\n\n    function getMintMultiOutput(\n        address[] calldata _inputs,\n        uint256[] calldata _inputQuantities\n    ) external view returns (uint256 mintOutput);\n\n    // Swaps\n    function swap(\n        address _input,\n        address _output,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 swapOutput);\n\n    function getSwapOutput(\n        address _input,\n        address _output,\n        uint256 _inputQuantity\n    ) external view returns (uint256 swapOutput);\n\n    // Redemption\n    function redeem(\n        address _output,\n        uint256 _mAssetQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 outputQuantity);\n\n    function redeemMasset(\n        uint256 _mAssetQuantity,\n        uint256[] calldata _minOutputQuantities,\n        address _recipient\n    ) external returns (uint256[] memory outputQuantities);\n\n    function redeemExactBassets(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities,\n        uint256 _maxMassetQuantity,\n        address _recipient\n    ) external returns (uint256 mAssetRedeemed);\n\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\n        external\n        view\n        returns (uint256 bAssetOutput);\n\n    function getRedeemExactBassetsOutput(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities\n    ) external view returns (uint256 mAssetAmount);\n\n    // Views\n    function getBasket() external view returns (bool, bool);\n\n    function getBasset(address _token)\n        external\n        view\n        returns (BassetPersonal memory personal, BassetData memory data);\n\n    function getBassets()\n        external\n        view\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n    function bAssetIndexes(address) external view returns (uint8);\n\n    // SavingsManager\n    function collectInterest()\n        external\n        returns (uint256 swapFeesGained, uint256 newSupply);\n\n    function collectPlatformInterest()\n        external\n        returns (uint256 mintAmount, uint256 newSupply);\n\n    // Admin\n    function setCacheSize(uint256 _cacheSize) external;\n\n    function upgradeForgeValidator(address _newForgeValidator) external;\n\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n    function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n    function migrateBassets(\n        address[] calldata _bAssets,\n        address _newIntegration\n    ) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.12;\n\n/**\n * @title ISavingsContractV2\n */\ninterface ISavingsContractV2 {\n    function redeemCredits(uint256 _amount)\n        external\n        returns (uint256 underlyingReturned); // V2\n\n    function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/rari-fuse/src/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.6.12;\n\ninterface MassetStructs {\n    struct BassetPersonal {\n        // Address of the bAsset\n        address addr;\n        // Address of the bAsset\n        address integrator;\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n        bool hasTxFee; // takes a byte in storage\n        // Status of the bAsset\n        BassetStatus status;\n    }\n\n    struct BassetData {\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n        uint128 ratio;\n        // Amount of the Basset that is held in Collateral\n        uint128 vaultBalance;\n    }\n\n    // Status of the Basset - has it broken its peg?\n    enum BassetStatus {\n        Default,\n        Normal,\n        BrokenBelowPeg,\n        BrokenAbovePeg,\n        Blacklisted,\n        Liquidating,\n        Liquidated,\n        Failed\n    }\n\n    struct BasketState {\n        bool undergoingRecol;\n        bool failed;\n    }\n\n    struct InvariantConfig {\n        uint256 a;\n        WeightLimits limits;\n    }\n\n    struct WeightLimits {\n        uint128 min;\n        uint128 max;\n    }\n\n    struct AmpData {\n        uint64 initialA;\n        uint64 targetA;\n        uint64 rampStartTime;\n        uint64 rampEndTime;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/external/nftx/INFTXInventoryStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface INFTXInventoryStaking {\n    function xTokenShareValue(uint256 vaultId) external view returns (uint256);\n\n    function withdraw(uint256 vaultId, uint256 _share) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/nftx/INFTXVaultUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface INFTXVaultUpgradeable {\n    function vaultId() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/nftx/IXTokenUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IXTokenUpgradeable {\n    function baseToken() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/olympus/IgOHM.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IgOHM {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function index() external view returns (uint256);\n\n    function balanceFrom(uint256 _amount) external view returns (uint256);\n\n    function balanceTo(uint256 _amount) external view returns (uint256);\n\n    function migrate(address _staking, address _sOHM) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/olympus/OlympusStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\nabstract contract OlympusStaking {\n    address public OHM;\n\n    function unstake(uint256 _amount, bool _trigger) external virtual;\n}\n"
    },
    "contracts/rari-fuse/src/external/olympus/OlympusV2Staking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\nabstract contract OlympusV2Staking {\n    address public OHM;\n\n    /**\n     * @notice redeem sOHM for OHMs\n     * @param _to address\n     * @param _amount uint\n     * @param _trigger bool\n     * @param _rebasing bool\n     * @return amount_ uint\n     */\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external virtual returns (uint256 amount_);\n}\n"
    },
    "contracts/rari-fuse/src/external/olympus/sOlympus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\nabstract contract sOlympus {\n    address public stakingContract;\n\n    function index() public view virtual returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/pooltogether/ControlledTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\n/// @title Controlled ERC20 Token\n/// @notice ERC20 Tokens with a controller for minting & burning\ninterface ControlledTokenInterface {\n    /// @notice Interface to the contract responsible for controlling mint/burn\n    function controller() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/pooltogether/PrizePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\ninterface PrizePoolInterface {\n    /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n    /// @param from The address to redeem tokens from.\n    /// @param amount The amount of tokens to redeem for assets.\n    /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n    /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n    /// @return The actual exit fee paid\n    function withdrawInstantlyFrom(\n        address from,\n        uint256 amount,\n        address controlledToken,\n        uint256 maximumExitFee\n    ) external returns (uint256);\n\n    /// @dev Returns the address of the underlying ERC20 asset\n    /// @return The address of the asset\n    function token() external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/rari/IUniswapV3Twap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\ninterface IUniswapV3Twap {\n    function price(address underlying) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/redacted/wxBTRFLY.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nabstract contract wxBTRFLY {\n    function realIndex() public view virtual returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/risedle/IRiseTokenVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\ninterface IRiseTokenVault {\n    function getNAV(address token) external view returns (uint256);\n\n    function removeSupply(uint256 amount) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/rocket/IrETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IrETH {\n    function getExchangeRate() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/saddle/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ISwap {\n    function getVirtualPrice() external view returns (uint256);\n\n    function getToken(uint8) external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/stakedao/Sanctuary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract Sanctuary is IERC20Upgradeable {\n    IERC20Upgradeable public sdt;\n\n    // Enter the Sanctuary. Pay some SDTs. Earn some shares.\n    function enter(uint256 _amount) public virtual;\n\n    // Leave the Sanctuary. Claim back your SDTs.\n    function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/rari-fuse/src/external/sushi/SushiBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract SushiBar is IERC20Upgradeable {\n    IERC20Upgradeable public sushi;\n\n    // Enter the bar. Pay some SUSHIs. Earn some shares.\n    function enter(uint256 _amount) public virtual;\n\n    // Leave the bar. Claim back your SUSHIs.\n    function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface AddressResolver {\n    function requireAndGetAddress(bytes32 name, string calldata reason)\n        external\n        view\n        returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/ExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ExchangeRates {\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint256 value);\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/ISynth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ISynth {\n    function currencyKey() external view returns (bytes32);\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ISynthetix {\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived);\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/MixinResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./AddressResolver.sol\";\n\ncontract MixinResolver {\n    AddressResolver public resolver;\n}\n"
    },
    "contracts/rari-fuse/src/external/synthetix/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ncontract Proxy {\n    address public target;\n}\n"
    },
    "contracts/rari-fuse/src/external/temple/ITempleTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ITempleTreasury {\n    function intrinsicValueRatio() external view returns (uint256, uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/tokemak/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Interface for Pool\n/// @notice Allows users to deposit ERC-20 tokens to be deployed to market makers.\n/// @notice Mints 1:1 fToken on deposit, represeting an IOU for the undelrying token that is freely transferable.\n/// @notice Holders of fTokens earn rewards based on duration their tokens were deployed and the demand for that asset.\n/// @notice Holders of fTokens can redeem for underlying asset after issuing requestWithdrawal and waiting for the next cycle.\ninterface ILiquidityPool {\n    /// @return Reference to the underlying ERC-20 contract\n    function underlyer() external view returns (ERC20Upgradeable);\n}\n"
    },
    "contracts/rari-fuse/src/external/tracer/ILeveragedPool.sol": {
      "content": "//SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity ^0.6.12;\n\n/// @title The pool controller contract interface\ninterface ILeveragedPool {\n    // Initialisation parameters for new market\n    struct Initialization {\n        address _owner; // Owner of the contract\n        address _keeper; // The address of the PoolKeeper contract\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\n        address _longToken; // Address of the long pool token\n        address _shortToken; // Address of the short pool token\n        address _poolCommitter; // Address of the PoolCommitter contract\n        address _invariantCheckContract; // Address of the PoolCommitter contract\n        string _poolName; // The pool identification name\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\n        address _feeAddress; // The address that the fund movement fee is sent to\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\n        address _quoteToken; //  The digital asset that the pool accepts. Must have a decimals() function\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\n    }\n\n    // #### Events\n    /**\n     * @notice Creates a notification when the pool is setup and ready for use\n     * @param longToken The address of the LONG pair token\n     * @param shortToken The address of the SHORT pair token\n     * @param quoteToken The address of the digital asset that the pool accepts\n     * @param poolName The pool code for the pool\n     */\n    event PoolInitialized(\n        address indexed longToken,\n        address indexed shortToken,\n        address quoteToken,\n        string poolName\n    );\n\n    /**\n     * @notice Creates a notification when the pool is rebalanced\n     * @param shortBalanceChange The change of funds in the short side\n     * @param longBalanceChange The change of funds in the long side\n     * @param shortFeeAmount Proportional fee taken from short side\n     * @param longFeeAmount Proportional fee taken from long side\n     */\n    event PoolRebalance(\n        int256 shortBalanceChange,\n        int256 longBalanceChange,\n        uint256 shortFeeAmount,\n        uint256 longFeeAmount\n    );\n\n    /**\n     * @notice Creates a notification when the pool's price execution fails\n     * @param startPrice Price prior to price change execution\n     * @param endPrice Price during price change execution\n     */\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\n\n    /**\n     * @notice Represents change in fee receiver's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event FeeAddressUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @notice Represents change in secondary fee receiver's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event SecondaryFeeAddressUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @notice Represents change in keeper's address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event KeeperAddressChanged(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    /**\n     * @notice Represents proposed change in governance address\n     * @param newAddress Proposed address\n     */\n    event ProvisionalGovernanceChanged(address indexed newAddress);\n\n    /**\n     * @notice Represents change in governance address\n     * @param oldAddress Previous address\n     * @param newAddress Address after change\n     */\n    event GovernanceAddressChanged(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    function leverageAmount() external view returns (bytes16);\n\n    function poolCommitter() external view returns (address);\n\n    function quoteToken() external view returns (address);\n\n    function oracleWrapper() external view returns (address);\n\n    function lastPriceTimestamp() external view returns (uint256);\n\n    function poolName() external view returns (string calldata);\n\n    function updateInterval() external view returns (uint32);\n\n    function shortBalance() external view returns (uint256);\n\n    function longBalance() external view returns (uint256);\n\n    function frontRunningInterval() external view returns (uint32);\n\n    function poolTokens() external view returns (address[2] memory);\n\n    function settlementEthOracle() external view returns (address);\n\n    // #### Functions\n    /**\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\n     * @param initialization The struct Initialization containing initialization data\n     */\n    function initialize(string calldata initialization) external;\n\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\n\n    function quoteTokenTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function payKeeperFromBalances(address to, uint256 amount)\n        external\n        returns (bool);\n\n    function quoteTokenTransfer(address to, uint256 amount) external;\n\n    function poolTokenTransfer(\n        bool isLongToken,\n        address to,\n        uint256 amount\n    ) external;\n\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance)\n        external;\n\n    /**\n     * @return _latestPrice The oracle price\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\n     * @return _updateInterval The update frequency for this pool\n     * @dev To save gas so PoolKeeper does not have to make three external calls\n     */\n    function getUpkeepInformation()\n        external\n        view\n        returns (\n            int256 _latestPrice,\n            bytes memory _data,\n            uint256 _lastPriceTimestamp,\n            uint256 _updateInterval\n        );\n\n    function getOraclePrice() external view returns (int256);\n\n    function intervalPassed() external view returns (bool);\n\n    function balances()\n        external\n        view\n        returns (uint256 _shortBalance, uint256 _longBalance);\n\n    function setKeeper(address _keeper) external;\n\n    function transferGovernance(address _governance) external;\n\n    function claimGovernance() external;\n\n    function updateFeeAddress(address account) external;\n\n    function updateSecondaryFeeAddress(address account) external;\n\n    function mintTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external;\n\n    function burnTokens(\n        bool isLongToken,\n        uint256 amount,\n        address burner\n    ) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV1Exchange {\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV1Factory {\n    function getExchange(address token) external view returns (address);\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/uniswap/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"./IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMathUpgradeable for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/external/volt/IVoltOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\ninterface IVoltOracle {\n    function currPegPrice() external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/external/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IVault {\n    function getPricePerFullShare() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _shares) external;\n}\n"
    },
    "contracts/rari-fuse/src/external/yearn/IVaultV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.6.12;\n\ninterface IVaultV2 {\n    function pricePerShare() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function deposit(uint256 _amount) external returns (uint256);\n\n    function withdraw(uint256 maxShares) external returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/FuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\n/**\n * @title FuseFeeDistributor\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseFeeDistributor controls and receives protocol fees from Fuse pools and relays admin actions to Fuse pools.\n */\ncontract FuseFeeDistributor is Initializable, OwnableUpgradeable {\n    using AddressUpgradeable for address;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Initializer that sets initial values of state variables.\n     * @param owner Default owner.\n     * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     * @param initialComptrollerImplementation The initial comptroller implementation\n     * @param initialCEtherDelegate The initial CEtherDelegate implementation\n     * @param initialCErc20Delegate The initial CErc20Delegate implementation\n     */\n    function initialize(\n        address owner,\n        uint256 _defaultInterestFeeRate,\n        address initialComptrollerImplementation,\n        address initialCEtherDelegate,\n        address initialCErc20Delegate\n    ) public initializer {\n        require(_defaultInterestFeeRate <= 1e18, \"!Interest fee\");\n        __Ownable_init();\n        transferOwnership(owner);\n        defaultInterestFeeRate = _defaultInterestFeeRate;\n        maxSupplyEth = uint256(-1);\n        maxUtilizationRate = uint256(-1);\n        comptrollerImplementationWhitelist[address(0)][\n            initialComptrollerImplementation\n        ] = true;\n        cEtherDelegateWhitelist[address(0)][initialCEtherDelegate][\n            false\n        ] = true;\n        cErc20DelegateWhitelist[address(0)][initialCErc20Delegate][\n            false\n        ] = true;\n    }\n\n    /**\n     * @notice The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    uint256 public defaultInterestFeeRate;\n\n    /**\n     * @dev Sets the default proportion of Fuse pool interest taken as a protocol fee.\n     * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function _setDefaultInterestFeeRate(uint256 _defaultInterestFeeRate)\n        external\n        onlyOwner\n    {\n        require(_defaultInterestFeeRate <= 1e18, \"!Interest fee\");\n        defaultInterestFeeRate = _defaultInterestFeeRate;\n    }\n\n    /**\n     * @dev Withdraws accrued fees on interest.\n     * @param erc20Contract The ERC20 token address to withdraw. Set to the zero address to withdraw ETH.\n     */\n    function _withdrawAssets(address erc20Contract) external {\n        if (erc20Contract == address(0)) {\n            uint256 balance = address(this).balance;\n            require(balance > 0, \"!balance\");\n            (bool success, ) = owner().call{value: balance}(\"\");\n            require(success, \"!transfer\");\n        } else {\n            IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n            uint256 balance = token.balanceOf(address(this));\n            require(balance > 0, \"!balance\");\n            token.safeTransfer(owner(), balance);\n        }\n    }\n\n    /**\n     * @dev Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n     */\n    uint256 public minBorrowEth;\n\n    /**\n     * @dev Maximum supply balance (in ETH) per user per Fuse pool asset.\n     * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n     */\n    uint256 public maxSupplyEth;\n\n    /**\n     * @dev Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n     * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n     */\n    uint256 public maxUtilizationRate;\n\n    /**\n     * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n     * @param _minBorrowEth Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n     * @param _maxSupplyEth Maximum supply balance (in ETH) per user per Fuse pool asset.\n     * @param _maxUtilizationRate Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n     */\n    function _setPoolLimits(\n        uint256 _minBorrowEth,\n        uint256 _maxSupplyEth,\n        uint256 _maxUtilizationRate\n    ) external onlyOwner {\n        minBorrowEth = _minBorrowEth;\n        maxSupplyEth = _maxSupplyEth;\n        maxUtilizationRate = _maxUtilizationRate;\n    }\n\n    /**\n     * @dev Globally pauses all borrowing. Accessible by guardian role.\n     */\n    function _pauseAllBorrowing() external onlyGuardian {\n        minBorrowEth = uint256(-1);\n    }\n\n    /**\n     * @dev Receives ETH fees.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Sends data to a contract.\n     * @param targets The contracts to which `data` will be sent.\n     * @param data The data to be sent to each of `targets`.\n     */\n    function _callPool(address[] calldata targets, bytes[] calldata data)\n        external\n        onlyOwner\n    {\n        require(\n            targets.length > 0 && targets.length == data.length,\n            \"!Array lengths\"\n        );\n        for (uint256 i = 0; i < targets.length; i++)\n            targets[i].functionCall(data[i]);\n    }\n\n    /**\n     * @dev Sends data to a contract.\n     * @param targets The contracts to which `data` will be sent.\n     * @param data The data to be sent to each of `targets`.\n     */\n    function _callPool(address[] calldata targets, bytes calldata data)\n        external\n        onlyOwner\n    {\n        require(targets.length > 0, \"!target addresses\");\n        for (uint256 i = 0; i < targets.length; i++)\n            targets[i].functionCall(data);\n    }\n\n    /**\n     * @dev Deploys a `CEtherDelegator`.\n     * @param constructorData `CEtherDelegator` ABI-encoded constructor data.\n     */\n    function deployCEther(bytes calldata constructorData)\n        external\n        virtual\n        returns (address)\n    {\n        // ABI decode constructor data\n        (address comptroller, , , , address implementation, , , ) = abi.decode(\n            constructorData,\n            (address, address, string, string, address, bytes, uint256, uint256)\n        );\n\n        // Check implementation whitelist\n        require(\n            cEtherDelegateWhitelist[address(0)][implementation][false],\n            \"!CEtherDelegate\"\n        );\n\n        // Make sure comptroller == msg.sender\n        require(comptroller == msg.sender, \"!Comptroller\");\n\n        // Deploy Unitroller using msg.sender, underlying, and block.number as a salt\n        // Steps to get bytecode: git checkout 4bd774d959513513a5fec5651fd814fae22f94e9 && make scripts-bytecodes\n        bytes\n            memory cEtherDelegatorCreationCode = hex\"608060405234801561001057600080fd5b50604051610785380380610785833981810160405261010081101561003457600080fd5b8151602083015160408085018051915193959294830192918464010000000082111561005f57600080fd5b90830190602082018581111561007457600080fd5b825164010000000081118282018810171561008e57600080fd5b82525081516020918201929091019080838360005b838110156100bb5781810151838201526020016100a3565b50505050905090810190601f1680156100e85780820380516001836020036101000a031916815260200191505b506040526020018051604051939291908464010000000082111561010b57600080fd5b90830190602082018581111561012057600080fd5b825164010000000081118282018810171561013a57600080fd5b82525081516020918201929091019080838360005b8381101561016757818101518382015260200161014f565b50505050905090810190601f1680156101945780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156101bc57600080fd5b9083019060208201858111156101d157600080fd5b82516401000000008111828201881017156101eb57600080fd5b82525081516020918201929091019080838360005b83811015610218578181015183820152602001610200565b50505050905090810190601f1680156102455780820380516001836020036101000a031916815260200191505b5060405260200180519060200190929190805190602001909291905050506103ba8489898989878760405160240180876001600160a01b03166001600160a01b03168152602001866001600160a01b03166001600160a01b031681526020018060200180602001858152602001848152602001838103835287818151815260200191508051906020019080838360005b838110156102ed5781810151838201526020016102d5565b50505050905090810190601f16801561031a5780820380516001836020036101000a031916815260200191505b50838103825286518152865160209182019188019080838360005b8381101561034d578181015183820152602001610335565b50505050905090810190601f16801561037a5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b03908116631e70b25560e21b1790915290995061049c16975050505050505050565b5061048e848560008660405160240180846001600160a01b03166001600160a01b031681526020018315151515815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561042557818101518382015260200161040d565b50505050905090810190601f1680156104525780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b039081166350d85b7360e01b1790915290955061049c169350505050565b50505050505050505061055e565b606060006060846001600160a01b0316846040518082805190602001908083835b602083106104dc5780518252601f1990920191602091820191016104bd565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461053c576040519150601f19603f3d011682016040523d82523d6000602084013e610541565b606091505b50915091506000821415610556573d60208201fd5b949350505050565b6102188061056d6000396000f3fe60806040526004361061001e5760003560e01c80635c60da1b146100e1575b6000546040805160048152602481019091526020810180516001600160e01b031663076de25160e21b17905261005d916001600160a01b031690610112565b50600080546040516001600160a01b0390911690829036908083838082843760405192019450600093509091505080830381855af49150503d80600081146100c1576040519150601f19603f3d011682016040523d82523d6000602084013e6100c6565b606091505b505090506040513d6000823e8180156100dd573d82f35b3d82fd5b3480156100ed57600080fd5b506100f66101d4565b604080516001600160a01b039092168252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b602083106101525780518252601f199092019160209182019101610133565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101b2576040519150601f19603f3d011682016040523d82523d6000602084013e6101b7565b606091505b509150915060008214156101cc573d60208201fd5b949350505050565b6000546001600160a01b03168156fea265627a7a7231582099cb628afa03dbc8f6a11f192f7b72ed7944736aab47f11754925fa6343e9c9864736f6c63430005110032\";\n        cEtherDelegatorCreationCode = abi.encodePacked(\n            cEtherDelegatorCreationCode,\n            constructorData\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, address(0), block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(cEtherDelegatorCreationCode, 32),\n                mload(cEtherDelegatorCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"!CEther.\")\n            }\n        }\n\n        return proxy;\n    }\n\n    /**\n     * @dev Deploys a `CErc20Delegator`.\n     * @param constructorData `CErc20Delegator` ABI-encoded constructor data.\n     */\n    function deployCErc20(bytes calldata constructorData)\n        external\n        virtual\n        returns (address)\n    {\n        // ABI decode constructor data\n        (\n            address underlying,\n            address comptroller,\n            ,\n            ,\n            ,\n            address implementation,\n            ,\n            ,\n\n        ) = abi.decode(\n                constructorData,\n                (\n                    address,\n                    address,\n                    address,\n                    string,\n                    string,\n                    address,\n                    bytes,\n                    uint256,\n                    uint256\n                )\n            );\n\n        // Check implementation whitelist\n        require(\n            cErc20DelegateWhitelist[address(0)][implementation][false],\n            \"!CErc20Delegate\"\n        );\n\n        // Make sure comptroller == msg.sender\n        require(comptroller == msg.sender, \"!Comptroller\");\n\n        // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\n        // Steps to get bytecode: git checkout 4bd774d959513513a5fec5651fd814fae22f94e9 && make scripts-bytecodes\n        bytes\n            memory cErc20DelegatorCreationCode = hex\"608060405234801561001057600080fd5b506040516107f53803806107f5833981810160405261012081101561003457600080fd5b81516020830151604080850151606086018051925194969395919493918201928464010000000082111561006757600080fd5b90830190602082018581111561007c57600080fd5b825164010000000081118282018810171561009657600080fd5b82525081516020918201929091019080838360005b838110156100c35781810151838201526020016100ab565b50505050905090810190601f1680156100f05780820380516001836020036101000a031916815260200191505b506040526020018051604051939291908464010000000082111561011357600080fd5b90830190602082018581111561012857600080fd5b825164010000000081118282018810171561014257600080fd5b82525081516020918201929091019080838360005b8381101561016f578181015183820152602001610157565b50505050905090810190601f16801561019c5780820380516001836020036101000a031916815260200191505b506040818152602083015192018051929491939192846401000000008211156101c457600080fd5b9083019060208201858111156101d957600080fd5b82516401000000008111828201881017156101f357600080fd5b82525081516020918201929091019080838360005b83811015610220578181015183820152602001610208565b50505050905090810190601f16801561024d5780820380516001836020036101000a031916815260200191505b50604081815260208381015193909101516001600160a01b03808e1660248501908152818e166044860152908c16606485015260c4840185905260e4840182905260e0608485019081528b516101048601528b519597509195506103b59489948f948f948f948f948f948d948d949260a4830192610124019189019080838360005b838110156102e75781810151838201526020016102cf565b50505050905090810190601f1680156103145780820380516001836020036101000a031916815260200191505b50838103825286518152865160209182019188019080838360005b8381101561034757818101518382015260200161032f565b50505050905090810190601f1680156103745780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b0390811663a0b0d28960e01b17909152909a506104981698505050505050505050565b50610489848560008660405160240180846001600160a01b03166001600160a01b031681526020018315151515815260200180602001828103825283818151815260200191508051906020019080838360005b83811015610420578181015183820152602001610408565b50505050905090810190601f16801561044d5780820380516001836020036101000a031916815260200191505b5060408051601f198184030181529190526020810180516001600160e01b039081166350d85b7360e01b17909152909550610498169350505050565b5050505050505050505061055a565b606060006060846001600160a01b0316846040518082805190602001908083835b602083106104d85780518252601f1990920191602091820191016104b9565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d8060008114610538576040519150601f19603f3d011682016040523d82523d6000602084013e61053d565b606091505b50915091506000821415610552573d60208201fd5b949350505050565b61028c806105696000396000f3fe60806040526004361061001e5760003560e01c80635c60da1b1461011e575b341561005b5760405162461bcd60e51b81526004018080602001828103825260378152602001806102216037913960400191505060405180910390fd5b6000546040805160048152602481019091526020810180516001600160e01b031663076de25160e21b17905261009a916001600160a01b03169061014f565b50600080546040516001600160a01b0390911690829036908083838082843760405192019450600093509091505080830381855af49150503d80600081146100fe576040519150601f19603f3d011682016040523d82523d6000602084013e610103565b606091505b505090506040513d6000823e81801561011a573d82f35b3d82fd5b34801561012a57600080fd5b50610133610211565b604080516001600160a01b039092168252519081900360200190f35b606060006060846001600160a01b0316846040518082805190602001908083835b6020831061018f5780518252601f199092019160209182019101610170565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d80600081146101ef576040519150601f19603f3d011682016040523d82523d6000602084013e6101f4565b606091505b50915091506000821415610209573d60208201fd5b949350505050565b6000546001600160a01b03168156fe43457263323044656c656761746f723a66616c6c6261636b3a2063616e6e6f742073656e642076616c756520746f2066616c6c6261636ba265627a7a72315820b5993ce32c06c76405b2f598c9dc406d72f2951447dd5a698c7f75652745767064736f6c63430005110032\";\n        cErc20DelegatorCreationCode = abi.encodePacked(\n            cErc20DelegatorCreationCode,\n            constructorData\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, underlying, block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(cErc20DelegatorCreationCode, 32),\n                mload(cErc20DelegatorCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"!CErc20\")\n            }\n        }\n\n        return proxy;\n    }\n\n    /**\n     * @dev Whitelisted Comptroller implementation contract addresses for each existing implementation.\n     */\n    mapping(address => mapping(address => bool))\n        public comptrollerImplementationWhitelist;\n\n    /**\n     * @dev Adds/removes Comptroller implementations to the whitelist.\n     * @param oldImplementations The old `Comptroller` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `Comptroller` implementations to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `implementations`.\n     */\n    function _editComptrollerImplementationWhitelist(\n        address[] calldata oldImplementations,\n        address[] calldata newImplementations,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        require(\n            newImplementations.length > 0 &&\n                newImplementations.length == oldImplementations.length &&\n                newImplementations.length == statuses.length,\n            \"No Comptroller implementations supplied or array lengths not equal.\"\n        );\n        for (uint256 i = 0; i < newImplementations.length; i++)\n            comptrollerImplementationWhitelist[oldImplementations[i]][\n                newImplementations[i]\n            ] = statuses[i];\n    }\n\n    /**\n     * @dev Whitelisted CErc20Delegate implementation contract addresses and `allowResign` values for each existing implementation.\n     */\n    mapping(address => mapping(address => mapping(bool => bool)))\n        public cErc20DelegateWhitelist;\n\n    /**\n     * @dev Adds/removes CErc20Delegate implementations to the whitelist.\n     * @param oldImplementations The old `CErc20Delegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `CErc20Delegate` implementations to be whitelisted/unwhitelisted.\n     * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n     */\n    function _editCErc20DelegateWhitelist(\n        address[] calldata oldImplementations,\n        address[] calldata newImplementations,\n        bool[] calldata allowResign,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        require(\n            newImplementations.length > 0 &&\n                newImplementations.length == oldImplementations.length &&\n                newImplementations.length == allowResign.length &&\n                newImplementations.length == statuses.length,\n            \"No CErc20Delegate implementations supplied or array lengths not equal.\"\n        );\n        for (uint256 i = 0; i < newImplementations.length; i++)\n            cErc20DelegateWhitelist[oldImplementations[i]][\n                newImplementations[i]\n            ][allowResign[i]] = statuses[i];\n    }\n\n    /**\n     * @dev Whitelisted CEtherDelegate implementation contract addresses and `allowResign` values for each existing implementation.\n     */\n    mapping(address => mapping(address => mapping(bool => bool)))\n        public cEtherDelegateWhitelist;\n\n    /**\n     * @dev Adds/removes CEtherDelegate implementations to the whitelist.\n     * @param oldImplementations The old `CEtherDelegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n     * @param newImplementations Array of `CEtherDelegate` implementations to be whitelisted/unwhitelisted.\n     * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n     * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n     */\n    function _editCEtherDelegateWhitelist(\n        address[] calldata oldImplementations,\n        address[] calldata newImplementations,\n        bool[] calldata allowResign,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        require(\n            newImplementations.length > 0 &&\n                newImplementations.length == oldImplementations.length &&\n                newImplementations.length == allowResign.length &&\n                newImplementations.length == statuses.length,\n            \"No CEtherDelegate implementations supplied or array lengths not equal.\"\n        );\n        for (uint256 i = 0; i < newImplementations.length; i++)\n            cEtherDelegateWhitelist[oldImplementations[i]][\n                newImplementations[i]\n            ][allowResign[i]] = statuses[i];\n    }\n\n    /**\n     * @dev Latest Comptroller implementation for each existing implementation.\n     */\n    mapping(address => address) internal _latestComptrollerImplementation;\n\n    /**\n     * @dev Latest Comptroller implementation for each existing implementation.\n     */\n    function latestComptrollerImplementation(address oldImplementation)\n        external\n        view\n        returns (address)\n    {\n        return\n            _latestComptrollerImplementation[oldImplementation] != address(0)\n                ? _latestComptrollerImplementation[oldImplementation]\n                : oldImplementation;\n    }\n\n    /**\n     * @dev Sets the latest `Comptroller` upgrade implementation address.\n     * @param oldImplementation The old `Comptroller` implementation address to upgrade from.\n     * @param newImplementation Latest `Comptroller` implementation address.\n     */\n    function _setLatestComptrollerImplementation(\n        address oldImplementation,\n        address newImplementation\n    ) external onlyOwner {\n        _latestComptrollerImplementation[oldImplementation] = newImplementation;\n    }\n\n    struct CDelegateUpgradeData {\n        address implementation;\n        bool allowResign;\n        bytes becomeImplementationData;\n    }\n\n    /**\n     * @dev Latest CErc20Delegate implementation for each existing implementation.\n     */\n    mapping(address => CDelegateUpgradeData) public _latestCErc20Delegate;\n\n    /**\n     * @dev Latest CEtherDelegate implementation for each existing implementation.\n     */\n    mapping(address => CDelegateUpgradeData) public _latestCEtherDelegate;\n\n    /**\n     * @dev Latest CErc20Delegate implementation for each existing implementation.\n     */\n    function latestCErc20Delegate(address oldImplementation)\n        external\n        view\n        returns (\n            address,\n            bool,\n            bytes memory\n        )\n    {\n        CDelegateUpgradeData memory data = _latestCErc20Delegate[\n            oldImplementation\n        ];\n        bytes memory emptyBytes;\n        return\n            data.implementation != address(0)\n                ? (\n                    data.implementation,\n                    data.allowResign,\n                    data.becomeImplementationData\n                )\n                : (oldImplementation, false, emptyBytes);\n    }\n\n    /**\n     * @dev Latest CEtherDelegate implementation for each existing implementation.\n     */\n    function latestCEtherDelegate(address oldImplementation)\n        external\n        view\n        returns (\n            address,\n            bool,\n            bytes memory\n        )\n    {\n        CDelegateUpgradeData memory data = _latestCEtherDelegate[\n            oldImplementation\n        ];\n        bytes memory emptyBytes;\n        return\n            data.implementation != address(0)\n                ? (\n                    data.implementation,\n                    data.allowResign,\n                    data.becomeImplementationData\n                )\n                : (oldImplementation, false, emptyBytes);\n    }\n\n    /**\n     * @dev Sets the latest `CEtherDelegate` upgrade implementation address and data.\n     * @param oldImplementation The old `CEtherDelegate` implementation address to upgrade from.\n     * @param newImplementation Latest `CEtherDelegate` implementation address.\n     * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n     * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n     */\n    function _setLatestCEtherDelegate(\n        address oldImplementation,\n        address newImplementation,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external onlyOwner {\n        _latestCEtherDelegate[oldImplementation] = CDelegateUpgradeData(\n            newImplementation,\n            allowResign,\n            becomeImplementationData\n        );\n    }\n\n    /**\n     * @dev Sets the latest `CErc20Delegate` upgrade implementation address and data.\n     * @param oldImplementation The old `CErc20Delegate` implementation address to upgrade from.\n     * @param newImplementation Latest `CErc20Delegate` implementation address.\n     * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n     * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n     */\n    function _setLatestCErc20Delegate(\n        address oldImplementation,\n        address newImplementation,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external onlyOwner {\n        _latestCErc20Delegate[oldImplementation] = CDelegateUpgradeData(\n            newImplementation,\n            allowResign,\n            becomeImplementationData\n        );\n    }\n\n    /**\n     * @notice Maps Unitroller (Comptroller proxy) addresses to the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     * @dev A value of 0 means unset whereas a negative value means 0.\n     */\n    mapping(address => int256) public customInterestFeeRates;\n\n    /**\n     * @notice Returns the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function interestFeeRate() external view returns (uint256) {\n        (bool success, bytes memory data) = msg.sender.staticcall(\n            abi.encodeWithSignature(\"comptroller()\")\n        );\n\n        if (success && data.length == 32) {\n            address comptroller = abi.decode(data, (address));\n            int256 customRate = customInterestFeeRates[comptroller];\n            if (customRate > 0) return uint256(customRate);\n            if (customRate < 0) return 0;\n        }\n\n        return defaultInterestFeeRate;\n    }\n\n    /**\n     * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n     * @param comptroller The Unitroller (Comptroller proxy) address.\n     * @param rate The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n     */\n    function _setCustomInterestFeeRate(address comptroller, int256 rate)\n        external\n        onlyOwner\n    {\n        require(rate <= 1e18, \"!Interest fee\");\n        customInterestFeeRates[comptroller] = rate;\n    }\n\n    /**\n     * @dev Maps underlying addresses to guardian role.\n     */\n    mapping(address => bool) public isGuardian;\n\n    /**\n     * @dev Changes guardian role mapping.\n     */\n    function _editGuardianWhitelist(\n        address[] calldata accounts,\n        bool[] calldata status\n    ) external onlyOwner {\n        require(\n            accounts.length > 0 && accounts.length == status.length,\n            \"!Array lengths\"\n        );\n        for (uint256 i = 0; i < accounts.length; i++)\n            isGuardian[accounts[i]] = status[i];\n    }\n\n    /**\n     * @dev Modifier that checks if msg.sender has guardian role.\n     */\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian.\");\n        _;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/FusePoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IUnitroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\n\n/**\n * @title FusePoolDirectory\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolDirectory is a directory for Fuse interest rate pools.\n */\ncontract FusePoolDirectory is OwnableUpgradeable {\n    /**\n     * @dev Initializes a deployer whitelist if desired.\n     * @param owner Default owner.\n     * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\n     * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\n     */\n    function initialize(\n        address owner,\n        bool _enforceDeployerWhitelist,\n        address[] memory _deployerWhitelist\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(owner);\n        enforceDeployerWhitelist = _enforceDeployerWhitelist;\n        for (uint256 i = 0; i < _deployerWhitelist.length; i++)\n            deployerWhitelist[_deployerWhitelist[i]] = true;\n    }\n\n    /**\n     * @dev Struct for a Fuse interest rate pool.\n     */\n    struct FusePool {\n        string name;\n        address creator;\n        address comptroller;\n        uint256 blockPosted;\n        uint256 timestampPosted;\n    }\n\n    /**\n     * @dev Array of Fuse interest rate pools.\n     */\n    FusePool[] public pools;\n\n    /**\n     * @dev Maps Ethereum accounts to arrays of Fuse pool indexes.\n     */\n    mapping(address => uint256[]) private _poolsByAccount;\n\n    /**\n     * @dev Maps Fuse pool Comptroller addresses to bools indicating if they have been registered via the directory.\n     */\n    mapping(address => bool) public poolExists;\n\n    /**\n     * @dev Emitted when a new Fuse pool is added to the directory.\n     */\n    event PoolRegistered(uint256 index, FusePool pool);\n\n    /**\n     * @dev Booleans indicating if the deployer whitelist is enforced.\n     */\n    bool public enforceDeployerWhitelist;\n\n    /**\n     * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\n     */\n    mapping(address => bool) public deployerWhitelist;\n\n    /**\n     * @dev Controls if the deployer whitelist is to be enforced.\n     * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\n     */\n    function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\n        enforceDeployerWhitelist = enforce;\n    }\n\n    /**\n     * @dev Adds/removes Ethereum accounts to the deployer whitelist.\n     * @param deployers Array of Ethereum accounts to be whitelisted.\n     * @param status Whether to add or remove the accounts.\n     */\n    function _editDeployerWhitelist(address[] calldata deployers, bool status)\n        external\n        onlyOwner\n    {\n        require(deployers.length > 0, \"No deployers supplied.\");\n        for (uint256 i = 0; i < deployers.length; i++)\n            deployerWhitelist[deployers[i]] = status;\n    }\n\n    /**\n     * @dev Adds a new Fuse pool to the directory (without checking msg.sender).\n     * @param name The name of the pool.\n     * @param comptroller The pool's Comptroller proxy contract address.\n     * @return The index of the registered Fuse pool.\n     */\n    function _registerPool(string memory name, address comptroller)\n        internal\n        returns (uint256)\n    {\n        require(\n            !poolExists[comptroller],\n            \"Pool already exists in the directory.\"\n        );\n        require(\n            !enforceDeployerWhitelist || deployerWhitelist[msg.sender],\n            \"Sender is not on deployer whitelist.\"\n        );\n        require(bytes(name).length <= 100, \"No pool name supplied.\");\n        FusePool memory pool = FusePool(\n            name,\n            msg.sender,\n            comptroller,\n            block.number,\n            block.timestamp\n        );\n        pools.push(pool);\n        _poolsByAccount[msg.sender].push(pools.length - 1);\n        poolExists[comptroller] = true;\n        emit PoolRegistered(pools.length - 1, pool);\n        return pools.length - 1;\n    }\n\n    /**\n     * @dev Deploys a new Fuse pool and adds to the directory.\n     * @param name The name of the pool.\n     * @param implementation The Comptroller implementation contract address.\n     * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n     * @param closeFactor The pool's close factor (scaled by 1e18).\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n     * @param priceOracle The pool's PriceOracle contract address.\n     * @return The index of the registered Fuse pool and the Unitroller proxy address.\n     */\n    function deployPool(\n        string memory name,\n        address implementation,\n        bool enforceWhitelist,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        address priceOracle\n    ) external virtual returns (uint256, address) {\n        // Input validation\n        require(\n            implementation != address(0),\n            \"No Comptroller implementation contract address specified.\"\n        );\n        require(\n            priceOracle != address(0),\n            \"No PriceOracle contract address specified.\"\n        );\n\n        // Deploy Unitroller using msg.sender, name, and block.number as a salt\n        // Steps to get bytecode: git checkout 4bd774d959513513a5fec5651fd814fae22f94e9 && make scripts-bytecodes\n        bytes\n            memory unitrollerCreationCode = hex\"60806040526002805460ff60a81b1960ff60a01b19909116600160a01b1716600160a81b17905534801561003257600080fd5b50600180546001600160a01b031990811633179091556000805490911672e4b82310d794f8312ddec83aa594545fa8d222179055610afc806100756000396000f3fe6080604052600436106100c25760003560e01c8063b71d1a0c1161007f578063dcfbc0c711610059578063dcfbc0c714610481578063e992a04114610496578063e9c714f2146104c9578063f851a440146104de576100c2565b8063b71d1a0c14610424578063bb82aa5e14610457578063c1e803341461046c576100c2565b80630225ab9d146103365780630a755ec21461037457806315761d511461039d57806326782247146103ce5780632f1069ba146103e35780636f63af0b146103f8575b3330146102b35760408051600481526024810182526020810180516001600160e01b0316633757348b60e21b1781529151815160009360609330939092909182918083835b602083106101265780518252601f199092019160209182019101610107565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d8060008114610186576040519150601f19603f3d011682016040523d82523d6000602084013e61018b565b606091505b5091509150600082156101b2578180602001905160208110156101ad57600080fd5b505190505b80156102af57600080546003546040805163bbcdd6d360e01b81526001600160a01b0392831660048201529051919092169163bbcdd6d3916024808301926020929190829003018186803b15801561020957600080fd5b505afa15801561021d573d6000803e3d6000fd5b505050506040513d602081101561023357600080fd5b50516003549091506001600160a01b038083169116146102ad57600380546001600160a01b038381166001600160a01b0319831617928390556040805192821680845293909116602083015280517fd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a9281900390910190a1505b505b5050505b6003546040516000916001600160a01b031690829036908083838082843760405192019450600093509091505080830381855af49150503d8060008114610316576040519150601f19603f3d011682016040523d82523d6000602084013e61031b565b606091505b505090506040513d6000823e818015610332573d82f35b3d82fd5b34801561034257600080fd5b506103626004803603602081101561035957600080fd5b503515156104f3565b60408051918252519081900360200190f35b34801561038057600080fd5b5061038961058f565b604080519115158252519081900360200190f35b3480156103a957600080fd5b506103b261059f565b604080516001600160a01b039092168252519081900360200190f35b3480156103da57600080fd5b506103b26105ae565b3480156103ef57600080fd5b506103896105bd565b34801561040457600080fd5b506103626004803603602081101561041b57600080fd5b503515156105cd565b34801561043057600080fd5b506103626004803603602081101561044757600080fd5b50356001600160a01b0316610669565b34801561046357600080fd5b506103b26106ec565b34801561047857600080fd5b506103626106fb565b34801561048d57600080fd5b506103b26107f6565b3480156104a257600080fd5b50610362600480360360208110156104b957600080fd5b50356001600160a01b0316610805565b3480156104d557600080fd5b50610362610918565b3480156104ea57600080fd5b506103b26109fe565b60006104fd610a0d565b6105145761050d60016005610a61565b905061058a565b60025460ff600160a81b909104161515821515141561053457600061050d565b60028054831515600160a81b810260ff60a81b199092169190911790915560408051918252517f10f9a0a95673b0837d1dce21fd3bffcb6d760435e9b5300b75a271182f75f8229181900360200190a160005b90505b919050565b600254600160a81b900460ff1681565b6000546001600160a01b031681565b6002546001600160a01b031681565b600254600160a01b900460ff1681565b60006105d7610a0d565b6105e75761050d60016005610a61565b60025460ff600160a01b909104161515821515141561060757600061050d565b60028054831515600160a01b90810260ff60a01b199092169190911791829055604080519190920460ff161515815290517fabb56a15fd39488c914b324690b88f30d7daec63d2131ca0ef47e5739068c86e9181900360200190a16000610587565b6000610673610a0d565b6106835761050d60016010610a61565b600280546001600160a01b038481166001600160a01b0319831681179093556040805191909216808252602082019390935281517fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a9929181900390910190a160005b9392505050565b6003546001600160a01b031681565b6004546000906001600160a01b03163314158061072157506004546001600160a01b0316155b1561073857610731600180610a61565b90506107f3565b60038054600480546001600160a01b038082166001600160a01b031980861682179687905590921690925560408051938316808552949092166020840152815190927fd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a92908290030190a1600454604080516001600160a01b038085168252909216602083015280517fe945ccee5d701fc83f9b8aa8ca94ea4219ec1fcbd4f4cab4f0ea57c5c3e1d8159281900390910190a160005b925050505b90565b6004546001600160a01b031681565b600061080f610a0d565b61081f5761050d60016012610a61565b60005460035460408051639d244f9f60e01b81526001600160a01b039283166004820152858316602482015290519190921691639d244f9f916044808301926020929190829003018186803b15801561087757600080fd5b505afa15801561088b573d6000803e3d6000fd5b505050506040513d60208110156108a157600080fd5b50516108b35761050d60016011610a61565b600480546001600160a01b038481166001600160a01b0319831617928390556040805192821680845293909116602083015280517fe945ccee5d701fc83f9b8aa8ca94ea4219ec1fcbd4f4cab4f0ea57c5c3e1d8159281900390910190a160006106e5565b6002546000906001600160a01b031633141580610933575033155b156109445761073160016000610a61565b60018054600280546001600160a01b038082166001600160a01b031980861682179687905590921690925560408051938316808552949092166020840152815190927ff9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc92908290030190a1600254604080516001600160a01b038085168252909216602083015280517fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a99281900390910190a160006107ee565b6001546001600160a01b031681565b6001546000906001600160a01b031633148015610a335750600254600160a81b900460ff165b80610a5c57506000546001600160a01b031633148015610a5c5750600254600160a01b900460ff165b905090565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa0836015811115610a9057fe5b83601b811115610a9c57fe5b604080519283526020830191909152600082820152519081900360600190a18260158111156106e557fefea265627a7a72315820183b9ef9af89f3cfde2ed17dadf7c10f53f06c6bbf7d34dc12f6f1ce1d5bf43764736f6c63430005110032\";\n        bytes32 salt = keccak256(\n            abi.encodePacked(msg.sender, name, block.number)\n        );\n        address proxy;\n\n        assembly {\n            proxy := create2(\n                0,\n                add(unitrollerCreationCode, 32),\n                mload(unitrollerCreationCode),\n                salt\n            )\n            if iszero(extcodesize(proxy)) {\n                revert(0, \"Failed to deploy Unitroller.\")\n            }\n        }\n\n        // Setup Unitroller\n        Unitroller unitroller = Unitroller(proxy);\n        require(\n            unitroller._setPendingImplementation(implementation) == 0,\n            \"Failed to set pending implementation on Unitroller.\"\n        ); // Checks Comptroller implementation whitelist\n        Comptroller comptrollerImplementation = Comptroller(implementation);\n        comptrollerImplementation._become(unitroller);\n        Comptroller comptrollerProxy = Comptroller(proxy);\n\n        // Set pool parameters\n        require(\n            comptrollerProxy._setCloseFactor(closeFactor) == 0,\n            \"Failed to set pool close factor.\"\n        );\n        require(\n            comptrollerProxy._setLiquidationIncentive(liquidationIncentive) ==\n                0,\n            \"Failed to set pool liquidation incentive.\"\n        );\n        require(\n            comptrollerProxy._setPriceOracle(PriceOracle(priceOracle)) == 0,\n            \"Failed to set pool price oracle.\"\n        );\n\n        // Whitelist\n        if (enforceWhitelist)\n            require(\n                comptrollerProxy._setWhitelistEnforcement(true) == 0,\n                \"Failed to enforce supplier/borrower whitelist.\"\n            );\n\n        // Enable auto-implementation\n        require(\n            comptrollerProxy._toggleAutoImplementations(true) == 0,\n            \"Failed to enable pool auto implementations.\"\n        );\n\n        // Make msg.sender the admin\n        require(\n            unitroller._setPendingAdmin(msg.sender) == 0,\n            \"Failed to set pending admin on Unitroller.\"\n        );\n\n        // Register the pool with this FusePoolDirectory\n        return (_registerPool(name, proxy), proxy);\n    }\n\n    /**\n     * @notice Returns arrays of all Fuse pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools() external view returns (FusePool[] memory) {\n        return pools;\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes and data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPublicPools()\n        external\n        view\n        returns (uint256[] memory, FusePool[] memory)\n    {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try Comptroller(pools[i].comptroller).enforceWhitelist() returns (\n                bool enforceWhitelist\n            ) {\n                if (enforceWhitelist) continue;\n            } catch {}\n\n            arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePool[] memory publicPools = new FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try Comptroller(pools[i].comptroller).enforceWhitelist() returns (\n                bool enforceWhitelist\n            ) {\n                if (enforceWhitelist) continue;\n            } catch {}\n\n            indexes[index] = i;\n            publicPools[index] = pools[i];\n            index++;\n        }\n\n        return (indexes, publicPools);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data created by `account`.\n     */\n    function getPoolsByAccount(address account)\n        external\n        view\n        returns (uint256[] memory, FusePool[] memory)\n    {\n        uint256[] memory indexes = new uint256[](\n            _poolsByAccount[account].length\n        );\n        FusePool[] memory accountPools = new FusePool[](\n            _poolsByAccount[account].length\n        );\n\n        for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\n            indexes[i] = _poolsByAccount[account][i];\n            accountPools[i] = pools[_poolsByAccount[account][i]];\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @dev Maps Ethereum accounts to arrays of Fuse pool Comptroller proxy contract addresses.\n     */\n    mapping(address => address[]) private _bookmarks;\n\n    /**\n     * @notice Returns arrays of Fuse pool Unitroller (Comptroller proxy) contract addresses bookmarked by `account`.\n     */\n    function getBookmarks(address account)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _bookmarks[account];\n    }\n\n    /**\n     * @notice Bookmarks a Fuse pool Unitroller (Comptroller proxy) contract addresses.\n     */\n    function bookmarkPool(address comptroller) external {\n        _bookmarks[msg.sender].push(comptroller);\n    }\n\n    /**\n     * @notice Modify existing Fuse pool name.\n     */\n    function setPoolName(uint256 index, string calldata name) external {\n        Comptroller _comptroller = Comptroller(pools[index].comptroller);\n\n        // Note: Compiler throws stack to deep if autoformatted with Prettier\n        // prettier-ignore\n        require(msg.sender == _comptroller.admin() && _comptroller.adminHasRights() || msg.sender == owner());\n\n        pools[index].name = name;\n    }\n\n    /**\n     * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\n     */\n    mapping(address => bool) public adminWhitelist;\n\n    /**\n     * @dev Event emitted when the admin whitelist is updated.\n     */\n    event AdminWhitelistUpdated(address[] admins, bool status);\n\n    /**\n     * @dev Adds/removes Ethereum accounts to the admin whitelist.\n     * @param admins Array of Ethereum accounts to be whitelisted.\n     * @param status Whether to add or remove the accounts.\n     */\n    function _editAdminWhitelist(address[] calldata admins, bool status)\n        external\n        onlyOwner\n    {\n        require(admins.length > 0, \"No admins supplied.\");\n        for (uint256 i = 0; i < admins.length; i++)\n            adminWhitelist[admins[i]] = status;\n        emit AdminWhitelistUpdated(admins, status);\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes and data with whitelisted admins.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPublicPoolsByVerification(bool whitelistedAdmin)\n        external\n        view\n        returns (uint256[] memory, FusePool[] memory)\n    {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n\n                try comptroller.admin() returns (address admin) {\n                    if (whitelistedAdmin != adminWhitelist[admin]) continue;\n                } catch {}\n            } catch {}\n\n            arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePool[] memory publicPools = new FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n                if (enforceWhitelist) continue;\n\n                try comptroller.admin() returns (address admin) {\n                    if (whitelistedAdmin != adminWhitelist[admin]) continue;\n                } catch {}\n            } catch {}\n\n            indexes[index] = i;\n            publicPools[index] = pools[i];\n            index++;\n        }\n\n        return (indexes, publicPools);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/FusePoolLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\nimport \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title FusePoolLens\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLens returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLens is Initializable {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Constructor to set the `FusePoolDirectory` contract object.\n     */\n    function initialize(FusePoolDirectory _directory) public initializer {\n        require(\n            address(_directory) != address(0),\n            \"FusePoolDirectory instance cannot be the zero address.\"\n        );\n        directory = _directory;\n    }\n\n    /**\n     * @notice `FusePoolDirectory` contract object.\n     */\n    FusePoolDirectory public directory;\n\n    /**\n     * @dev Struct for Fuse pool summary data.\n     */\n    struct FusePoolData {\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        address[] underlyingTokens;\n        string[] underlyingSymbols;\n        bool whitelistedAdmin;\n    }\n\n    /**\n     * @notice Returns arrays of all public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPublicPoolsWithData()\n        external\n        returns (\n            uint256[] memory,\n            FusePoolDirectory.FusePool[] memory,\n            FusePoolData[] memory,\n            bool[] memory\n        )\n    {\n        (\n            uint256[] memory indexes,\n            FusePoolDirectory.FusePool[] memory publicPools\n        ) = directory.getPublicPools();\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(\n            publicPools\n        );\n        return (indexes, publicPools, data, errored);\n    }\n\n    /**\n     * @notice Returns arrays of all whitelisted public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPublicPoolsByVerificationWithData(bool whitelistedAdmin)\n        external\n        returns (\n            uint256[] memory,\n            FusePoolDirectory.FusePool[] memory,\n            FusePoolData[] memory,\n            bool[] memory\n        )\n    {\n        (\n            uint256[] memory indexes,\n            FusePoolDirectory.FusePool[] memory publicPools\n        ) = directory.getPublicPoolsByVerification(whitelistedAdmin);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(\n            publicPools\n        );\n        return (indexes, publicPools, data, errored);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools created by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsByAccountWithData(address account)\n        external\n        returns (\n            uint256[] memory,\n            FusePoolDirectory.FusePool[] memory,\n            FusePoolData[] memory,\n            bool[] memory\n        )\n    {\n        (\n            uint256[] memory indexes,\n            FusePoolDirectory.FusePool[] memory accountPools\n        ) = directory.getPoolsByAccount(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(\n            accountPools\n        );\n        return (indexes, accountPools, data, errored);\n    }\n\n    /**\n     * @notice Internal function returning arrays of requested Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsData(FusePoolDirectory.FusePool[] memory pools)\n        internal\n        returns (FusePoolData[] memory, bool[] memory)\n    {\n        FusePoolData[] memory data = new FusePoolData[](pools.length);\n        bool[] memory errored = new bool[](pools.length);\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try this.getPoolSummary(Comptroller(pools[i].comptroller)) returns (\n                uint256 _totalSupply,\n                uint256 _totalBorrow,\n                address[] memory _underlyingTokens,\n                string[] memory _underlyingSymbols,\n                bool _whitelistedAdmin\n            ) {\n                data[i] = FusePoolData(\n                    _totalSupply,\n                    _totalBorrow,\n                    _underlyingTokens,\n                    _underlyingSymbols,\n                    _whitelistedAdmin\n                );\n            } catch {\n                errored[i] = true;\n            }\n        }\n\n        return (data, errored);\n    }\n\n    /**\n     * @notice Returns total supply balance (in ETH), total borrow balance (in ETH), underlying token addresses, and underlying token symbols of a Fuse pool.\n     */\n    function getPoolSummary(Comptroller comptroller)\n        external\n        returns (\n            uint256,\n            uint256,\n            address[] memory,\n            string[] memory,\n            bool\n        )\n    {\n        uint256 totalBorrow = 0;\n        uint256 totalSupply = 0;\n        CToken[] memory cTokens = comptroller.getAllMarkets();\n        address[] memory underlyingTokens = new address[](cTokens.length);\n        string[] memory underlyingSymbols = new string[](cTokens.length);\n        PriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            uint256 assetTotalBorrow = cToken.totalBorrowsCurrent();\n            uint256 assetTotalSupply = cToken\n                .getCash()\n                .add(assetTotalBorrow)\n                .sub(\n                    cToken.totalReserves().add(cToken.totalAdminFees()).add(\n                        cToken.totalFuseFees()\n                    )\n                );\n            uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n            totalBorrow = totalBorrow.add(\n                assetTotalBorrow.mul(underlyingPrice).div(1e18)\n            );\n            totalSupply = totalSupply.add(\n                assetTotalSupply.mul(underlyingPrice).div(1e18)\n            );\n\n            if (cToken.isCEther()) {\n                underlyingTokens[i] = address(0);\n                underlyingSymbols[i] = \"ETH\";\n            } else {\n                underlyingTokens[i] = CErc20(address(cToken)).underlying();\n                (, underlyingSymbols[i]) = getTokenNameAndSymbol(\n                    underlyingTokens[i]\n                );\n            }\n        }\n\n        bool whitelistedAdmin = directory.adminWhitelist(comptroller.admin());\n        return (\n            totalSupply,\n            totalBorrow,\n            underlyingTokens,\n            underlyingSymbols,\n            whitelistedAdmin\n        );\n    }\n\n    /**\n     * @dev Struct for a Fuse pool asset.\n     */\n    struct FusePoolAsset {\n        address cToken;\n        address underlyingToken;\n        string underlyingName;\n        string underlyingSymbol;\n        uint256 underlyingDecimals;\n        uint256 underlyingBalance;\n        uint256 supplyRatePerBlock;\n        uint256 borrowRatePerBlock;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 supplyBalance;\n        uint256 borrowBalance;\n        uint256 liquidity;\n        bool membership;\n        uint256 exchangeRate; // Price of cTokens in terms of underlying tokens\n        uint256 underlyingPrice; // Price of underlying tokens in ETH (scaled by 1e18)\n        address oracle;\n        uint256 collateralFactor;\n        uint256 reserveFactor;\n        uint256 adminFee;\n        uint256 fuseFee;\n        bool borrowGuardianPaused;\n    }\n\n    /**\n     * @notice Returns data on the specified assets of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract address of the Fuse pool.\n     * @param cTokens The cToken contract addresses of the assets to query.\n     * @param user The user for which to get account data.\n     * @return An array of Fuse pool assets.\n     */\n    function getPoolAssetsWithData(\n        Comptroller comptroller,\n        CToken[] memory cTokens,\n        address user\n    ) internal returns (FusePoolAsset[] memory) {\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            (bool isListed, ) = comptroller.markets(address(cTokens[i]));\n            if (isListed) arrayLength++;\n        }\n\n        FusePoolAsset[] memory detailedAssets = new FusePoolAsset[](\n            arrayLength\n        );\n        uint256 index = 0;\n        PriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            // Check if market is listed and get collateral factor\n            (bool isListed, uint256 collateralFactorMantissa) = comptroller\n                .markets(address(cTokens[i]));\n            if (!isListed) continue;\n\n            // Start adding data to FusePoolAsset\n            FusePoolAsset memory asset;\n            CToken cToken = cTokens[i];\n            asset.cToken = address(cToken);\n\n            // Get underlying asset data\n            if (cToken.isCEther()) {\n                asset.underlyingName = \"Ethereum\";\n                asset.underlyingSymbol = \"ETH\";\n                asset.underlyingDecimals = 18;\n                asset.underlyingBalance = user.balance;\n            } else {\n                asset.underlyingToken = CErc20(address(cToken)).underlying();\n                ERC20Upgradeable underlying = ERC20Upgradeable(\n                    asset.underlyingToken\n                );\n                (\n                    asset.underlyingName,\n                    asset.underlyingSymbol\n                ) = getTokenNameAndSymbol(asset.underlyingToken);\n                asset.underlyingDecimals = underlying.decimals();\n                asset.underlyingBalance = underlying.balanceOf(user);\n            }\n\n            // Get cToken data\n            asset.supplyRatePerBlock = cToken.supplyRatePerBlock();\n            asset.borrowRatePerBlock = cToken.borrowRatePerBlock();\n            asset.liquidity = cToken.getCash();\n            asset.totalBorrow = cToken.totalBorrowsCurrent();\n            asset.totalSupply = asset.liquidity.add(asset.totalBorrow).sub(\n                cToken.totalReserves().add(cToken.totalAdminFees()).add(\n                    cToken.totalFuseFees()\n                )\n            );\n            asset.supplyBalance = cToken.balanceOfUnderlying(user);\n            asset.borrowBalance = cToken.borrowBalanceStored(user); // We would use borrowBalanceCurrent but we already accrue interest above\n            asset.membership = comptroller.checkMembership(user, cToken);\n            asset.exchangeRate = cToken.exchangeRateStored(); // We would use exchangeRateCurrent but we already accrue interest above\n            asset.underlyingPrice = oracle.getUnderlyingPrice(cToken);\n\n            // Get oracle for this cToken\n            asset.oracle = address(oracle);\n\n            try\n                MasterPriceOracle(asset.oracle).oracles(asset.underlyingToken)\n            returns (PriceOracle _oracle) {\n                asset.oracle = address(_oracle);\n            } catch {}\n\n            // More cToken data\n            asset.collateralFactor = collateralFactorMantissa;\n            asset.reserveFactor = cToken.reserveFactorMantissa();\n            asset.adminFee = cToken.adminFeeMantissa();\n            asset.fuseFee = cToken.fuseFeeMantissa();\n            asset.borrowGuardianPaused = comptroller.borrowGuardianPaused(\n                address(cToken)\n            );\n\n            // Add to assets array and increment index\n            detailedAssets[index] = asset;\n            index++;\n        }\n\n        return (detailedAssets);\n    }\n\n    /**\n     * @notice Returns the `name` and `symbol` of `token`.\n     * Supports Uniswap V2 and SushiSwap LP tokens as well as MKR.\n     * @param token An ERC20 token contract object.\n     * @return The `name` and `symbol`.\n     */\n    function getTokenNameAndSymbol(address token)\n        internal\n        view\n        returns (string memory, string memory)\n    {\n        // MKR is a DSToken and uses bytes32\n        if (token == 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2)\n            return (\"Maker\", \"MKR\");\n        if (token == 0xB8c77482e45F1F44dE1745F52C74426C631bDD52)\n            return (\"BNB\", \"BNB\");\n\n        // Get name and symbol from token contract\n        ERC20Upgradeable tokenContract = ERC20Upgradeable(token);\n        string memory name = tokenContract.name();\n        string memory symbol = tokenContract.symbol();\n\n        // Check for Uniswap V2/SushiSwap pair\n        try IUniswapV2Pair(token).token0() returns (address _token0) {\n            bool isUniswapToken = keccak256(abi.encodePacked(name)) ==\n                keccak256(abi.encodePacked(\"Uniswap V2\")) &&\n                keccak256(abi.encodePacked(symbol)) ==\n                keccak256(abi.encodePacked(\"UNI-V2\"));\n            bool isSushiSwapToken = !isUniswapToken &&\n                keccak256(abi.encodePacked(name)) ==\n                keccak256(abi.encodePacked(\"SushiSwap LP Token\")) &&\n                keccak256(abi.encodePacked(symbol)) ==\n                keccak256(abi.encodePacked(\"SLP\"));\n\n            if (isUniswapToken || isSushiSwapToken) {\n                ERC20Upgradeable token0 = ERC20Upgradeable(_token0);\n                ERC20Upgradeable token1 = ERC20Upgradeable(\n                    IUniswapV2Pair(token).token1()\n                );\n                name = string(\n                    abi.encodePacked(\n                        isSushiSwapToken ? \"SushiSwap \" : \"Uniswap \",\n                        token0.symbol(),\n                        \"/\",\n                        token1.symbol(),\n                        \" LP\"\n                    )\n                );\n                symbol = string(\n                    abi.encodePacked(token0.symbol(), \"-\", token1.symbol())\n                );\n            }\n        } catch {}\n\n        return (name, symbol);\n    }\n\n    /**\n     * @notice Returns the assets of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract of the Fuse pool.\n     * @return An array of Fuse pool assets.\n     */\n    function getPoolAssetsWithData(Comptroller comptroller)\n        external\n        returns (FusePoolAsset[] memory)\n    {\n        return\n            getPoolAssetsWithData(\n                comptroller,\n                comptroller.getAllMarkets(),\n                msg.sender\n            );\n    }\n\n    /**\n     * @dev Struct for a Fuse pool user.\n     */\n    struct FusePoolUser {\n        address account;\n        uint256 totalBorrow;\n        uint256 totalCollateral;\n        uint256 health;\n        FusePoolAsset[] assets;\n    }\n\n    /**\n     * @notice Returns the borrowers of the specified Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptroller The Comptroller proxy contract of the Fuse pool.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of Fuse pool users, the pool's close factor, and the pool's liquidation incentive.\n     */\n    function getPoolUsersWithData(Comptroller comptroller, uint256 maxHealth)\n        external\n        returns (\n            FusePoolUser[] memory,\n            uint256,\n            uint256\n        )\n    {\n        address[] memory users = comptroller.getAllBorrowers();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            uint256 totalBorrow = 0;\n            uint256 totalCollateral = 0;\n            FusePoolAsset[] memory assets = getPoolAssetsWithData(\n                comptroller,\n                comptroller.getAssetsIn(users[i]),\n                users[i]\n            );\n\n            for (uint256 j = 0; j < assets.length; j++) {\n                totalBorrow = totalBorrow.add(\n                    assets[j].borrowBalance.mul(assets[j].underlyingPrice).div(\n                        1e18\n                    )\n                );\n                if (assets[j].membership)\n                    totalCollateral = totalCollateral.add(\n                        assets[j]\n                            .supplyBalance\n                            .mul(assets[j].underlyingPrice)\n                            .div(1e18)\n                            .mul(assets[j].collateralFactor)\n                            .div(1e18)\n                    );\n            }\n\n            uint256 health = totalBorrow > 0\n                ? totalCollateral.mul(1e18).div(totalBorrow)\n                : 1e36;\n            if (health <= maxHealth) arrayLength++;\n        }\n\n        FusePoolUser[] memory detailedUsers = new FusePoolUser[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            uint256 totalBorrow = 0;\n            uint256 totalCollateral = 0;\n            FusePoolAsset[] memory assets = getPoolAssetsWithData(\n                comptroller,\n                comptroller.getAssetsIn(users[i]),\n                users[i]\n            );\n\n            for (uint256 j = 0; j < assets.length; j++) {\n                totalBorrow = totalBorrow.add(\n                    assets[j].borrowBalance.mul(assets[j].underlyingPrice).div(\n                        1e18\n                    )\n                );\n                if (assets[j].membership)\n                    totalCollateral = totalCollateral.add(\n                        assets[j]\n                            .supplyBalance\n                            .mul(assets[j].underlyingPrice)\n                            .div(1e18)\n                            .mul(assets[j].collateralFactor)\n                            .div(1e18)\n                    );\n            }\n\n            uint256 health = totalBorrow > 0\n                ? totalCollateral.mul(1e18).div(totalBorrow)\n                : 1e36;\n            if (health > maxHealth) continue;\n            detailedUsers[index] = FusePoolUser(\n                users[i],\n                totalBorrow,\n                totalCollateral,\n                health,\n                assets\n            );\n            index++;\n        }\n\n        return (\n            detailedUsers,\n            comptroller.closeFactorMantissa(),\n            comptroller.liquidationIncentiveMantissa()\n        );\n    }\n\n    /**\n     * @notice Returns the users of each public Fuse pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of pools' Comptroller proxy addresses, an array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n     */\n    function getPublicPoolUsersWithData(uint256 maxHealth)\n        external\n        returns (\n            Comptroller[] memory,\n            FusePoolUser[][] memory,\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        // Get Comptroller addresses of all public pools\n        Comptroller[] memory comptrollers;\n\n        // Scope to avoid \"stack too deep\" error\n        {\n            (, FusePoolDirectory.FusePool[] memory publicPools) = directory\n                .getPublicPools();\n            comptrollers = new Comptroller[](publicPools.length);\n            for (uint256 i = 0; i < publicPools.length; i++)\n                comptrollers[i] = Comptroller(publicPools[i].comptroller);\n        }\n\n        // Get all public pools' data\n        (\n            FusePoolUser[][] memory users,\n            uint256[] memory closeFactors,\n            uint256[] memory liquidationIncentives,\n            bool[] memory errored\n        ) = getPoolUsersWithData(comptrollers, maxHealth);\n        return (\n            comptrollers,\n            users,\n            closeFactors,\n            liquidationIncentives,\n            errored\n        );\n    }\n\n    /**\n     * @notice Returns the users of the specified Fuse pools.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     * @param comptrollers The Comptroller proxy contracts of the Fuse pools.\n     * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n     * @return An array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n     */\n    function getPoolUsersWithData(\n        Comptroller[] memory comptrollers,\n        uint256 maxHealth\n    )\n        public\n        returns (\n            FusePoolUser[][] memory,\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        FusePoolUser[][] memory users = new FusePoolUser[][](\n            comptrollers.length\n        );\n        uint256[] memory closeFactors = new uint256[](comptrollers.length);\n        uint256[] memory liquidationIncentives = new uint256[](\n            comptrollers.length\n        );\n        bool[] memory errored = new bool[](comptrollers.length);\n\n        for (uint256 i = 0; i < comptrollers.length; i++) {\n            try\n                this.getPoolUsersWithData(\n                    Comptroller(comptrollers[i]),\n                    maxHealth\n                )\n            returns (\n                FusePoolUser[] memory _users,\n                uint256 closeFactor,\n                uint256 liquidationIncentive\n            ) {\n                users[i] = _users;\n                closeFactors[i] = closeFactor;\n                liquidationIncentives[i] = liquidationIncentive;\n            } catch {\n                errored[i] = true;\n            }\n        }\n\n        return (users, closeFactors, liquidationIncentives, errored);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data supplied to by `account`.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getPoolsBySupplier(address account)\n        public\n        view\n        returns (uint256[] memory, FusePoolDirectory.FusePool[] memory)\n    {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(account) returns (bool isSupplier) {\n                if (isSupplier) {\n                    CToken[] memory allMarkets = comptroller.getAllMarkets();\n\n                    for (uint256 j = 0; j < allMarkets.length; j++)\n                        if (allMarkets[j].balanceOf(account) > 0) {\n                            arrayLength++;\n                            break;\n                        }\n                }\n            } catch {}\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePoolDirectory.FusePool[]\n            memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(account) returns (bool isSupplier) {\n                if (isSupplier) {\n                    CToken[] memory allMarkets = comptroller.getAllMarkets();\n\n                    for (uint256 j = 0; j < allMarkets.length; j++)\n                        if (allMarkets[j].balanceOf(account) > 0) {\n                            indexes[index] = i;\n                            accountPools[index] = pools[i];\n                            index++;\n                            break;\n                        }\n                }\n            } catch {}\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools supplied to by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolsBySupplierWithData(address account)\n        external\n        returns (\n            uint256[] memory,\n            FusePoolDirectory.FusePool[] memory,\n            FusePoolData[] memory,\n            bool[] memory\n        )\n    {\n        (\n            uint256[] memory indexes,\n            FusePoolDirectory.FusePool[] memory accountPools\n        ) = getPoolsBySupplier(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(\n            accountPools\n        );\n        return (indexes, accountPools, data, errored);\n    }\n\n    /**\n     * @notice Returns the total supply balance (in ETH) and the total borrow balance (in ETH) of the caller across all pools.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getUserSummary(address account)\n        external\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 borrowBalance = 0;\n        uint256 supplyBalance = 0;\n        bool errors = false;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try\n                this.getPoolUserSummary(\n                    Comptroller(pools[i].comptroller),\n                    account\n                )\n            returns (uint256 poolSupplyBalance, uint256 poolBorrowBalance) {\n                supplyBalance = supplyBalance.add(poolSupplyBalance);\n                borrowBalance = borrowBalance.add(poolBorrowBalance);\n            } catch {\n                errors = true;\n            }\n        }\n\n        return (supplyBalance, borrowBalance, errors);\n    }\n\n    /**\n     * @notice Returns the total supply balance (in ETH) and the total borrow balance (in ETH) of the caller in the specified pool.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolUserSummary(Comptroller comptroller, address account)\n        external\n        returns (uint256, uint256)\n    {\n        uint256 borrowBalance = 0;\n        uint256 supplyBalance = 0;\n\n        if (!comptroller.suppliers(account)) return (0, 0);\n        CToken[] memory cTokens = comptroller.getAllMarkets();\n        PriceOracle oracle = comptroller.oracle();\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n            uint256 assetSupplyBalance = cToken.balanceOfUnderlying(account);\n            uint256 assetBorrowBalance = cToken.borrowBalanceStored(account); // We would use borrowBalanceCurrent but we already accrue interest above\n            uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n            borrowBalance = borrowBalance.add(\n                assetBorrowBalance.mul(underlyingPrice).div(1e18)\n            );\n            supplyBalance = supplyBalance.add(\n                assetSupplyBalance.mul(underlyingPrice).div(1e18)\n            );\n        }\n\n        return (supplyBalance, borrowBalance);\n    }\n\n    /**\n     * @notice Returns arrays of Fuse pool indexes and data with a whitelist containing `account`.\n     * Note that the whitelist does not have to be enforced.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getWhitelistedPoolsByAccount(address account)\n        public\n        view\n        returns (uint256[] memory, FusePoolDirectory.FusePool[] memory)\n    {\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            if (comptroller.whitelist(account)) arrayLength++;\n        }\n\n        uint256[] memory indexes = new uint256[](arrayLength);\n        FusePoolDirectory.FusePool[]\n            memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            if (comptroller.whitelist(account)) {\n                indexes[index] = i;\n                accountPools[index] = pools[i];\n                index++;\n                break;\n            }\n        }\n\n        return (indexes, accountPools);\n    }\n\n    /**\n     * @notice Returns arrays of the indexes of Fuse pools with a whitelist containing `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getWhitelistedPoolsByAccountWithData(address account)\n        external\n        returns (\n            uint256[] memory,\n            FusePoolDirectory.FusePool[] memory,\n            FusePoolData[] memory,\n            bool[] memory\n        )\n    {\n        (\n            uint256[] memory indexes,\n            FusePoolDirectory.FusePool[] memory accountPools\n        ) = getWhitelistedPoolsByAccount(account);\n        (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(\n            accountPools\n        );\n        return (indexes, accountPools, data, errored);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/FusePoolLensSecondary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\nimport \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title FusePoolLensSecondary\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLensSecondary returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLensSecondary is Initializable {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Constructor to set the `FusePoolDirectory` contract object.\n     */\n    function initialize(FusePoolDirectory _directory) public initializer {\n        require(\n            address(_directory) != address(0),\n            \"FusePoolDirectory instance cannot be the zero address.\"\n        );\n        directory = _directory;\n    }\n\n    /**\n     * @notice `FusePoolDirectory` contract object.\n     */\n    FusePoolDirectory public directory;\n\n    /**\n     * @notice Struct for ownership over a CToken.\n     */\n    struct CTokenOwnership {\n        address cToken;\n        address admin;\n        bool adminHasRights;\n        bool fuseAdminHasRights;\n    }\n\n    /**\n     * @notice Returns the admin, admin rights, Fuse admin (constant), Fuse admin rights, and an array of cTokens with differing properties.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n     */\n    function getPoolOwnership(Comptroller comptroller)\n        external\n        view\n        returns (\n            address,\n            bool,\n            bool,\n            CTokenOwnership[] memory\n        )\n    {\n        // Get pool ownership\n        address comptrollerAdmin = comptroller.admin();\n        bool comptrollerAdminHasRights = comptroller.adminHasRights();\n        bool comptrollerFuseAdminHasRights = comptroller.fuseAdminHasRights();\n\n        // Get cToken ownership\n        CToken[] memory cTokens = comptroller.getAllMarkets();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n\n            address cTokenAdmin;\n            try cToken.admin() returns (address _cTokenAdmin) {\n                cTokenAdmin = _cTokenAdmin;\n            } catch {\n                continue;\n            }\n            bool cTokenAdminHasRights = cToken.adminHasRights();\n            bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n            // If outlier, push to array\n            if (\n                cTokenAdmin != comptrollerAdmin ||\n                cTokenAdminHasRights != comptrollerAdminHasRights ||\n                cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights\n            ) arrayLength++;\n        }\n\n        CTokenOwnership[] memory outliers = new CTokenOwnership[](arrayLength);\n        uint256 arrayIndex = 0;\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            CToken cToken = cTokens[i];\n            (bool isListed, ) = comptroller.markets(address(cToken));\n            if (!isListed) continue;\n\n            address cTokenAdmin;\n            try cToken.admin() returns (address _cTokenAdmin) {\n                cTokenAdmin = _cTokenAdmin;\n            } catch {\n                continue;\n            }\n            bool cTokenAdminHasRights = cToken.adminHasRights();\n            bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n            // If outlier, push to array and increment array index\n            if (\n                cTokenAdmin != comptrollerAdmin ||\n                cTokenAdminHasRights != comptrollerAdminHasRights ||\n                cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights\n            ) {\n                outliers[arrayIndex] = CTokenOwnership(\n                    address(cToken),\n                    cTokenAdmin,\n                    cTokenAdminHasRights,\n                    cTokenFuseAdminHasRights\n                );\n                arrayIndex++;\n            }\n        }\n\n        return (\n            comptrollerAdmin,\n            comptrollerAdminHasRights,\n            comptrollerFuseAdminHasRights,\n            outliers\n        );\n    }\n\n    /**\n     * @notice Determine the maximum redeem amount of a cToken.\n     * @param cTokenModify The market to hypothetically redeem in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum redeem amount.\n     */\n    function getMaxRedeem(address account, CToken cTokenModify)\n        external\n        returns (uint256)\n    {\n        return getMaxRedeemOrBorrow(account, cTokenModify, false);\n    }\n\n    /**\n     * @notice Determine the maximum borrow amount of a cToken.\n     * @param cTokenModify The market to hypothetically borrow in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum borrow amount.\n     */\n    function getMaxBorrow(address account, CToken cTokenModify)\n        external\n        returns (uint256)\n    {\n        return getMaxRedeemOrBorrow(account, cTokenModify, true);\n    }\n\n    /**\n     * @dev Internal function to determine the maximum borrow/redeem amount of a cToken.\n     * @param cTokenModify The market to hypothetically borrow/redeem in.\n     * @param account The account to determine liquidity for.\n     * @return Maximum borrow/redeem amount.\n     */\n    function getMaxRedeemOrBorrow(\n        address account,\n        CToken cTokenModify,\n        bool isBorrow\n    ) internal returns (uint256) {\n        // Accrue interest\n        uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n\n        // Get account liquidity\n        Comptroller comptroller = Comptroller(cTokenModify.comptroller());\n        (uint256 err, uint256 liquidity, uint256 shortfall) = comptroller\n            .getAccountLiquidity(account);\n        require(\n            err == 0,\n            \"Comptroller error when calculating account liquidity.\"\n        );\n        if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\n\n        // Get max borrow/redeem\n        uint256 maxBorrowOrRedeemAmount;\n\n        if (\n            !isBorrow && !comptroller.checkMembership(msg.sender, cTokenModify)\n        ) {\n            // Max redeem = balance of underlying if not used as collateral\n            maxBorrowOrRedeemAmount = balanceOfUnderlying;\n        } else {\n            // Avoid \"stack too deep\" error by separating this logic\n            maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(\n                liquidity,\n                cTokenModify,\n                isBorrow\n            );\n\n            // Redeem only: max out at underlying balance\n            if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount)\n                maxBorrowOrRedeemAmount = balanceOfUnderlying;\n        }\n\n        // Get max borrow or redeem considering cToken liquidity\n        uint256 cTokenLiquidity = cTokenModify.getCash();\n\n        // Return the minimum of the two maximums\n        return\n            maxBorrowOrRedeemAmount <= cTokenLiquidity\n                ? maxBorrowOrRedeemAmount\n                : cTokenLiquidity;\n    }\n\n    /**\n     * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\n     */\n    function _getMaxRedeemOrBorrow(\n        uint256 liquidity,\n        CToken cTokenModify,\n        bool isBorrow\n    ) internal view returns (uint256) {\n        if (liquidity <= 0) return 0; // No available account liquidity, so no more borrow/redeem\n\n        // Get the normalized price of the asset\n        Comptroller comptroller = Comptroller(cTokenModify.comptroller());\n        uint256 conversionFactor = comptroller.oracle().getUnderlyingPrice(\n            cTokenModify\n        );\n        require(conversionFactor > 0, \"Oracle price error.\");\n\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n        if (!isBorrow) {\n            (, uint256 collateralFactorMantissa) = comptroller.markets(\n                address(cTokenModify)\n            );\n            conversionFactor = collateralFactorMantissa\n                .mul(conversionFactor)\n                .div(1e18);\n        }\n\n        // Get max borrow or redeem considering excess account liquidity\n        return liquidity.mul(1e18).div(conversionFactor);\n    }\n\n    /**\n     * @notice Returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n     * @param comptroller The Fuse pool Comptroller to check.\n     */\n    function getRewardSpeedsByPool(Comptroller comptroller)\n        public\n        view\n        returns (\n            CToken[] memory,\n            RewardsDistributor[] memory,\n            address[] memory,\n            uint256[][] memory,\n            uint256[][] memory\n        )\n    {\n        CToken[] memory allMarkets = comptroller.getAllMarkets();\n        RewardsDistributor[] memory distributors;\n\n        try comptroller.getRewardsDistributors() returns (\n            RewardsDistributor[] memory _distributors\n        ) {\n            distributors = _distributors;\n        } catch {\n            distributors = new RewardsDistributor[](0);\n        }\n\n        address[] memory rewardTokens = new address[](distributors.length);\n        uint256[][] memory supplySpeeds = new uint256[][](allMarkets.length);\n        uint256[][] memory borrowSpeeds = new uint256[][](allMarkets.length);\n\n        // Get reward tokens for each distributor\n        for (uint256 i = 0; i < distributors.length; i++)\n            rewardTokens[i] = distributors[i].rewardToken();\n\n        // Get reward speeds for each market for each distributor\n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            address cToken = address(allMarkets[i]);\n            supplySpeeds[i] = new uint256[](distributors.length);\n            borrowSpeeds[i] = new uint256[](distributors.length);\n\n            for (uint256 j = 0; j < distributors.length; j++) {\n                RewardsDistributor distributor = distributors[j];\n                supplySpeeds[i][j] = distributor.compSupplySpeeds(cToken);\n                borrowSpeeds[i][j] = distributor.compBorrowSpeeds(cToken);\n            }\n        }\n\n        return (\n            allMarkets,\n            distributors,\n            rewardTokens,\n            supplySpeeds,\n            borrowSpeeds\n        );\n    }\n\n    /**\n     * @notice For each `Comptroller`, returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n     * @param comptrollers The Fuse pool Comptrollers to check.\n     */\n    function getRewardSpeedsByPools(Comptroller[] memory comptrollers)\n        external\n        view\n        returns (\n            CToken[][] memory,\n            RewardsDistributor[][] memory,\n            address[][] memory,\n            uint256[][][] memory,\n            uint256[][][] memory\n        )\n    {\n        CToken[][] memory allMarkets = new CToken[][](comptrollers.length);\n        RewardsDistributor[][] memory distributors = new RewardsDistributor[][](\n            comptrollers.length\n        );\n        address[][] memory rewardTokens = new address[][](comptrollers.length);\n        uint256[][][] memory supplySpeeds = new uint256[][][](\n            comptrollers.length\n        );\n        uint256[][][] memory borrowSpeeds = new uint256[][][](\n            comptrollers.length\n        );\n        for (uint256 i = 0; i < comptrollers.length; i++)\n            (\n                allMarkets[i],\n                distributors[i],\n                rewardTokens[i],\n                supplySpeeds[i],\n                borrowSpeeds[i]\n            ) = getRewardSpeedsByPool(comptrollers[i]);\n        return (\n            allMarkets,\n            distributors,\n            rewardTokens,\n            supplySpeeds,\n            borrowSpeeds\n        );\n    }\n\n    /**\n     * @notice Returns unaccrued rewards by `holder` from `cToken` on `distributor`.\n     * @param holder The address to check.\n     * @param distributor The RewardsDistributor to check.\n     * @param cToken The CToken to check.\n     * @return Unaccrued (unclaimed) supply-side rewards and unaccrued (unclaimed) borrow-side rewards.\n     */\n    function getUnaccruedRewards(\n        address holder,\n        RewardsDistributor distributor,\n        CToken cToken\n    ) internal returns (uint256, uint256) {\n        // Get unaccrued supply rewards\n        uint256 compAccruedPrior = distributor.compAccrued(holder);\n        distributor.flywheelPreSupplierAction(address(cToken), holder);\n        uint256 supplyRewardsUnaccrued = distributor.compAccrued(holder).sub(\n            compAccruedPrior\n        );\n\n        // Get unaccrued borrow rewards\n        compAccruedPrior = distributor.compAccrued(holder);\n        distributor.flywheelPreBorrowerAction(address(cToken), holder);\n        uint256 borrowRewardsUnaccrued = distributor.compAccrued(holder).sub(\n            compAccruedPrior\n        );\n\n        // Return both\n        return (supplyRewardsUnaccrued, borrowRewardsUnaccrued);\n    }\n\n    /**\n     * @notice Returns all unclaimed rewards accrued by the `holder` on `distributors`.\n     * @param holder The address to check.\n     * @param distributors The `RewardsDistributor` contracts to check.\n     * @return For each of `distributors`: total quantity of unclaimed rewards, array of cTokens, array of unaccrued (unclaimed) supply-side and borrow-side rewards per cToken, and quantity of funds available in the distributor.\n     */\n    function getUnclaimedRewardsByDistributors(\n        address holder,\n        RewardsDistributor[] memory distributors\n    )\n        external\n        returns (\n            address[] memory,\n            uint256[] memory,\n            CToken[][] memory,\n            uint256[2][][] memory,\n            uint256[] memory\n        )\n    {\n        address[] memory rewardTokens = new address[](distributors.length);\n        uint256[] memory compUnclaimedTotal = new uint256[](\n            distributors.length\n        );\n        CToken[][] memory allMarkets = new CToken[][](distributors.length);\n        uint256[2][][] memory rewardsUnaccrued = new uint256[2][][](\n            distributors.length\n        );\n        uint256[] memory distributorFunds = new uint256[](distributors.length);\n\n        for (uint256 i = 0; i < distributors.length; i++) {\n            RewardsDistributor distributor = distributors[i];\n            rewardTokens[i] = distributor.rewardToken();\n            allMarkets[i] = distributor.getAllMarkets();\n            rewardsUnaccrued[i] = new uint256[2][](allMarkets[i].length);\n            for (uint256 j = 0; j < allMarkets[i].length; j++)\n                (\n                    rewardsUnaccrued[i][j][0],\n                    rewardsUnaccrued[i][j][1]\n                ) = getUnaccruedRewards(holder, distributor, allMarkets[i][j]);\n            compUnclaimedTotal[i] = distributor.compAccrued(holder);\n            distributorFunds[i] = IERC20Upgradeable(rewardTokens[i]).balanceOf(\n                address(distributor)\n            );\n        }\n\n        return (\n            rewardTokens,\n            compUnclaimedTotal,\n            allMarkets,\n            rewardsUnaccrued,\n            distributorFunds\n        );\n    }\n\n    /**\n     * @notice Returns arrays of indexes, `Comptroller` proxy contracts, and `RewardsDistributor` contracts for Fuse pools supplied to by `account`.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getRewardsDistributorsBySupplier(address supplier)\n        external\n        view\n        returns (\n            uint256[] memory,\n            Comptroller[] memory,\n            RewardsDistributor[][] memory\n        )\n    {\n        // Get array length\n        FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n        uint256 arrayLength = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            try Comptroller(pools[i].comptroller).suppliers(supplier) returns (\n                bool isSupplier\n            ) {\n                if (isSupplier) arrayLength++;\n            } catch {}\n        }\n\n        // Build array\n        uint256[] memory indexes = new uint256[](arrayLength);\n        Comptroller[] memory comptrollers = new Comptroller[](arrayLength);\n        RewardsDistributor[][] memory distributors = new RewardsDistributor[][](\n            arrayLength\n        );\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pools.length; i++) {\n            Comptroller comptroller = Comptroller(pools[i].comptroller);\n\n            try comptroller.suppliers(supplier) returns (bool isSupplier) {\n                if (isSupplier) {\n                    indexes[index] = i;\n                    comptrollers[index] = comptroller;\n\n                    try comptroller.getRewardsDistributors() returns (\n                        RewardsDistributor[] memory _distributors\n                    ) {\n                        distributors[index] = _distributors;\n                    } catch {}\n\n                    index++;\n                }\n            } catch {}\n        }\n\n        // Return distributors\n        return (indexes, comptrollers, distributors);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/FuseSafeLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"./liquidators/IRedemptionStrategy.sol\";\n\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/ICEther.sol\";\n\nimport \"./external/aave/IWETH.sol\";\n\nimport \"./external/uniswap/IUniswapV2Router02.sol\";\nimport \"./external/uniswap/IUniswapV2Callee.sol\";\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\nimport \"./external/uniswap/IUniswapV2Factory.sol\";\nimport \"./external/uniswap/UniswapV2Library.sol\";\n\n/**\n * @title FuseSafeLiquidator\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseSafeLiquidator safely liquidates unhealthy borrowers (with flashloan support).\n * @dev Do not transfer ETH or tokens directly to this address. Only send ETH here when using a method, and only approve tokens for transfer to here when using a method. Direct ETH transfers will be rejected and direct token transfers will be lost.\n */\ncontract FuseSafeLiquidator is Initializable, IUniswapV2Callee {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address payable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n     * @param from The input ERC20 token address (or the zero address if ETH) to exchange from.\n     * @param to The output ERC20 token address (or the zero address if ETH) to exchange to.\n     * @param minOutputAmount The minimum output amount of `to` necessary to complete the exchange without reversion.\n     * @param uniswapV2Router The UniswapV2Router02 to use.\n     */\n    function exchangeAllEthOrTokens(\n        address from,\n        address to,\n        uint256 minOutputAmount,\n        IUniswapV2Router02 uniswapV2Router\n    ) private {\n        if (to == from) return;\n\n        // From ETH, WETH, or something else?\n        if (from == address(0)) {\n            if (to == WETH_ADDRESS) {\n                // Deposit all ETH to WETH\n                WETH.deposit{value: address(this).balance}();\n            } else {\n                // Exchange from ETH to tokens\n                uniswapV2Router.swapExactETHForTokens{\n                    value: address(this).balance\n                }(\n                    minOutputAmount,\n                    array(WETH_ADDRESS, to),\n                    address(this),\n                    block.timestamp\n                );\n            }\n        } else if (from == WETH_ADDRESS && to == address(0)) {\n            // Withdraw all WETH to ETH\n            WETH.withdraw(\n                IERC20Upgradeable(WETH_ADDRESS).balanceOf(address(this))\n            );\n        } else {\n            // Approve input tokens\n            IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n            uint256 inputBalance = fromToken.balanceOf(address(this));\n            safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n            // Exchange from tokens to ETH or tokens\n            if (to == address(0))\n                uniswapV2Router.swapExactTokensForETH(\n                    inputBalance,\n                    minOutputAmount,\n                    array(from, WETH_ADDRESS),\n                    address(this),\n                    block.timestamp\n                );\n            else\n                uniswapV2Router.swapExactTokensForTokens(\n                    inputBalance,\n                    minOutputAmount,\n                    from == WETH_ADDRESS || to == WETH_ADDRESS\n                        ? array(from, to)\n                        : array(from, WETH_ADDRESS, to),\n                    address(this),\n                    block.timestamp\n                ); // Put WETH in the middle of the path if not already a part of the path\n        }\n    }\n\n    /**\n     * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n     * @param from The input ERC20 token address (or the zero address if ETH) to exchange from.\n     * @param outputAmount The output amount of ETH.\n     * @param uniswapV2Router The UniswapV2Router02 to use.\n     */\n    function exchangeToExactEth(\n        address from,\n        uint256 outputAmount,\n        IUniswapV2Router02 uniswapV2Router\n    ) private {\n        if (from == address(0)) return;\n\n        // From WETH something else?\n        if (from == WETH_ADDRESS) {\n            // Withdraw WETH to ETH\n            WETH.withdraw(outputAmount);\n        } else {\n            // Approve input tokens\n            IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n            uint256 inputBalance = fromToken.balanceOf(address(this));\n            safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n            // Exchange from tokens to ETH\n            uniswapV2Router.swapTokensForExactETH(\n                outputAmount,\n                inputBalance,\n                array(from, WETH_ADDRESS),\n                address(this),\n                block.timestamp\n            );\n        }\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n     * @param cErc20 The borrowed cErc20 to repay.\n     * @param cTokenCollateral The cToken collateral to be liquidated.\n     * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n     * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidate(\n        address borrower,\n        uint256 repayAmount,\n        CErc20 cErc20,\n        CToken cTokenCollateral,\n        uint256 minOutputAmount,\n        address exchangeSeizedTo,\n        IUniswapV2Router02 uniswapV2Router,\n        IRedemptionStrategy[] memory redemptionStrategies,\n        bytes[] memory strategyData\n    ) external returns (uint256) {\n        // Transfer tokens in, approve to cErc20, and liquidate borrow\n        require(\n            repayAmount > 0,\n            \"Repay amount (transaction value) must be greater than 0.\"\n        );\n        IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\n        underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n        safeApprove(underlying, address(cErc20), repayAmount);\n        require(\n            cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) ==\n                0,\n            \"Liquidation failed.\"\n        );\n\n        // Redeem seized cToken collateral if necessary\n        if (exchangeSeizedTo != address(cTokenCollateral)) {\n            uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(\n                address(this)\n            );\n\n            if (seizedCTokenAmount > 0) {\n                uint256 redeemResult = cTokenCollateral.redeem(\n                    seizedCTokenAmount\n                );\n                require(\n                    redeemResult == 0,\n                    \"Error calling redeeming seized cToken: error code not equal to 0\"\n                );\n\n                // If cTokenCollateral is CEther\n                if (cTokenCollateral.isCEther()) {\n                    // Exchange redeemed ETH collateral if necessary\n                    exchangeAllEthOrTokens(\n                        address(0),\n                        exchangeSeizedTo,\n                        minOutputAmount,\n                        uniswapV2Router\n                    );\n                } else {\n                    // Redeem custom collateral if liquidation strategy is set\n                    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(\n                        CErc20(address(cTokenCollateral)).underlying()\n                    );\n\n                    if (redemptionStrategies.length > 0) {\n                        require(\n                            redemptionStrategies.length == strategyData.length,\n                            \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n                        );\n                        uint256 underlyingCollateralSeized = underlyingCollateral\n                                .balanceOf(address(this));\n                        for (\n                            uint256 i = 0;\n                            i < redemptionStrategies.length;\n                            i++\n                        )\n                            (\n                                underlyingCollateral,\n                                underlyingCollateralSeized\n                            ) = redeemCustomCollateral(\n                                underlyingCollateral,\n                                underlyingCollateralSeized,\n                                redemptionStrategies[i],\n                                strategyData[i]\n                            );\n                    }\n\n                    // Exchange redeemed token collateral if necessary\n                    exchangeAllEthOrTokens(\n                        address(underlyingCollateral),\n                        exchangeSeizedTo,\n                        minOutputAmount,\n                        uniswapV2Router\n                    );\n                }\n            }\n        }\n\n        // Transfer seized amount to sender\n        return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n     * @param borrower The borrower's Ethereum address.\n     * @param cEther The borrowed cEther contract to repay.\n     * @param cErc20Collateral The cErc20 collateral contract to be liquidated.\n     * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n     * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidate(\n        address borrower,\n        CEther cEther,\n        CErc20 cErc20Collateral,\n        uint256 minOutputAmount,\n        address exchangeSeizedTo,\n        IUniswapV2Router02 uniswapV2Router,\n        IRedemptionStrategy[] memory redemptionStrategies,\n        bytes[] memory strategyData\n    ) external payable returns (uint256) {\n        // Liquidate ETH borrow\n        require(\n            msg.value > 0,\n            \"Repay amount (transaction value) must be greater than 0.\"\n        );\n        cEther.liquidateBorrow{value: msg.value}(\n            borrower,\n            CToken(cErc20Collateral)\n        );\n\n        // Redeem seized cToken collateral if necessary\n        if (exchangeSeizedTo != address(cErc20Collateral)) {\n            uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(\n                address(this)\n            );\n\n            if (seizedCTokenAmount > 0) {\n                uint256 redeemResult = cErc20Collateral.redeem(\n                    seizedCTokenAmount\n                );\n                require(\n                    redeemResult == 0,\n                    \"Error calling redeeming seized cToken: error code not equal to 0\"\n                );\n\n                // Redeem custom collateral if liquidation strategy is set\n                IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(\n                    cErc20Collateral.underlying()\n                );\n\n                if (redemptionStrategies.length > 0) {\n                    require(\n                        redemptionStrategies.length == strategyData.length,\n                        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n                    );\n                    uint256 underlyingCollateralSeized = underlyingCollateral\n                        .balanceOf(address(this));\n                    for (uint256 i = 0; i < redemptionStrategies.length; i++)\n                        (\n                            underlyingCollateral,\n                            underlyingCollateralSeized\n                        ) = this.redeemCustomCollateral(\n                            underlyingCollateral,\n                            underlyingCollateralSeized,\n                            redemptionStrategies[i],\n                            strategyData[i]\n                        ); // redeemCustomCollateral called externally because this safeLiquidate function is payable (for some reason delegatecall fails when called with msg.value > 0)\n                }\n\n                // Exchange redeemed collateral if necessary\n                exchangeAllEthOrTokens(\n                    address(underlyingCollateral),\n                    exchangeSeizedTo,\n                    minOutputAmount,\n                    uniswapV2Router\n                );\n            }\n        }\n\n        // Transfer seized amount to sender\n        return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n    }\n\n    /**\n     * @dev Transfers seized funds to the sender.\n     * @param erc20Contract The address of the token to transfer.\n     * @param minOutputAmount The minimum amount to transfer.\n     */\n    function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount)\n        internal\n        returns (uint256)\n    {\n        uint256 seizedOutputAmount;\n\n        if (erc20Contract == address(0)) {\n            seizedOutputAmount = address(this).balance;\n            require(\n                seizedOutputAmount >= minOutputAmount,\n                \"Minimum ETH output amount not satisfied.\"\n            );\n\n            if (seizedOutputAmount > 0) {\n                (bool success, ) = msg.sender.call{value: seizedOutputAmount}(\n                    \"\"\n                );\n                require(\n                    success,\n                    \"Failed to transfer output ETH to msg.sender.\"\n                );\n            }\n        } else {\n            IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n            seizedOutputAmount = token.balanceOf(address(this));\n            require(\n                seizedOutputAmount >= minOutputAmount,\n                \"Minimum token output amount not satified.\"\n            );\n            if (seizedOutputAmount > 0)\n                token.safeTransfer(msg.sender, seizedOutputAmount);\n        }\n\n        return seizedOutputAmount;\n    }\n\n    /**\n     * @dev WETH contract address.\n     */\n    address internal WETH_ADDRESS;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH internal WETH;\n\n    /**\n     * @dev UniswapV2Router02 contract address.\n     */\n    address internal UNISWAP_V2_ROUTER_02_ADDRESS;\n\n    /**\n     * @dev UniswapV2Router02 contract object.\n     */\n    IUniswapV2Router02 internal UNISWAP_V2_ROUTER_02;\n\n    /**\n     * @dev WETH flashloan pair base token #1 (USDC on Ethereum, MIM on Arbitrum).\n     */\n    address internal WETH_FLASHLOAN_BASE_TOKEN_1;\n\n    /**\n     * @dev WETH flashloan pair base token #2 (WBTC on Ethereum, DPX on Arbitrum).\n     */\n    address internal WETH_FLASHLOAN_BASE_TOKEN_2;\n\n    /**\n     * @dev Constructor to set immutable variables.\n     */\n    constructor() public {\n        WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n        UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap V2 on Ethereum\n        UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n        );\n        WETH_FLASHLOAN_BASE_TOKEN_1 = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC on Ethereum\n        WETH_FLASHLOAN_BASE_TOKEN_2 = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC on Ethereum\n    }\n\n    /**\n     * @dev Cached liquidator profit exchange source.\n     * ERC20 token address or the zero address for ETH.\n     * For use in `safeLiquidateToTokensWithFlashLoan`/`safeLiquidateToEthWithFlashLoan` after it is set by `postFlashLoanTokens`/`postFlashLoanWeth`.\n     */\n    address private _liquidatorProfitExchangeSource;\n\n    /**\n     * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in ETH profit is seized.\n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n     * @param cErc20 The borrowed CErc20 contract to repay.\n     * @param cTokenCollateral The cToken collateral contract to be liquidated.\n     * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n     * @param exchangeProfitTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2RouterForBorrow The UniswapV2Router to use to convert the ETH to the underlying borrow (and flashloan the underlying borrow for ETH).\n     * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to ETH.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidateToTokensWithFlashLoan(\n        address borrower,\n        uint256 repayAmount,\n        CErc20 cErc20,\n        CToken cTokenCollateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        IUniswapV2Router02 uniswapV2RouterForBorrow,\n        IUniswapV2Router02 uniswapV2RouterForCollateral,\n        IRedemptionStrategy[] memory redemptionStrategies,\n        bytes[] memory strategyData,\n        uint256 ethToCoinbase\n    ) external returns (uint256) {\n        // Input validation\n        require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n        // Flashloan via Uniswap (scoping `underlyingBorrow` variable to avoid \"stack too deep\" compiler error)\n        IUniswapV2Pair pair;\n        bool token0IsUnderlyingBorrow;\n        {\n            address underlyingBorrow = cErc20.underlying();\n            pair = IUniswapV2Pair(\n                IUniswapV2Factory(uniswapV2RouterForBorrow.factory()).getPair(\n                    underlyingBorrow,\n                    WETH_ADDRESS\n                )\n            );\n            token0IsUnderlyingBorrow = pair.token0() == underlyingBorrow;\n        }\n        pair.swap(\n            token0IsUnderlyingBorrow ? repayAmount : 0,\n            !token0IsUnderlyingBorrow ? repayAmount : 0,\n            address(this),\n            msg.data\n        );\n\n        // Exchange profit, send ETH to coinbase if necessary, and transfer seized funds\n        return\n            distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n    }\n\n    /**\n     * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in ETH profit is seized.\n     * @param borrower The borrower's Ethereum address.\n     * @param repayAmount The ETH amount to repay to liquidate the unhealthy loan.\n     * @param cEther The borrowed CEther contract to repay.\n     * @param cErc20Collateral The CErc20 collateral contract to be liquidated.\n     * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n     * @param exchangeProfitTo If set to an address other than `cErc20Collateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for ETH).\n     * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to ETH.\n     * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n     */\n    function safeLiquidateToEthWithFlashLoan(\n        address borrower,\n        uint256 repayAmount,\n        CEther cEther,\n        CErc20 cErc20Collateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        IUniswapV2Router02 uniswapV2RouterForCollateral,\n        IRedemptionStrategy[] memory redemptionStrategies,\n        bytes[] memory strategyData,\n        uint256 ethToCoinbase\n    ) external returns (uint256) {\n        // Input validation\n        require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n        // Flashloan via Uniswap\n        IUniswapV2Pair pair = IUniswapV2Pair(\n            UniswapV2Library.pairFor(\n                UNISWAP_V2_ROUTER_02.factory(),\n                address(uniswapV2RouterForCollateral) ==\n                    UNISWAP_V2_ROUTER_02_ADDRESS &&\n                    cErc20Collateral.underlying() == WETH_FLASHLOAN_BASE_TOKEN_1\n                    ? WETH_FLASHLOAN_BASE_TOKEN_2\n                    : WETH_FLASHLOAN_BASE_TOKEN_1,\n                WETH_ADDRESS\n            )\n        ); // Use USDC unless collateral is USDC, in which case we use WBTC to avoid a reentrancy error when exchanging the collateral to repay the borrow\n        address token0 = pair.token0();\n        pair.swap(\n            token0 == WETH_ADDRESS ? repayAmount : 0,\n            token0 != WETH_ADDRESS ? repayAmount : 0,\n            address(this),\n            msg.data\n        );\n\n        // Exchange profit, send ETH to coinbase if necessary, and transfer seized funds\n        return\n            distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n    }\n\n    /**\n     * Exchange profit, send ETH to coinbase if necessary, and transfer seized funds to sender.\n     */\n    function distributeProfit(\n        address exchangeProfitTo,\n        uint256 minProfitAmount,\n        uint256 ethToCoinbase\n    ) private returns (uint256) {\n        if (exchangeProfitTo == address(0)) {\n            // Exchange profit if necessary\n            exchangeAllEthOrTokens(\n                _liquidatorProfitExchangeSource,\n                exchangeProfitTo,\n                minProfitAmount.add(ethToCoinbase),\n                UNISWAP_V2_ROUTER_02\n            );\n\n            // Transfer ETH to block.coinbase if requested\n            if (ethToCoinbase > 0)\n                block.coinbase.call{value: ethToCoinbase}(\"\");\n\n            // Transfer profit to msg.sender\n            return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n        } else {\n            // Transfer ETH to block.coinbase if requested\n            if (ethToCoinbase > 0) {\n                exchangeToExactEth(\n                    _liquidatorProfitExchangeSource,\n                    ethToCoinbase,\n                    UNISWAP_V2_ROUTER_02\n                );\n                block.coinbase.call{value: ethToCoinbase}(\"\");\n            }\n\n            // Exchange profit if necessary\n            exchangeAllEthOrTokens(\n                _liquidatorProfitExchangeSource,\n                exchangeProfitTo,\n                minProfitAmount.add(ethToCoinbase),\n                UNISWAP_V2_ROUTER_02\n            );\n\n            // Transfer profit to msg.sender\n            return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n        }\n    }\n\n    /**\n     * @dev Receives ETH from liquidations and flashloans.\n     * Requires that `msg.sender` is WETH, a CToken, or a Uniswap V2 Router, or another contract.\n     */\n    receive() external payable {\n        require(msg.sender.isContract(), \"Sender is not a contract.\");\n    }\n\n    /**\n     * @dev Callback function for Uniswap flashloans.\n     */\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override {\n        address cToken = abi.decode(data[68:100], (address));\n\n        // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\n        if (CToken(cToken).isCEther()) {\n            // Decode params\n            (\n                address borrower,\n                uint256 repayAmount,\n                ,\n                address cTokenCollateral,\n                uint256 minProfitAmount,\n                address exchangeProfitTo,\n                IUniswapV2Router02 uniswapV2Router,\n                address[] memory redemptionStrategies,\n                bytes[] memory strategyData\n            ) = abi.decode(\n                    data[4:],\n                    (\n                        address,\n                        uint256,\n                        address,\n                        address,\n                        uint256,\n                        address,\n                        IUniswapV2Router02,\n                        address[],\n                        bytes[]\n                    )\n                );\n\n            // Calculate flashloan return amount\n            uint256 flashLoanReturnAmount = repayAmount.mul(1000).div(997);\n            if (repayAmount.mul(1000).mod(997) > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n            // Post WETH flashloan\n            // Cache liquidation profit token (or the zero address for ETH) for use as source for exchange later\n            _liquidatorProfitExchangeSource = postFlashLoanWeth(\n                borrower,\n                repayAmount,\n                CEther(cToken),\n                CErc20(cTokenCollateral),\n                minProfitAmount,\n                exchangeProfitTo,\n                flashLoanReturnAmount,\n                uniswapV2Router,\n                redemptionStrategies,\n                strategyData\n            );\n        } else {\n            // Decode params\n            (\n                address borrower,\n                uint256 repayAmount,\n                ,\n                address cTokenCollateral,\n                uint256 minProfitAmount,\n                address exchangeProfitTo,\n                IUniswapV2Router02 uniswapV2RouterForBorrow,\n                IUniswapV2Router02 uniswapV2RouterForCollateral,\n                address[] memory redemptionStrategies,\n                bytes[] memory strategyData\n            ) = abi.decode(\n                    data[4:],\n                    (\n                        address,\n                        uint256,\n                        address,\n                        address,\n                        uint256,\n                        address,\n                        IUniswapV2Router02,\n                        IUniswapV2Router02,\n                        address[],\n                        bytes[]\n                    )\n                );\n\n            // Calculate flashloan return amount\n            uint256 flashLoanReturnAmount = repayAmount.mul(1000).div(997);\n            if (repayAmount.mul(1000).mod(997) > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n            // Post token flashloan\n            // Cache liquidation profit token (or the zero address for ETH) for use as source for exchange later\n            _liquidatorProfitExchangeSource = postFlashLoanTokens(\n                borrower,\n                repayAmount,\n                CErc20(cToken),\n                CToken(cTokenCollateral),\n                minProfitAmount,\n                exchangeProfitTo,\n                flashLoanReturnAmount,\n                uniswapV2RouterForBorrow,\n                uniswapV2RouterForCollateral,\n                redemptionStrategies,\n                strategyData\n            );\n        }\n    }\n\n    /**\n     * @dev Fetches and sorts the reserves for a pair.\n     * Original code from UniswapV2Library.\n     */\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) private view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            IUniswapV2Factory(factory).getPair(tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    /**\n     * @dev Performs chained getAmountIn calculations on any number of pairs.\n     * Original code from UniswapV2Library.\n     */\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) private view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = UniswapV2Library.getAmountIn(\n                amounts[i],\n                reserveIn,\n                reserveOut\n            );\n        }\n    }\n\n    /**\n     * @dev Liquidate unhealthy ETH borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n     */\n    function postFlashLoanWeth(\n        address borrower,\n        uint256 repayAmount,\n        CEther cEther,\n        CErc20 cErc20Collateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        uint256 flashLoanReturnAmount,\n        IUniswapV2Router02 uniswapV2Router,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData\n    ) private returns (address) {\n        // Unwrap WETH\n        WETH.withdraw(repayAmount);\n\n        // Liquidate ETH borrow using flashloaned ETH\n        cEther.liquidateBorrow{value: repayAmount}(\n            borrower,\n            CToken(cErc20Collateral)\n        );\n\n        // Redeem seized cTokens for underlying asset\n        uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(address(this));\n        require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n        uint256 redeemResult = cErc20Collateral.redeem(seizedCTokenAmount);\n        require(\n            redeemResult == 0,\n            \"Error calling redeeming seized cToken: error code not equal to 0\"\n        );\n\n        // Repay flashloan\n        return\n            repayWethFlashLoan(\n                repayAmount,\n                cErc20Collateral,\n                exchangeProfitTo,\n                flashLoanReturnAmount,\n                uniswapV2Router,\n                redemptionStrategies,\n                strategyData\n            );\n    }\n\n    /**\n     * @dev Repays WETH flashloans.\n     */\n    function repayWethFlashLoan(\n        uint256 repayAmount,\n        CErc20 cErc20Collateral,\n        address exchangeProfitTo,\n        uint256 flashLoanReturnAmount,\n        IUniswapV2Router02 uniswapV2Router,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData\n    ) private returns (address) {\n        // Check underlying collateral seized\n        IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(\n            cErc20Collateral.underlying()\n        );\n        uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(\n            address(this)\n        );\n\n        // Redeem custom collateral if liquidation strategy is set\n        if (redemptionStrategies.length > 0) {\n            require(\n                redemptionStrategies.length == strategyData.length,\n                \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n            );\n            for (uint256 i = 0; i < redemptionStrategies.length; i++)\n                (\n                    underlyingCollateral,\n                    underlyingCollateralSeized\n                ) = redeemCustomCollateral(\n                    underlyingCollateral,\n                    underlyingCollateralSeized,\n                    IRedemptionStrategy(redemptionStrategies[i]),\n                    strategyData[i]\n                );\n        }\n\n        // Check side of the flashloan to repay: if input token (underlying collateral) is part of flashloan, repay it (to avoid reentracy error); otherwise, convert to WETH and repay WETH\n        if (\n            address(uniswapV2Router) == UNISWAP_V2_ROUTER_02_ADDRESS &&\n            address(underlyingCollateral) ==\n            (\n                cErc20Collateral.underlying() ==\n                    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n                    ? 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n                    : 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n            )\n        ) {\n            // Get tokens required to repay flashloan and repay flashloan in non-WETH tokens\n            uint256 tokensRequired = getAmountsIn(\n                uniswapV2Router.factory(),\n                repayAmount,\n                array(address(underlyingCollateral), WETH_ADDRESS)\n            )[0];\n            require(\n                tokensRequired <= underlyingCollateralSeized,\n                \"Flashloan return amount greater than seized collateral.\"\n            );\n            require(\n                underlyingCollateral.transfer(msg.sender, tokensRequired),\n                \"Failed to transfer non-WETH tokens back to flashlender.\"\n            );\n        } else {\n            // If underlying collateral is not already WETH, convert it to WETH\n            if (address(underlyingCollateral) != WETH_ADDRESS) {\n                // If underlying collateral is ETH, deposit to WETH; if token, exchange to WETH\n                if (address(underlyingCollateral) == address(0)) {\n                    // Deposit ETH to WETH to repay flashloan\n                    WETH.deposit{value: flashLoanReturnAmount}();\n                } else {\n                    // Approve to Uniswap router\n                    safeApprove(\n                        underlyingCollateral,\n                        address(uniswapV2Router),\n                        underlyingCollateralSeized\n                    );\n\n                    // Swap collateral tokens for WETH via Uniswap router\n                    if (exchangeProfitTo == address(underlyingCollateral))\n                        uniswapV2Router.swapTokensForExactTokens(\n                            flashLoanReturnAmount,\n                            underlyingCollateralSeized,\n                            array(address(underlyingCollateral), WETH_ADDRESS),\n                            address(this),\n                            block.timestamp\n                        );\n                    else {\n                        uniswapV2Router.swapExactTokensForTokens(\n                            underlyingCollateralSeized,\n                            flashLoanReturnAmount,\n                            array(address(underlyingCollateral), WETH_ADDRESS),\n                            address(this),\n                            block.timestamp\n                        );\n                        underlyingCollateral = IERC20Upgradeable(WETH_ADDRESS);\n                    }\n                }\n            }\n\n            // Repay flashloan in WETH\n            require(\n                flashLoanReturnAmount <=\n                    IERC20Upgradeable(WETH_ADDRESS).balanceOf(address(this)),\n                \"Flashloan return amount greater than WETH exchanged from seized collateral.\"\n            );\n            require(\n                WETH.transfer(msg.sender, flashLoanReturnAmount),\n                \"Failed to transfer WETH back to flashlender.\"\n            );\n        }\n\n        // Return the profited token\n        return address(underlyingCollateral);\n    }\n\n    /**\n     * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n     */\n    function postFlashLoanTokens(\n        address borrower,\n        uint256 repayAmount,\n        CErc20 cErc20,\n        CToken cTokenCollateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        uint256 flashLoanReturnAmount,\n        IUniswapV2Router02 uniswapV2RouterForBorrow,\n        IUniswapV2Router02 uniswapV2RouterForCollateral,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData\n    ) private returns (address) {\n        // Approve repayAmount to cErc20\n        IERC20Upgradeable underlyingBorrow = IERC20Upgradeable(\n            cErc20.underlying()\n        );\n        safeApprove(underlyingBorrow, address(cErc20), repayAmount);\n\n        // Liquidate ETH borrow using flashloaned ETH\n        require(\n            cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) ==\n                0,\n            \"Liquidation failed.\"\n        );\n\n        // Redeem seized cTokens for underlying asset\n        uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n        require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n        uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n        require(\n            redeemResult == 0,\n            \"Error calling redeeming seized cToken: error code not equal to 0\"\n        );\n\n        // Repay flashloan\n        return\n            repayTokenFlashLoan(\n                repayAmount,\n                cTokenCollateral,\n                exchangeProfitTo,\n                flashLoanReturnAmount,\n                uniswapV2RouterForBorrow,\n                uniswapV2RouterForCollateral,\n                redemptionStrategies,\n                strategyData,\n                underlyingBorrow\n            );\n    }\n\n    /**\n     * @dev Repays token flashloans.\n     */\n    function repayTokenFlashLoan(\n        uint256 repayAmount,\n        CToken cTokenCollateral,\n        address exchangeProfitTo,\n        uint256 flashLoanReturnAmount,\n        IUniswapV2Router02 uniswapV2RouterForBorrow,\n        IUniswapV2Router02 uniswapV2RouterForCollateral,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData,\n        IERC20Upgradeable underlyingBorrow\n    ) private returns (address) {\n        // Swap cTokenCollateral for cErc20 via Uniswap\n        if (cTokenCollateral.isCEther()) {\n            // Get flashloan repay amount in terms of WETH collateral via Uniswap router\n            // uniswapV2RouterForCollateral is ignored because it should be the same as uniswapV2RouterForBorrow\n            uint256 underlyingCollateralSeized = address(this).balance;\n            uint256 wethRequired = getAmountsIn(\n                uniswapV2RouterForBorrow.factory(),\n                repayAmount,\n                array(WETH_ADDRESS, address(underlyingBorrow))\n            )[0];\n\n            // Repay flashloan\n            require(\n                wethRequired <= underlyingCollateralSeized,\n                \"Seized ETH collateral not enough to repay flashloan.\"\n            );\n            WETH.deposit{value: wethRequired}();\n            require(\n                WETH.transfer(msg.sender, wethRequired),\n                \"Failed to repay Uniswap flashloan with WETH exchanged from seized collateral.\"\n            );\n\n            // Return the profited token (ETH)\n            return address(0);\n        } else {\n            // Check underlying collateral seized\n            IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(\n                CErc20(address(cTokenCollateral)).underlying()\n            );\n            uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(\n                address(this)\n            );\n\n            // Redeem custom collateral if liquidation strategy is set\n            if (redemptionStrategies.length > 0) {\n                require(\n                    redemptionStrategies.length == strategyData.length,\n                    \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n                );\n                for (uint256 i = 0; i < redemptionStrategies.length; i++)\n                    (\n                        underlyingCollateral,\n                        underlyingCollateralSeized\n                    ) = redeemCustomCollateral(\n                        underlyingCollateral,\n                        underlyingCollateralSeized,\n                        IRedemptionStrategy(redemptionStrategies[i]),\n                        strategyData[i]\n                    );\n            }\n\n            // Check which side of the flashloan to repay\n            if (address(underlyingCollateral) == address(underlyingBorrow)) {\n                // Repay flashloan on borrow side with collateral\n                require(\n                    flashLoanReturnAmount <=\n                        underlyingBorrow.balanceOf(address(this)),\n                    \"Token flashloan return amount greater than tokens exchanged from seized collateral.\"\n                );\n                require(\n                    underlyingBorrow.transfer(\n                        msg.sender,\n                        flashLoanReturnAmount\n                    ),\n                    \"Failed to repay token flashloan on borrow (non-WETH) side.\"\n                );\n\n                // Return the profited token (same as collateral and borrow)\n                return address(underlyingCollateral);\n            } else {\n                // Get WETH required to repay flashloan\n                uint256 wethRequired = getAmountsIn(\n                    uniswapV2RouterForBorrow.factory(),\n                    repayAmount,\n                    array(WETH_ADDRESS, address(underlyingBorrow))\n                )[0];\n\n                if (address(underlyingCollateral) != WETH_ADDRESS) {\n                    // Approve to Uniswap router\n                    safeApprove(\n                        underlyingCollateral,\n                        address(uniswapV2RouterForCollateral),\n                        underlyingCollateralSeized\n                    );\n\n                    // Swap collateral tokens for WETH to be repaid via Uniswap router\n                    if (exchangeProfitTo == address(underlyingCollateral))\n                        uniswapV2RouterForCollateral.swapTokensForExactTokens(\n                            wethRequired,\n                            underlyingCollateralSeized,\n                            array(address(underlyingCollateral), WETH_ADDRESS),\n                            address(this),\n                            block.timestamp\n                        );\n                    else\n                        uniswapV2RouterForCollateral.swapExactTokensForTokens(\n                            underlyingCollateralSeized,\n                            wethRequired,\n                            array(address(underlyingCollateral), WETH_ADDRESS),\n                            address(this),\n                            block.timestamp\n                        );\n                }\n\n                // Repay flashloan\n                require(\n                    wethRequired <=\n                        IERC20Upgradeable(WETH_ADDRESS).balanceOf(\n                            address(this)\n                        ),\n                    \"Not enough WETH exchanged from seized collateral to repay flashloan.\"\n                );\n                require(\n                    WETH.transfer(msg.sender, wethRequired),\n                    \"Failed to repay Uniswap flashloan with WETH exchanged from seized collateral.\"\n                );\n\n                // Return the profited token (underlying collateral if same as exchangeProfitTo; otherwise, WETH)\n                return\n                    exchangeProfitTo == address(underlyingCollateral)\n                        ? address(underlyingCollateral)\n                        : WETH_ADDRESS;\n            }\n        }\n    }\n\n    /**\n     * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n     * Public visibility because we have to call this function externally if called from a payable FuseSafeLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\n     */\n    function redeemCustomCollateral(\n        IERC20Upgradeable underlyingCollateral,\n        uint256 underlyingCollateralSeized,\n        IRedemptionStrategy strategy,\n        bytes memory strategyData\n    ) public returns (IERC20Upgradeable, uint256) {\n        bytes memory returndata = _functionDelegateCall(\n            address(strategy),\n            abi.encodeWithSelector(\n                strategy.redeem.selector,\n                underlyingCollateral,\n                underlyingCollateralSeized,\n                strategyData\n            )\n        );\n        return abi.decode(returndata, (IERC20Upgradeable, uint256));\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\n     * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\n     */\n    function _functionDelegateCall(address target, bytes memory data)\n        private\n        returns (bytes memory)\n    {\n        require(\n            AddressUpgradeable.isContract(target),\n            \"Address: delegate call to non-contract\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return\n            _verifyCallResult(\n                success,\n                returndata,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\n     * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\n     */\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(uint256 a) private pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n        arr[0] = a;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(address a) private pure returns (address[] memory) {\n        address[] memory arr = new address[](1);\n        arr[0] = a;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(address a, address b)\n        private\n        pure\n        returns (address[] memory)\n    {\n        address[] memory arr = new address[](2);\n        arr[0] = a;\n        arr[1] = b;\n        return arr;\n    }\n\n    /**\n     * @dev Returns an array containing the parameters supplied.\n     */\n    function array(\n        address a,\n        address b,\n        address c\n    ) private pure returns (address[] memory) {\n        address[] memory arr = new address[](3);\n        arr[0] = a;\n        arr[1] = b;\n        arr[2] = c;\n        return arr;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/AlphaHomoraV1BankLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/Bank.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV1BankLiquidator\n * @notice Redeems seized Alpha Homora v1 ibETH (Bank) tokens for ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1BankLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem ibTokenV2 for underlying ETH token (and store output as new collateral)\n        Bank bank = Bank(address(inputToken));\n        bank.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/AlphaHomoraV2SafeBoxETHLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBoxETH.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxETHLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibETHv2\" (SafeBoxETH) tokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxETHLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem ibTokenV2 for underlying ETH (and store output as new collateral)\n        ISafeBoxETH safeBox = ISafeBoxETH(address(inputToken));\n        safeBox.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/AlphaHomoraV2SafeBoxLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBox.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibTokenV2\" or SafeBox tokens (e.g., ibDAIv2) for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem ibTokenV2 for underlying ERC20 token (and store output as new collateral)\n        ISafeBox safeBox = ISafeBox(address(inputToken));\n        safeBox.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(safeBox.uToken());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/BadgerSettLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/badger/Sett.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\nimport \"./BadgerSettLiquidatorEnclave.sol\";\n\n/**\n * @title BadgerSettLiquidator\n * @notice Redeems a Badger Sett for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerSettLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Internal \"enclave\" which is whitelisted to redeem Badger Setts.\n     */\n    BadgerSettLiquidatorEnclave public immutable enclave;\n\n    /**\n     * @notice Constructor to deploy BadgerSettLiquidatorEnclave.\n     */\n    constructor() public {\n        enclave = new BadgerSettLiquidatorEnclave();\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        Sett token = Sett(address(inputToken));\n        inputToken.safeTransfer(address(enclave), inputAmount);\n        (outputToken, outputAmount) = enclave.withdrawAll(token);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/BadgerSettLiquidatorEnclave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/badger/Sett.sol\";\n\n/**\n * @title BadgerSettLiquidatorEnclave\n * @notice Internal component to redeems a Badger Sett for underlying tokens for use as a step in a liquidation.\n * @dev This contract was created because we need to whitelist a contract that can only withdraw from a Sett and not deposit. We cannot use BadgerSettLiquidator because FuseSafeLiquidator delegatecalls to it, meaning the address to whitelist would be FuseSafeLiquidator, which is open to permissionless strategies.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerSettLiquidatorEnclave {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Withdraws all from the Sett `inputToken`.\n     */\n    function withdrawAll(Sett inputToken)\n        external\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        inputToken.withdrawAll();\n        outputToken = IERC20Upgradeable(inputToken.token());\n        outputAmount = outputToken.balanceOf(address(this));\n        outputToken.safeTransfer(msg.sender, outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CErc20Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CErc20Liquidator\n * @notice Redeems seized Compound/Cream/Fuse CErc20 cTokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CErc20Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem cErc20 for underlying ERC20 token (and store output as new collateral)\n        CErc20 cErc20 = CErc20(address(inputToken));\n        uint256 redeemResult = cErc20.redeem(inputAmount);\n        require(\n            redeemResult == 0,\n            \"Error calling redeeming seized cErc20: error code not equal to 0\"\n        );\n        outputToken = IERC20Upgradeable(cErc20.underlying());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CEtherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICEther.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CEtherLiquidator\n * @notice Redeems seized Compound/Cream/Fuse CEther cTokens for underlying ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CEtherLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem cEther for underlying ETH (and store output as new collateral)\n        CEther cEther = CEther(address(inputToken));\n        uint256 redeemResult = cEther.redeem(inputAmount);\n        require(\n            redeemResult == 0,\n            \"Error calling redeeming seized cEther: error code not equal to 0\"\n        );\n        outputToken = IERC20Upgradeable(address(0));\n        outputAmount = address(this).balance;\n\n        // Convert to WETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CurveLiquidityGaugeV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\nimport \"../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2Liquidator\n * @notice Redeems seized Curve LiquidityGaugeV2 collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLiquidityGaugeV2Liquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem Curve liquidity gauge V2 token for Curve pool LP token (and store output as new collateral)\n        ICurveLiquidityGaugeV2 gauge = ICurveLiquidityGaugeV2(\n            address(inputToken)\n        );\n        gauge.withdraw(inputAmount);\n        inputToken = IERC20Upgradeable(gauge.lp_token());\n\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurvePool curvePool = ICurvePool(\n            ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c)\n                .get_pool_from_lp_token(address(inputToken))\n        );\n        (uint8 curveCoinIndex, address underlying) = abi.decode(\n            strategyData,\n            (uint8, address)\n        );\n        curvePool.remove_liquidity_one_coin(\n            inputAmount,\n            int128(curveCoinIndex),\n            1\n        );\n        outputToken = IERC20Upgradeable(\n            underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                ? address(0)\n                : underlying\n        );\n        outputAmount = address(outputToken) == address(0)\n            ? address(this).balance\n            : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CurveLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLpTokenLiquidator\n * @notice Redeems seized Curve LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLpTokenLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurvePool curvePool = ICurvePool(\n            ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c)\n                .get_pool_from_lp_token(address(inputToken))\n        );\n        (uint8 curveCoinIndex, address underlying) = abi.decode(\n            strategyData,\n            (uint8, address)\n        );\n        curvePool.remove_liquidity_one_coin(\n            inputAmount,\n            int128(curveCoinIndex),\n            1\n        );\n        outputToken = IERC20Upgradeable(\n            underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                ? address(0)\n                : underlying\n        );\n        outputAmount = address(outputToken) == address(0)\n            ? address(this).balance\n            : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CurveMetapoolLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveStableSwap.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveMetaPoolLpTokenLiquidator\n * @notice Redeems seized Curve Metapool LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveMetaPoolLpTokenLiquidator is IRedemptionStrategy {\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurveStableSwap curvePool = ICurveStableSwap(address(inputToken));\n        (uint8 curveCoinIndex, address underlying) = abi.decode(\n            strategyData,\n            (uint8, address)\n        );\n        curvePool.remove_liquidity_one_coin(\n            inputAmount,\n            int128(curveCoinIndex),\n            1\n        );\n        outputToken = IERC20Upgradeable(\n            underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                ? address(0)\n                : underlying\n        );\n        outputAmount = address(outputToken) == address(0)\n            ? address(this).balance\n            : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CurveSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveSwapLiquidator\n * @notice Swaps seized token collateral via Curve as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveSwapLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Exchange and store output\n        (ICurvePool curvePool, int128 i, int128 j, address jToken) = abi.decode(\n            strategyData,\n            (ICurvePool, int128, int128, address)\n        );\n        outputToken = IERC20Upgradeable(\n            jToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                ? address(0)\n                : jToken\n        );\n        safeApprove(inputToken, address(curvePool), inputAmount);\n        outputAmount = curvePool.exchange(i, j, inputAmount, 0);\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CurveTriCryptoLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveTriCryptoLpToken.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveTriCryptoLpTokenLiquidator\n * @notice Redeems seized Curve TriCrypto LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveTriCryptoLpTokenLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n        ICurvePool curvePool = ICurvePool(\n            ICurveTriCryptoLpToken(address(inputToken)).minter()\n        );\n        (uint8 curveCoinIndex, address underlying) = abi.decode(\n            strategyData,\n            (uint8, address)\n        );\n        curvePool.remove_liquidity_one_coin(\n            inputAmount,\n            int128(curveCoinIndex),\n            1\n        );\n        outputToken = IERC20Upgradeable(underlying);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/CustomLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CustomLiquidator\n * @notice Redeems seized collateral tokens for the specified output token by calling the specified contract for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CustomLiquidator is IRedemptionStrategy {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Call arbitrary contract\n        address target;\n        bytes memory data;\n        (target, data, outputToken) = abi.decode(\n            strategyData,\n            (address, bytes, IERC20Upgradeable)\n        );\n        target.functionCall(data);\n        outputAmount = address(outputToken) == address(0)\n            ? address(this).balance\n            : outputToken.balanceOf(address(this));\n\n        // Convert to WETH if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n        if (address(outputToken) == address(0)) {\n            WETH.deposit{value: outputAmount}();\n            return (IERC20Upgradeable(address(WETH)), outputAmount);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/DolaStabilizerLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/inverse/Stabilizer.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title DolaStabilizerLiquidator\n * @notice Buys DOLA using DAI and sells DOLA for DAI using the Anchor Stabilizer contract as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract DolaStabilizerLiquidator is IRedemptionStrategy {\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Anchor's Stabilizer contract for DOLA.\n     */\n    Stabilizer public STABILIZER =\n        Stabilizer(0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd);\n\n    /**\n     * @dev Stabilizer's fee denominator.\n     */\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Approve input token to Stabilizer\n        safeApprove(inputToken, address(STABILIZER), inputAmount);\n\n        // Buy or sell depending on if input is synth or reserve\n        address synth = STABILIZER.synth();\n        address reserve = STABILIZER.reserve();\n\n        if (address(inputToken) == reserve) {\n            // Buy DOLA with DAI\n            outputAmount = inputAmount.mul(FEE_DENOMINATOR).div(\n                FEE_DENOMINATOR.add(STABILIZER.buyFee())\n            );\n            STABILIZER.buy(outputAmount);\n            outputToken = IERC20Upgradeable(synth);\n        } else if (address(inputToken) == synth) {\n            // Sell DOLA for DAI\n            STABILIZER.sell(inputAmount);\n            outputToken = IERC20Upgradeable(reserve);\n            outputAmount = outputToken.balanceOf(address(this));\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/ETHMAXYLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/risedle/IRiseTokenVault.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title ETHMAXYLiquidator\n * @notice Redeems ETHMAXY for underlying WETH for use as a step in a liquidation.\n * @author Sri Yantra <sriyantra@rari.capital>, David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ETHMAXYLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Risedle Vault\n     */\n    IRiseTokenVault public rVault =\n        IRiseTokenVault(0xf7EDB240DbF7BBED7D321776AFe87D1FBcFD0A94);\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        safeApprove(inputToken, address(rVault), inputAmount);\n        rVault.removeSupply(inputAmount);\n\n        // convert ETH to WETH\n        outputAmount = address(this).balance;\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/EthRiseLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/risedle/IRiseTokenVault.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title EthRiseLiquidator\n * @notice Redeems EthRise for underlying WETH for use as a step in a liquidation.\n * @author Sri Yantra <sriyantra@rari.capital>, David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract EthRiseLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Risedle Vault\n     */\n    IRiseTokenVault public rVault =\n        IRiseTokenVault(0xf7EDB240DbF7BBED7D321776AFe87D1FBcFD0A94);\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        safeApprove(inputToken, address(rVault), inputAmount);\n        rVault.removeSupply(inputAmount);\n\n        // convert ETH to WETH\n        outputAmount = address(this).balance;\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/GelatoGUniLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../external/gelato/GUniPool.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GelatoGUniLiquidator\n * @notice Exchanges seized GelatoGUni token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GelatoGUniLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Exit GUni pool\n        GUniPool pool = GUniPool(address(inputToken));\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n        (uint256 amount0, uint256 amount1, ) = pool.burn(\n            inputAmount,\n            address(this)\n        );\n\n        // Swap underlying tokens\n        (\n            IUniswapV2Router02 uniswapV2Router,\n            address[] memory swapToken0Path,\n            address[] memory swapToken1Path\n        ) = abi.decode(\n                strategyData,\n                (IUniswapV2Router02, address[], address[])\n            );\n        require(\n            (\n                swapToken0Path.length > 0\n                    ? swapToken0Path[swapToken0Path.length - 1]\n                    : token0\n            ) ==\n                (\n                    swapToken1Path.length > 0\n                        ? swapToken1Path[swapToken1Path.length - 1]\n                        : token1\n                ),\n            \"Output of token0 swap path must equal output of token1 swap path.\"\n        );\n\n        if (\n            swapToken0Path.length > 0 &&\n            swapToken0Path[swapToken0Path.length - 1] != token0\n        ) {\n            safeApprove(\n                IERC20Upgradeable(token0),\n                address(uniswapV2Router),\n                amount0\n            );\n            uniswapV2Router.swapExactTokensForTokens(\n                amount0,\n                0,\n                swapToken0Path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        if (\n            swapToken1Path.length > 0 &&\n            swapToken1Path[swapToken1Path.length - 1] != token1\n        ) {\n            safeApprove(\n                IERC20Upgradeable(token1),\n                address(uniswapV2Router),\n                amount1\n            );\n            uniswapV2Router.swapExactTokensForTokens(\n                amount1,\n                0,\n                swapToken1Path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(\n            swapToken0Path.length > 0\n                ? swapToken0Path[swapToken0Path.length - 1]\n                : token0\n        );\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/GFloorLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/floor/FloorStaking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GFloorLiquidator\n * @notice Redeems gFloor for underlying Floor for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GFloorLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Floor staking contract.\n     */\n    FloorStaking public constant FLOOR_STAKING =\n        FloorStaking(0x759c6De5bcA9ADE8A1a2719a31553c4B7DE02539);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake gFloor (and store output Floor as new collateral)\n        safeApprove(inputToken, address(FLOOR_STAKING), inputAmount);\n        outputAmount = FLOOR_STAKING.unstake(\n            address(this),\n            inputAmount,\n            true,\n            false\n        );\n        outputToken = IERC20Upgradeable(FLOOR_STAKING.gFloor());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/GOhmLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/olympus/OlympusV2Staking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GOhmLiquidator\n * @notice Redeems gOHM for underlying OHM for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GOhmLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev OHM V2 OlympusStaking contract.\n     */\n    OlympusV2Staking public constant OLYMPUS_STAKING =\n        OlympusV2Staking(0xB63cac384247597756545b500253ff8E607a8020);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake gOHM (and store output OHM as new collateral)\n        safeApprove(inputToken, address(OLYMPUS_STAKING), inputAmount);\n        outputAmount = OLYMPUS_STAKING.unstake(\n            address(this),\n            inputAmount,\n            true,\n            false\n        );\n        outputToken = IERC20Upgradeable(OLYMPUS_STAKING.OHM());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/HarvestLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/harvest/IFarmVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title HarvestLiquidator\n * @notice Exchanges seized iFARM token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        IFarmVault vault = IFarmVault(address(inputToken));\n        vault.withdrawAll();\n        outputToken = IERC20Upgradeable(vault.underlying());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/IRedemptionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title IRedemptionStrategy\n * @notice Redeems seized wrapped token collateral for an underlying token for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/MStableLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/mstable/IMasset.sol\";\nimport \"../external/mstable/ISavingsContractV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title MStableLiquidator\n * @notice Redeems mUSD, imUSD, mBTC, and imBTC for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MStableLiquidator is IRedemptionStrategy {\n    /**\n     * @dev mStable imUSD ERC20 token contract object.\n     */\n    IMasset public constant MUSD =\n        IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n    /**\n     * @dev mStable mUSD ERC20 token contract object.\n     */\n    ISavingsContractV2 public constant IMUSD =\n        ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n    /**\n     * @dev mStable mBTC ERC20 token contract object.\n     */\n    IMasset public constant MBTC =\n        IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n    /**\n     * @dev mStable imBTC ERC20 token contract object.\n     */\n    ISavingsContractV2 public constant IMBTC =\n        ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Get output token\n        if (strategyData.length > 0)\n            (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n\n        // TODO: Choose asset to redeem dynamically\n        if (address(inputToken) == address(MUSD)) {\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0))\n                outputToken = IERC20Upgradeable(\n                    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n                ); // Output USDC by default\n            outputAmount = MUSD.redeem(\n                address(outputToken),\n                inputAmount,\n                1,\n                address(this)\n            );\n        } else if (address(inputToken) == address(IMUSD)) {\n            // Redeem imUSD for mUSD\n            uint256 mAssetReturned = IMUSD.redeemCredits(inputAmount);\n            require(\n                mAssetReturned > 0,\n                \"Error calling redeem on mStable savings contract: no mUSD returned.\"\n            );\n\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0))\n                outputToken = IERC20Upgradeable(\n                    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n                ); // Output USDC by default\n            outputAmount = MUSD.redeem(\n                address(outputToken),\n                mAssetReturned,\n                1,\n                address(this)\n            );\n        } else if (address(inputToken) == address(MBTC)) {\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0))\n                outputToken = IERC20Upgradeable(\n                    0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n                ); // Output WBTC by default\n            outputAmount = MBTC.redeem(\n                address(outputToken),\n                inputAmount,\n                1,\n                address(this)\n            );\n        } else if (address(inputToken) == address(IMBTC)) {\n            // Redeem imUSD for mUSD\n            uint256 mAssetReturned = IMBTC.redeemCredits(inputAmount);\n            require(\n                mAssetReturned > 0,\n                \"Error calling redeem on mStable savings contract: no mUSD returned.\"\n            );\n\n            // Redeem mUSD for USDC\n            if (address(outputToken) == address(0))\n                outputToken = IERC20Upgradeable(\n                    0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n                ); // Output WBTC by default\n            outputAmount = MBTC.redeem(\n                address(outputToken),\n                mAssetReturned,\n                1,\n                address(this)\n            );\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/PoolTogetherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/pooltogether/ControlledTokenInterface.sol\";\nimport \"../external/pooltogether/PrizePoolInterface.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title PoolTogetherLiquidator\n * @notice Redeems PoolTogether PcTokens for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PoolTogetherLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem PcToken (and store output as new collateral)\n        ControlledTokenInterface token = ControlledTokenInterface(\n            address(inputToken)\n        );\n        PrizePoolInterface controller = PrizePoolInterface(token.controller());\n        controller.withdrawInstantlyFrom(\n            address(this),\n            inputAmount,\n            address(token),\n            uint256(-1)\n        );\n        outputToken = IERC20Upgradeable(controller.token());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/SOhmLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/olympus/sOlympus.sol\";\nimport \"../external/olympus/OlympusStaking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SOhmLiquidator\n * @notice Redeems sOHM for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SOhmLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake sOHM (and store output OHM as new collateral)\n        sOlympus token = sOlympus(address(inputToken));\n        OlympusStaking staking = OlympusStaking(token.stakingContract());\n        safeApprove(inputToken, address(staking), inputAmount);\n        staking.unstake(inputAmount, false);\n        outputToken = IERC20Upgradeable(staking.OHM());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/StakedFodlLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/fodl/FodlStake.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title StakedFodlLiquidator\n * @notice Redeems staked FODL (xFODL) for underlying FODL for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedFodlLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake sOHM (and store output OHM as new collateral)\n        FodlStake stakedFodl = FodlStake(address(inputToken));\n        outputAmount = stakedFodl.unstake(inputAmount);\n        outputToken = stakedFodl.fodlToken();\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/StakedSdtLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/stakedao/Sanctuary.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title StakedSdtLiquidator\n * @notice Redeems Staked SDT (xSDT) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake xSDT (and store output SDT as new collateral)\n        Sanctuary sanctuary = Sanctuary(address(inputToken));\n        sanctuary.leave(inputAmount);\n        outputToken = IERC20Upgradeable(sanctuary.sdt());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/StakedSpellLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/abracadabra/sSpell.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title StakedSpellLiquidator\n * @notice Redeems Staked Spell Tokens (sSPELL) for underlying SPELL for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSpellLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake sSPELL (and store output SPELL as new collateral)\n        sSpellV1 sSpell = sSpellV1(address(inputToken));\n        require(\n            sSpell.burn(address(this), inputAmount),\n            \"Failed to burn sSPELL.\"\n        );\n        outputToken = IERC20Upgradeable(sSpell.token());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/SushiBarLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/sushi/SushiBar.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SushiBarLiquidator\n * @notice Redeems SushiBar (xSUSHI) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake sOHM (and store output OHM as new collateral)\n        SushiBar sushiBar = SushiBar(address(inputToken));\n        sushiBar.leave(inputAmount);\n        outputToken = IERC20Upgradeable(sushiBar.sushi());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/SynthetixSynthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/synthetix/ISynthetix.sol\";\nimport \"../external/synthetix/ISynth.sol\";\nimport \"../external/synthetix/Proxy.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SynthetixSynthLiquidator\n * @notice Exchanges seized Synthetix Synth token collateral for more common Synthetix Synth tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixSynthLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Synthetix SNX token contract.\n     */\n    ISynthetix public constant SYNTHETIX =\n        ISynthetix(0x97767D7D04Fd0dB0A1a2478DCd4BA85290556B48);\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Swap Synth token for other Synth token (and store output as new collateral)\n        (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n        address inputSynthLogic = Proxy(address(inputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n        address outputSynthLogic = Proxy(address(outputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n        SYNTHETIX.exchange(\n            ISynth(inputSynthLogic).currencyKey(),\n            inputAmount,\n            ISynth(outputSynthLogic).currencyKey()\n        );\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/UniswapLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapLpTokenLiquidator\n * @notice Exchanges seized Uniswap V2 LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapLpTokenLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Exit Uniswap pool\n        IUniswapV2Pair pair = IUniswapV2Pair(address(inputToken));\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n        pair.transfer(address(pair), inputAmount);\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n        // Swap underlying tokens\n        (\n            IUniswapV2Router02 uniswapV2Router,\n            address[] memory swapToken0Path,\n            address[] memory swapToken1Path\n        ) = abi.decode(\n                strategyData,\n                (IUniswapV2Router02, address[], address[])\n            );\n        require(\n            (\n                swapToken0Path.length > 0\n                    ? swapToken0Path[swapToken0Path.length - 1]\n                    : token0\n            ) ==\n                (\n                    swapToken1Path.length > 0\n                        ? swapToken1Path[swapToken1Path.length - 1]\n                        : token1\n                ),\n            \"Output of token0 swap path must equal output of token1 swap path.\"\n        );\n\n        if (\n            swapToken0Path.length > 0 &&\n            swapToken0Path[swapToken0Path.length - 1] != token0\n        ) {\n            safeApprove(\n                IERC20Upgradeable(token0),\n                address(uniswapV2Router),\n                amount0\n            );\n            uniswapV2Router.swapExactTokensForTokens(\n                amount0,\n                0,\n                swapToken0Path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        if (\n            swapToken1Path.length > 0 &&\n            swapToken1Path[swapToken1Path.length - 1] != token1\n        ) {\n            safeApprove(\n                IERC20Upgradeable(token1),\n                address(uniswapV2Router),\n                amount1\n            );\n            uniswapV2Router.swapExactTokensForTokens(\n                amount1,\n                0,\n                swapToken1Path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(\n            swapToken0Path.length > 0\n                ? swapToken0Path[swapToken0Path.length - 1]\n                : token0\n        );\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/UniswapV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV1Exchange.sol\";\nimport \"../external/uniswap/IUniswapV1Factory.sol\";\n\nimport \"../external/aave/IWETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV1Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V1 pool for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV1Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev The V1 Uniswap factory contract.\n     */\n    IUniswapV1Factory private constant UNISWAP_V1_FACTORY =\n        IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n    /**\n     * @dev WETH contract object.\n     */\n    IWETH private constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Get Uniswap exchange\n        IUniswapV1Exchange uniswapV1Exchange = IUniswapV1Exchange(\n            UNISWAP_V1_FACTORY.getExchange(address(inputToken))\n        );\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(uniswapV1Exchange), inputAmount);\n        uniswapV1Exchange.tokenToEthSwapInput(inputAmount, 1, block.timestamp);\n\n        // Get new collateral\n        outputAmount = address(this).balance;\n        WETH.deposit{value: outputAmount}();\n        return (IERC20Upgradeable(address(WETH)), outputAmount);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/UniswapV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV2Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V2 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV2Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Get Uniswap router and path\n        (IUniswapV2Router02 uniswapV2Router, address[] memory swapPath) = abi\n            .decode(strategyData, (IUniswapV2Router02, address[]));\n        require(\n            swapPath.length >= 2 && swapPath[0] == address(inputToken),\n            \"Invalid UniswapLiquidator swap path.\"\n        );\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(uniswapV2Router), inputAmount);\n        uniswapV2Router.swapExactTokensForTokens(\n            inputAmount,\n            0,\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapPath[swapPath.length - 1]);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/UniswapV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/ISwapRouter.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV3Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V3 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3Liquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Get Uniswap router, output token, and fee\n        (ISwapRouter swapRouter, address _outputToken, uint24 fee) = abi.decode(\n            strategyData,\n            (ISwapRouter, address, uint24)\n        );\n\n        // Swap underlying tokens\n        safeApprove(inputToken, address(swapRouter), inputAmount);\n        outputAmount = swapRouter.exactInputSingle(\n            ISwapRouter.ExactInputSingleParams(\n                address(inputToken),\n                _outputToken,\n                fee,\n                address(this),\n                block.timestamp,\n                inputAmount,\n                0,\n                0\n            )\n        );\n        outputToken = IERC20Upgradeable(_outputToken);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/WSTEthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/lido/IWstETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title WSTEthLiquidator\n * @notice Redeems wstETH for underlying stETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthLiquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unwrap wstETH (and store output stETH as new collateral)\n        IWstETH token = IWstETH(address(inputToken));\n        token.unwrap(inputAmount);\n        outputToken = IERC20Upgradeable(token.stETH());\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/XVaultLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"../external/nftx/INFTXInventoryStaking.sol\";\nimport \"../external/nftx/INFTXVaultUpgradeable.sol\";\nimport \"../external/nftx/IXTokenUpgradeable.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title NFTX xVault Liquidator\n * @notice Redeems xVault assets for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract XVaultLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice INFTXInventoryStaking contract address.\n     */\n    INFTXInventoryStaking staking =\n        INFTXInventoryStaking(0x3E135c3E981fAe3383A5aE0d323860a34CfAB893);\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address to,\n        uint256 minAmount\n    ) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Unstake xVault asset (and store output asset as new collateral)\n        IXTokenUpgradeable xToken = IXTokenUpgradeable(address(inputToken));\n        INFTXVaultUpgradeable vault = INFTXVaultUpgradeable(xToken.baseToken());\n        safeApprove(inputToken, address(staking), inputAmount);\n        staking.withdraw(vault.vaultId(), inputAmount);\n        outputToken = IERC20Upgradeable(address(vault));\n        outputAmount = inputAmount;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/YearnYVaultV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV1Liquidator\n * @notice Exchanges seized Yearn yVault V1 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV1Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem yVault token for underlying token (and store output as new collateral)\n        IVault yVault = IVault(address(inputToken));\n        yVault.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(yVault.token());\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/liquidators/YearnYVaultV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVaultV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV2Liquidator\n * @notice Exchanges seized Yearn yVault V2 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV2Liquidator is IRedemptionStrategy {\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(\n        IERC20Upgradeable inputToken,\n        uint256 inputAmount,\n        bytes memory strategyData\n    )\n        external\n        override\n        returns (IERC20Upgradeable outputToken, uint256 outputAmount)\n    {\n        // Redeem yVault token for underlying token (and store output as new collateral)\n        IVaultV2 yVault = IVaultV2(address(inputToken));\n        outputAmount = yVault.withdraw(inputAmount);\n        outputToken = IERC20Upgradeable(yVault.token());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/AlphaHomoraV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/alpha/Bank.sol\";\n\n/**\n * @title AlphaHomoraV1PriceOracle\n * @notice Returns prices the Alpha Homora V1 ibETH ERC20 token.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1PriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Alpha Homora ibETH token contract object.\n     */\n    Bank public constant IBETH =\n        Bank(0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A);\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(CErc20(address(cToken)).underlying() == address(IBETH));\n        return IBETH.totalETH().mul(1e18).div(IBETH.totalSupply());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/AlphaHomoraV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/alpha/ISafeBox.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title AlphaHomoraV2PriceOracle\n * @notice Returns prices from Alpha Homora v2 \"ibTokenV2\" tokens (e.g., ibETHv2, ibDAIv2).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2PriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n     * @param safeBox The SafeBox (or SafeBoxETH) contract address for price retrieval.\n     */\n    function _price(address safeBox) internal view returns (uint256) {\n        // Get the cToken's underlying ibToken's underlying cToken\n        CErc20 underlyingCErc20 = CErc20(ISafeBox(safeBox).cToken());\n\n        // Get the token underlying the underlying cToken\n        address baseToken = underlyingCErc20.underlying();\n\n        // ibTokenV2/ETH price = underlying cToken/ETH price = underlying cToken/token price * base token/ETH price\n        return\n            underlyingCErc20\n                .exchangeRateStored()\n                .mul(BasePriceOracle(msg.sender).price(baseToken))\n                .div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/BadgerPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../external/badger/IXToken.sol\";\nimport \"../external/badger/IDigg.sol\";\nimport \"../external/badger/DiggSett.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title BadgerPriceOracle\n * @notice Returns prices for bDIGG, bBADGER, and ibBTC.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev BADGER/ETH Chainlink price feed.\n     */\n    AggregatorV3Interface public constant BADGER_ETH_FEED =\n        AggregatorV3Interface(0x58921Ac140522867bf50b9E009599Da0CA4A2379);\n\n    /**\n     * @dev bBADGER ERC20 token contract.\n     */\n    IXToken public constant BBADGER =\n        IXToken(0x19D97D8fA813EE2f51aD4B4e04EA08bAf4DFfC28);\n\n    /**\n     * @dev DIGG/BTC Chainlink price feed.\n     */\n    AggregatorV3Interface public constant DIGG_BTC_FEED =\n        AggregatorV3Interface(0x418a6C98CD5B8275955f08F0b8C1c6838c8b1685);\n\n    /**\n     * @dev bDIGG ERC20 token contract.\n     */\n    DiggSett public constant BDIGG =\n        DiggSett(0x7e7E112A68d8D2E221E11047a72fFC1065c38e1a);\n\n    /**\n     * @dev BTC/ETH Chainlink price feed.\n     */\n    AggregatorV3Interface public constant BTC_ETH_FEED =\n        AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8);\n\n    /**\n     * @dev ibBTC ERC20 token contract.\n     */\n    IXToken public constant IBBTC =\n        IXToken(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        if (token == address(BBADGER)) {\n            (\n                uint80 roundId,\n                int256 badgerEthPrice,\n                ,\n                ,\n                uint80 answeredInRound\n            ) = BADGER_ETH_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            return\n                badgerEthPrice > 0\n                    ? uint256(badgerEthPrice)\n                        .mul(BBADGER.getPricePerFullShare())\n                        .div(1e18)\n                    : 0;\n        } else if (token == address(BDIGG)) {\n            (\n                uint80 roundId,\n                int256 diggBtcPrice,\n                ,\n                ,\n                uint80 answeredInRound\n            ) = DIGG_BTC_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (diggBtcPrice < 0) return 0;\n            int256 btcEthPrice;\n            (roundId, btcEthPrice, , , answeredInRound) = BTC_ETH_FEED\n                .latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (btcEthPrice < 0) return 0;\n            uint256 bDiggDiggPrice = IDigg(BDIGG.token()).sharesToFragments(\n                BDIGG.shares().div(BDIGG.totalSupply()).mul(1e18)\n            );\n            // bDIGG/ETH price = (bDIGG/DIGG price / 1e9) * (DIGG/BTC price / 1e8) * BTC/ETH price\n            // Divide by BTC base unit 1e8 (BTC has 8 decimals) and DIGG base unit 1e9 (DIGG has 9 decimals)\n            return\n                bDiggDiggPrice > 0\n                    ? uint256(diggBtcPrice)\n                        .mul(uint256(btcEthPrice))\n                        .div(1e8)\n                        .mul(bDiggDiggPrice)\n                        .div(1e9)\n                    : 0;\n        } else if (token == address(IBBTC)) {\n            (\n                uint80 roundId,\n                int256 btcEthPrice,\n                ,\n                ,\n                uint80 answeredInRound\n            ) = BTC_ETH_FEED.latestRoundData();\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            return\n                btcEthPrice > 0\n                    ? uint256(btcEthPrice).mul(IBBTC.pricePerShare()).div(1e18)\n                    : 0;\n        } else revert(\"Invalid token address passed to BadgerPriceOracle.\");\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/BalancerLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/balancer/BNum.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title BalancerLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice BalancerLpTokenPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract BalancerLpTokenPriceOracle is PriceOracle, BasePriceOracle, BNum {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n     */\n    function _price(address underlying)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        IBalancerPool pool = IBalancerPool(underlying);\n        require(\n            pool.getNumTokens() == 2,\n            \"Balancer pool must have exactly 2 tokens.\"\n        );\n        address[] memory tokens = pool.getFinalTokens();\n        address tokenA = tokens[0];\n        address tokenB = tokens[1];\n        uint256 pxA = BasePriceOracle(msg.sender).price(tokenA);\n        uint256 pxB = BasePriceOracle(msg.sender).price(tokenB);\n        uint8 decimalsA = ERC20Upgradeable(tokenA).decimals();\n        uint8 decimalsB = ERC20Upgradeable(tokenB).decimals();\n        if (decimalsA < 18) pxA = pxA.mul(10**(18 - uint256(decimalsA)));\n        if (decimalsA > 18) pxA = pxA.div(10**(uint256(decimalsA) - 18));\n        if (decimalsB < 18) pxB = pxB.mul(10**(18 - uint256(decimalsB)));\n        if (decimalsB > 18) pxB = pxB.div(10**(uint256(decimalsB) - 18));\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            pool.getBalance(tokenA),\n            pool.getBalance(tokenB),\n            pool.getNormalizedWeight(tokenA),\n            pool.getNormalizedWeight(tokenB),\n            pxA,\n            pxB\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n    }\n\n    /**\n     * @dev Returns fair reserve amounts given spot reserves, weights, and fair prices.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n     * @param resA Reserve of the first asset\n     * @param resB Reserev of the second asset\n     * @param wA Weight of the first asset\n     * @param wB Weight of the second asset\n     * @param pxA Fair price of the first asset\n     * @param pxB Fair price of the second asset\n     */\n    function computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = bdiv(resA, resB);\n        uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = bdiv(r1, r0);\n            fairResA = bmul(resA, bpow(ratio, wB));\n            fairResB = bdiv(resB, bpow(ratio, wA));\n        } else {\n            uint256 ratio = bdiv(r0, r1);\n            fairResA = bdiv(resA, bpow(ratio, wB));\n            fairResB = bmul(resB, bpow(ratio, wA));\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/BalancerStableLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/balancer/IStablePool.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title BalancerStableLpTokenPriceOracle\n * @notice Returns prices for stable pool Balancer Lp tokens with more than 2 assets.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BalancerStableLpTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev bbaUSD BPT token contract.\n     */\n    IStablePool public constant bbaUSD =\n        IStablePool(0x7B50775383d3D6f0215A8F290f2C9e2eEBBEceb2);\n\n    /**\n     * @dev WBTC/renBTC/sBTC BPT token contract.\n     */\n    IStablePool public constant staBTC =\n        IStablePool(0xFeadd389a5c427952D8fdb8057D6C8ba1156cC56);\n\n    /**\n     * @dev WBTC ERC20 token contract.\n     */\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    /**\n     * @dev DAI ERC20 token contract.\n     */\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        if (token == address(bbaUSD)) {\n            return\n                bbaUSD\n                    .getRate()\n                    .mul(BasePriceOracle(msg.sender).price(DAI))\n                    .div(1e18);\n        } else if (token == address(staBTC)) {\n            return\n                staBTC\n                    .getRate()\n                    .mul(BasePriceOracle(msg.sender).price(WBTC))\n                    .div(1e18);\n        } else\n            revert(\n                \"Invalid token address passed to BalancerStableLpTokenPriceOracle.\"\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/BalancerV2TwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/balancer/IBalancerPriceOracle.sol\";\nimport \"../external/balancer/IBalancerV2Vault.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title BalancerV2TwapPriceOracle\n * @notice Stores cumulative prices and returns TWAPs for BalancerV2 assets.\n * @author sri yantra @RariCapital\n */\ncontract BalancerV2TwapPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev BalancerV2 Vault contract address\n     */\n    IBalancerV2Vault constant balancerV2Vault =\n        IBalancerV2Vault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    /**\n     * @dev Ideal TWAP interval in seconds (10 minutes).\n     */\n    uint256 public constant TWAP_PERIOD = 600;\n\n    /**\n     * @dev Returns the price in ETH of `underlying` with 18 decimals of precision.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        IBalancerPriceOracle pool = IBalancerPriceOracle(underlying);\n\n        require(\n            TWAP_PERIOD < pool.getLargestSafeQueryWindow(),\n            \"TWAP period must be less than largest safe query window\"\n        );\n\n        IBalancerPriceOracle.OracleAverageQuery[]\n            memory queries = new IBalancerPriceOracle.OracleAverageQuery[](1);\n\n        queries[0] = IBalancerPriceOracle.OracleAverageQuery({\n            variable: IBalancerPriceOracle.Variable.BPT_PRICE,\n            secs: TWAP_PERIOD,\n            ago: 0\n        });\n\n        uint256[] memory results = pool.getTimeWeightedAverage(queries);\n\n        (address[] memory poolTokens, , ) = balancerV2Vault.getPoolTokens(\n            IBalancerPriceOracle(pool).getPoolId()\n        );\n        return\n            poolTokens[0] == address(WETH)\n                ? results[0]\n                : results[0]\n                    .mul(BasePriceOracle(msg.sender).price(poolTokens[0]))\n                    .div(1e18);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price and return\n        return _price(underlying);\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"../external/compound/IPriceOracle.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle is PriceOracle {\n    /**\n     * @notice Get the price of an underlying asset.\n     * @param underlying The underlying asset to get the price of.\n     * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n     * Zero means the price is unavailable.\n     */\n    function price(address underlying) external view returns (uint256);\n}\n"
    },
    "contracts/rari-fuse/src/oracles/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title PreferredPriceOracle\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n     */\n    mapping(address => AggregatorV3Interface) public ethPriceFeeds;\n\n    /**\n     * @notice Maps ERC20 token addresses to USD-based Chainlink price feed contracts.\n     */\n    mapping(address => AggregatorV3Interface) public usdPriceFeeds;\n\n    /**\n     * @notice Maps ERC20 token addresses to BTC-based Chainlink price feed contracts.\n     */\n    mapping(address => AggregatorV3Interface) public btcPriceFeeds;\n\n    /**\n     * @notice Chainlink ETH/USD price feed contracts.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @notice Chainlink BTC/ETH price feed contracts.\n     */\n    AggregatorV3Interface public constant BTC_ETH_PRICE_FEED =\n        AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8);\n\n    /**\n     * @notice The maxmimum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n     */\n    uint256 public maxSecondsBeforePriceIsStale;\n\n    /**\n     * @dev Constructor to set `maxSecondsBeforePriceIsStale` as well as all Chainlink price feeds.\n     */\n    constructor(uint256 _maxSecondsBeforePriceIsStale) public {\n        // Set maxSecondsBeforePriceIsStale\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n\n        // Set Chainlink ETH price feeds\n        ethPriceFeeds[\n            0x111111111117dC0aa78b770fA6A738034120C302\n        ] = AggregatorV3Interface(0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8); // 1INCH\n        ethPriceFeeds[\n            0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\n        ] = AggregatorV3Interface(0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012); // AAVE\n        ethPriceFeeds[\n            0xD46bA6D942050d489DBd938a2C909A5d5039A161\n        ] = AggregatorV3Interface(0x492575FDD11a0fCf2C6C719867890a7648d526eB); // AMPL\n        ethPriceFeeds[\n            0xa117000000f279D81A1D3cc75430fAA017FA5A2e\n        ] = AggregatorV3Interface(0x8f83670260F8f7708143b836a2a6F11eF0aBac01); // ANT\n        ethPriceFeeds[\n            0x3472A5A71965499acd81997a54BBA8D852C6E53d\n        ] = AggregatorV3Interface(0x58921Ac140522867bf50b9E009599Da0CA4A2379); // BADGER\n        ethPriceFeeds[\n            0xba100000625a3754423978a60c9317c58a424e3D\n        ] = AggregatorV3Interface(0xC1438AA3823A6Ba0C159CfA8D98dF5A994bA120b); // BAL\n        ethPriceFeeds[\n            0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55\n        ] = AggregatorV3Interface(0x0BDb051e10c9718d1C29efbad442E88D38958274); // BAND\n        ethPriceFeeds[\n            0x0D8775F648430679A709E98d2b0Cb6250d2887EF\n        ] = AggregatorV3Interface(0x0d16d4528239e9ee52fa531af613AcdB23D88c94); // BAT\n        ethPriceFeeds[\n            0xB8c77482e45F1F44dE1745F52C74426C631bDD52\n        ] = AggregatorV3Interface(0xc546d2d06144F9DD42815b8bA46Ee7B8FcAFa4a2); // BNB\n        ethPriceFeeds[\n            0x617aeCB6137B5108D1E7D4918e3725C8cEbdB848\n        ] = AggregatorV3Interface(0xc546d2d06144F9DD42815b8bA46Ee7B8FcAFa4a2); // sBNB = BNB\n        ethPriceFeeds[\n            0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C\n        ] = AggregatorV3Interface(0xCf61d1841B178fe82C8895fe60c2EDDa08314416); // BNT\n        ethPriceFeeds[\n            0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n        ] = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8); // WBTC = BTC\n        ethPriceFeeds[\n            0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D\n        ] = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8); // renBTC = BTC\n        ethPriceFeeds[\n            0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\n        ] = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8); // sBTC = BTC\n        ethPriceFeeds[\n            0x0316EB71485b0Ab14103307bf65a021042c6d380\n        ] = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8); // HBTC = BTC\n        ethPriceFeeds[\n            0x4Fabb145d64652a948d72533023f6E7A623C7C53\n        ] = AggregatorV3Interface(0x614715d2Af89E6EC99A233818275142cE88d1Cfd); // BUSD\n        ethPriceFeeds[\n            0x56d811088235F11C8920698a204A5010a788f4b3\n        ] = AggregatorV3Interface(0x8f7C7181Ed1a2BA41cfC3f5d064eF91b67daef66); // BZRX\n        ethPriceFeeds[\n            0xaaAEBE6Fe48E54f431b0C390CfaF0b017d09D42d\n        ] = AggregatorV3Interface(0x75FbD83b4bd51dEe765b2a01e8D3aa1B020F9d33); // CEL\n        ethPriceFeeds[\n            0xc00e94Cb662C3520282E6f5717214004A7f26888\n        ] = AggregatorV3Interface(0x1B39Ee86Ec5979ba5C322b826B3ECb8C79991699); // COMP\n        ethPriceFeeds[\n            0x4688a8b1F292FDaB17E9a90c8Bc379dC1DBd8713\n        ] = AggregatorV3Interface(0x7B6230EF79D5E97C11049ab362c0b685faCBA0C2); // COVER\n        ethPriceFeeds[\n            0x2ba592F78dB6436527729929AAf6c908497cB200\n        ] = AggregatorV3Interface(0x82597CFE6af8baad7c0d441AA82cbC3b51759607); // CREAM\n        ethPriceFeeds[\n            0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b\n        ] = AggregatorV3Interface(0xcA696a9Eb93b81ADFE6435759A29aB4cf2991A96); // CRO\n        ethPriceFeeds[\n            0xD533a949740bb3306d119CC777fa900bA034cd52\n        ] = AggregatorV3Interface(0x8a12Be339B0cD1829b91Adc01977caa5E9ac121e); // CRV\n        ethPriceFeeds[\n            0x6B175474E89094C44Da98b954EedeAC495271d0F\n        ] = AggregatorV3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4); // DAI\n        ethPriceFeeds[\n            0xEd91879919B71bB6905f23af0A68d231EcF87b14\n        ] = AggregatorV3Interface(0xD010e899f7ab723AC93f825cDC5Aa057669557c2); // DMG\n        ethPriceFeeds[\n            0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b\n        ] = AggregatorV3Interface(0x029849bbc0b1d93b85a8b6190e979fd38F5760E2); // DPI\n        ethPriceFeeds[\n            0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c\n        ] = AggregatorV3Interface(0x24D9aB51950F3d62E9144fdC2f3135DAA6Ce8D1B); // ENJ\n        ethPriceFeeds[\n            0x4E15361FD6b4BB609Fa63C81A2be19d873717870\n        ] = AggregatorV3Interface(0x2DE7E4a9488488e0058B95854CC2f7955B35dC9b); // FTM\n        ethPriceFeeds[\n            0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9\n        ] = AggregatorV3Interface(0xF0985f7E2CaBFf22CecC5a71282a89582c382EFE); // FTT\n        ethPriceFeeds[\n            0xc944E90C64B2c07662A292be6244BDf05Cda44a7\n        ] = AggregatorV3Interface(0x17D054eCac33D91F7340645341eFB5DE9009F1C1); // GRT\n        ethPriceFeeds[\n            0x584bC13c7D411c00c01A62e8019472dE68768430\n        ] = AggregatorV3Interface(0xAf5E8D9Cd9fC85725A83BF23C52f1C39A71588a6); // HEGIC\n        ethPriceFeeds[\n            0xdd974D5C2e2928deA5F71b9825b8b646686BD200\n        ] = AggregatorV3Interface(0x656c0544eF4C98A6a98491833A89204Abb045d6b); // KNC\n        ethPriceFeeds[\n            0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44\n        ] = AggregatorV3Interface(0xe7015CCb7E5F788B8c1010FC22343473EaaC3741); // KP3R\n        ethPriceFeeds[\n            0x514910771AF9Ca656af840dff83E8264EcF986CA\n        ] = AggregatorV3Interface(0xDC530D9457755926550b59e8ECcdaE7624181557); // LINK\n        ethPriceFeeds[\n            0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD\n        ] = AggregatorV3Interface(0x160AC928A16C93eD4895C2De6f81ECcE9a7eB7b4); // LRC\n        ethPriceFeeds[\n            0x0F5D2fB29fb7d3CFeE444a200298f468908cC942\n        ] = AggregatorV3Interface(0x82A44D92D6c329826dc557c5E1Be6ebeC5D5FeB9); // MANA\n        ethPriceFeeds[\n            0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2\n        ] = AggregatorV3Interface(0x24551a8Fb2A7211A25a17B1481f043A8a8adC7f2); // MKR\n        ethPriceFeeds[\n            0xec67005c4E498Ec7f55E092bd1d35cbC47C91892\n        ] = AggregatorV3Interface(0xDaeA8386611A157B08829ED4997A8A62B557014C); // MLN\n        ethPriceFeeds[\n            0xa3BeD4E1c75D00fa6f4E5E6922DB7261B5E9AcD2\n        ] = AggregatorV3Interface(0x98334b85De2A8b998Ba844c5521e73D68AD69C00); // MTA\n        ethPriceFeeds[\n            0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671\n        ] = AggregatorV3Interface(0x9cB2A01A7E64992d32A34db7cEea4c919C391f6A); // NMR\n        ethPriceFeeds[\n            0xd26114cd6EE289AccF82350c8d8487fedB8A0C07\n        ] = AggregatorV3Interface(0x57C9aB3e56EE4a83752c181f241120a3DBba06a1); // OMG\n        ethPriceFeeds[\n            0x0258F474786DdFd37ABCE6df6BBb1Dd5dfC4434a\n        ] = AggregatorV3Interface(0xbA9B2a360eb8aBdb677d6d7f27E12De11AA052ef); // ORN\n        ethPriceFeeds[\n            0x8E870D67F660D95d5be530380D0eC0bd388289E1\n        ] = AggregatorV3Interface(0x3a08ebBaB125224b7b6474384Ee39fBb247D2200); // PAX\n        ethPriceFeeds[\n            0x45804880De22913dAFE09f4980848ECE6EcbAf78\n        ] = AggregatorV3Interface(0x9B97304EA12EFed0FAd976FBeCAad46016bf269e); // PAXG\n        ethPriceFeeds[\n            0x408e41876cCCDC0F92210600ef50372656052a38\n        ] = AggregatorV3Interface(0x3147D7203354Dc06D9fd350c7a2437bcA92387a4); // REN\n        ethPriceFeeds[\n            0x221657776846890989a759BA2973e427DfF5C9bB\n        ] = AggregatorV3Interface(0xD4CE430C3b67b3E2F7026D86E7128588629e2455); // REP\n        ethPriceFeeds[\n            0x607F4C5BB672230e8672085532f7e901544a7375\n        ] = AggregatorV3Interface(0x4cba1e1fdc738D0fe8DB3ee07728E2Bc4DA676c6); // RLC\n        ethPriceFeeds[\n            0x3155BA85D5F96b2d030a4966AF206230e46849cb\n        ] = AggregatorV3Interface(0x875D60C44cfbC38BaA4Eb2dDB76A767dEB91b97e); // RUNE\n        ethPriceFeeds[\n            0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\n        ] = AggregatorV3Interface(0x79291A9d692Df95334B1a0B3B4AE6bC606782f8c); // SNX\n        ethPriceFeeds[\n            0x476c5E26a75bd202a9683ffD34359C0CC15be0fF\n        ] = AggregatorV3Interface(0x050c048c9a0CD0e76f166E2539F87ef2acCEC58f); // SRM\n        ethPriceFeeds[\n            0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\n        ] = AggregatorV3Interface(0x8e0b7e6062272B5eF4524250bFFF8e5Bd3497757); // sUSD\n        ethPriceFeeds[\n            0x6B3595068778DD592e39A122f4f5a5cF09C90fE2\n        ] = AggregatorV3Interface(0xe572CeF69f43c2E488b33924AF04BDacE19079cf); // SUSHI\n        ethPriceFeeds[\n            0x0000000000085d4780B73119b644AE5ecd22b376\n        ] = AggregatorV3Interface(0x3886BA987236181D98F2401c507Fb8BeA7871dF2); // TUSD\n        ethPriceFeeds[\n            0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828\n        ] = AggregatorV3Interface(0xf817B69EA583CAFF291E287CaE00Ea329d22765C); // UMA\n        ethPriceFeeds[\n            0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\n        ] = AggregatorV3Interface(0xD6aA3D25116d8dA79Ea0246c4826EB951872e02e); // UNI\n        ethPriceFeeds[\n            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n        ] = AggregatorV3Interface(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4); // USDC\n        ethPriceFeeds[\n            0xdAC17F958D2ee523a2206206994597C13D831ec7\n        ] = AggregatorV3Interface(0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46); // USDT\n        ethPriceFeeds[\n            0xa47c8bf37f92aBed4A126BDA807A7b7498661acD\n        ] = AggregatorV3Interface(0xa20623070413d42a5C01Db2c8111640DD7A5A03a); // UST\n        ethPriceFeeds[\n            0x0d438F3b5175Bebc262bF23753C1E53d03432bDE\n        ] = AggregatorV3Interface(0xe5Dc0A609Ab8bCF15d3f35cFaa1Ff40f521173Ea); // WNXM\n        ethPriceFeeds[\n            0xBd356a39BFf2cAda8E9248532DD879147221Cf76\n        ] = AggregatorV3Interface(0xcEBD2026d3C99F2a7CE028acf372C154aB4638a9); // WOM\n        ethPriceFeeds[\n            0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e\n        ] = AggregatorV3Interface(0x7c5d4F8345e66f68099581Db340cd65B078C41f4); // YFI\n        ethPriceFeeds[\n            0xa1d0E215a23d7030842FC67cE582a6aFa3CCaB83\n        ] = AggregatorV3Interface(0xaaB2f6b45B28E962B3aCd1ee4fC88aEdDf557756); // YFII\n        ethPriceFeeds[\n            0xE41d2489571d322189246DaFA5ebDe1F4699F498\n        ] = AggregatorV3Interface(0x2Da4983a622a8498bb1a21FaE9D8F6C664939962); // ZRX\n\n        // USD price feeds\n        usdPriceFeeds[\n            0xe36E2D3c7c34281FA3bC737950a68571736880A1\n        ] = AggregatorV3Interface(0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55); // sADA = ADA\n        usdPriceFeeds[\n            0xADE00C28244d5CE17D72E40330B1c318cD12B7c3\n        ] = AggregatorV3Interface(0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10); // ADX\n        usdPriceFeeds[\n            0xF48e200EAF9906362BB1442fca31e0835773b8B4\n        ] = AggregatorV3Interface(0x77F9710E7d0A19669A13c055F62cd80d313dF022); // sAUD = AUD\n        usdPriceFeeds[\n            0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d\n        ] = AggregatorV3Interface(0x449d117117838fFA61263B61dA6301AA2a88B13A); // sCHF = CHF\n        usdPriceFeeds[\n            0xfE33ae95A9f0DA8A845aF33516EDc240DCD711d6\n        ] = AggregatorV3Interface(0xFb0cADFEa136E9E343cfb55B863a6Df8348ab912); // sDASH = DASH\n        usdPriceFeeds[\n            0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6\n        ] = AggregatorV3Interface(0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734); // sDOT = DOT\n        usdPriceFeeds[\n            0x88C8Cf3A212c0369698D13FE98Fcb76620389841\n        ] = AggregatorV3Interface(0x10a43289895eAff840E8d45995BBa89f9115ECEe); // sEOS = EOS\n        usdPriceFeeds[\n            0x22602469d704BfFb0936c7A7cfcD18f7aA269375\n        ] = AggregatorV3Interface(0xaEA2808407B7319A31A383B6F8B60f04BCa23cE2); // sETC = ETC\n        usdPriceFeeds[\n            0xD71eCFF9342A5Ced620049e616c5035F1dB98620\n        ] = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1); // sEUR = EUR\n        usdPriceFeeds[\n            0xeF9Cd7882c067686691B6fF49e650b43AFBBCC6B\n        ] = AggregatorV3Interface(0x80070f7151BdDbbB1361937ad4839317af99AE6c); // FNX\n        usdPriceFeeds[\n            0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F\n        ] = AggregatorV3Interface(0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5); // sGBP = GBP\n        usdPriceFeeds[\n            0xFA1a856Cfa3409CFa145Fa4e20Eb270dF3EB21ab\n        ] = AggregatorV3Interface(0xd0935838935349401c73a06FCde9d63f719e84E5); // IOST\n        usdPriceFeeds[\n            0xC14103C2141E842e228FBaC594579e798616ce7A\n        ] = AggregatorV3Interface(0x6AF09DF7563C363B5763b9102712EbeD3b9e859B); // sLTC = LTC\n        usdPriceFeeds[\n            0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0\n        ] = AggregatorV3Interface(0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676); // MATIC\n        usdPriceFeeds[\n            0x4575f41308EC1483f3d399aa9a2826d74Da13Deb\n        ] = AggregatorV3Interface(0xd75AAaE4AF0c398ca13e2667Be57AF2ccA8B5de6); // OXT\n        usdPriceFeeds[\n            0x8CE9137d39326AD0cD6491fb5CC0CbA0e089b6A9\n        ] = AggregatorV3Interface(0xFb0CfD6c19e25DB4a08D8a204a387cEa48Cc138f); // SXP\n        usdPriceFeeds[\n            0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784\n        ] = AggregatorV3Interface(0x26929b85fE284EeAB939831002e1928183a10fb1); // TRU\n        usdPriceFeeds[\n            0xf2E08356588EC5cd9E437552Da87C0076b4970B0\n        ] = AggregatorV3Interface(0xacD0D1A29759CC01E8D925371B72cb2b5610EA25); // sTRX = TRX\n        usdPriceFeeds[\n            0x918dA91Ccbc32B7a6A0cc4eCd5987bbab6E31e6D\n        ] = AggregatorV3Interface(0x1ceDaaB50936881B3e449e47e40A2cDAF5576A4a); // sTSLA = TSLA\n        usdPriceFeeds[\n            0x1c48f86ae57291F7686349F12601910BD8D470bb\n        ] = AggregatorV3Interface(0xfAC81Ea9Dd29D8E9b212acd6edBEb6dE38Cb43Af); // USDK\n        usdPriceFeeds[\n            0x6A22e5e94388464181578Aa7A6B869e00fE27846\n        ] = AggregatorV3Interface(0x379589227b15F1a12195D3f2d90bBc9F31f95235); // sXAG = XAG\n        usdPriceFeeds[\n            0x261EfCdD24CeA98652B9700800a13DfBca4103fF\n        ] = AggregatorV3Interface(0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6); // sXAU = XAU\n        usdPriceFeeds[\n            0x5299d6F7472DCc137D7f3C4BcfBBB514BaBF341A\n        ] = AggregatorV3Interface(0xFA66458Cce7Dd15D8650015c4fce4D278271618F); // sXMR = XMR\n        usdPriceFeeds[\n            0xa2B0fDe6D710e201d0d608e924A484d1A5fEd57c\n        ] = AggregatorV3Interface(0xCed2660c6Dd1Ffd856A5A82C67f3482d88C50b12); // sXRP = XRP\n        usdPriceFeeds[\n            0x2e59005c5c0f0a4D77CcA82653d48b46322EE5Cd\n        ] = AggregatorV3Interface(0x5239a625dEb44bF3EeAc2CD5366ba24b8e9DB63F); // sXTZ = XTZ\n        usdPriceFeeds[\n            0xeABACD844A196D7Faf3CE596edeBF9900341B420\n        ] = AggregatorV3Interface(0x283D433435cFCAbf00263beEF6A362b7cc5ed9f2); // sCEX\n        usdPriceFeeds[\n            0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B\n        ] = AggregatorV3Interface(0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87); // sDEFI\n\n        // BTC price feeds\n        btcPriceFeeds[\n            0x798D1bE841a82a273720CE31c822C61a67a601C3\n        ] = AggregatorV3Interface(0x418a6C98CD5B8275955f08F0b8C1c6838c8b1685); // DIGG\n        btcPriceFeeds[\n            0xF970b8E36e23F7fC3FD752EeA86f8Be8D83375A6\n        ] = AggregatorV3Interface(0xEa0b3DCa635f4a4E77D9654C5c18836EE771566e); // RCN\n    }\n\n    /**\n     * @dev Returns a boolean indicating if a price feed exists for the underlying asset.\n     */\n    function hasPriceFeed(address underlying) external view returns (bool) {\n        return\n            address(ethPriceFeeds[underlying]) != address(0) ||\n            address(usdPriceFeeds[underlying]) != address(0) ||\n            address(btcPriceFeeds[underlying]) != address(0);\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n            return 1e18;\n\n        // Get token/ETH price from Chainlink\n        if (address(ethPriceFeeds[underlying]) != address(0)) {\n            (, int256 tokenEthPrice, , uint256 updatedAt, ) = ethPriceFeeds[\n                underlying\n            ].latestRoundData();\n            if (maxSecondsBeforePriceIsStale > 0)\n                require(\n                    block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale,\n                    \"Token/ETH Chainlink price is stale.\"\n                );\n            return\n                tokenEthPrice >= 0\n                    ? uint256(tokenEthPrice).mul(1e18).div(\n                        10**uint256(ethPriceFeeds[underlying].decimals())\n                    )\n                    : 0;\n        } else if (address(usdPriceFeeds[underlying]) != address(0)) {\n            (, int256 ethUsdPrice, , uint256 updatedAt, ) = ETH_USD_PRICE_FEED\n                .latestRoundData();\n            if (maxSecondsBeforePriceIsStale > 0)\n                require(\n                    block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale,\n                    \"ETH/USD Chainlink price is stale.\"\n                );\n            if (ethUsdPrice <= 0) return 0;\n            int256 tokenUsdPrice;\n            (, tokenUsdPrice, , updatedAt, ) = usdPriceFeeds[underlying]\n                .latestRoundData();\n            if (maxSecondsBeforePriceIsStale > 0)\n                require(\n                    block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale,\n                    \"Token/USD Chainlink price is stale.\"\n                );\n            return\n                tokenUsdPrice >= 0\n                    ? uint256(tokenUsdPrice)\n                        .mul(1e26)\n                        .div(10**uint256(usdPriceFeeds[underlying].decimals()))\n                        .div(uint256(ethUsdPrice))\n                    : 0;\n        } else if (address(btcPriceFeeds[underlying]) != address(0)) {\n            (, int256 btcEthPrice, , uint256 updatedAt, ) = BTC_ETH_PRICE_FEED\n                .latestRoundData();\n            if (maxSecondsBeforePriceIsStale > 0)\n                require(\n                    block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale,\n                    \"BTC/ETH Chainlink price is stale.\"\n                );\n            if (btcEthPrice <= 0) return 0;\n            int256 tokenBtcPrice;\n            (, tokenBtcPrice, , updatedAt, ) = btcPriceFeeds[underlying]\n                .latestRoundData();\n            if (maxSecondsBeforePriceIsStale > 0)\n                require(\n                    block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale,\n                    \"Token/BTC Chainlink price is stale.\"\n                );\n            return\n                tokenBtcPrice >= 0\n                    ? uint256(tokenBtcPrice).mul(uint256(btcEthPrice)).div(\n                        10**uint256(btcPriceFeeds[underlying].decimals())\n                    )\n                    : 0;\n        } else\n            revert(\n                \"No Chainlink price feed found for this underlying ERC20 token.\"\n            );\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price\n        uint256 chainlinkPrice = _price(underlying);\n\n        // Format and return price\n        uint256 underlyingDecimals = uint256(\n            ERC20Upgradeable(underlying).decimals()\n        );\n        return\n            underlyingDecimals <= 18\n                ? uint256(chainlinkPrice).mul(10**(18 - underlyingDecimals))\n                : uint256(chainlinkPrice).div(10**(underlyingDecimals - 18));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/ChainlinkPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title ChainlinkPriceOracleV2\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV2 is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n     */\n    mapping(address => AggregatorV3Interface) public priceFeeds;\n\n    /**\n     * @notice Maps ERC20 token addresses to enums indicating the base currency of the feed.\n     */\n    mapping(address => FeedBaseCurrency) public feedBaseCurrencies;\n\n    /**\n     * @notice Enum indicating the base currency of a Chainlink price feed.\n     */\n    enum FeedBaseCurrency {\n        ETH,\n        USD,\n        BTC\n    }\n\n    /**\n     * @notice Chainlink ETH/USD price feed contracts.\n     */\n    AggregatorV3Interface public ETH_USD_PRICE_FEED;\n\n    /**\n     * @notice Chainlink BTC/ETH price feed contracts.\n     */\n    AggregatorV3Interface public BTC_ETH_PRICE_FEED;\n\n    /**\n     * @dev The administrator of this `MasterPriceOracle`.\n     */\n    address public admin;\n\n    /**\n     * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    bool public canAdminOverwrite;\n\n    /**\n     * @dev Constructor to set admin and canAdminOverwrite.\n     */\n    constructor(address _admin, bool _canAdminOverwrite) public {\n        admin = _admin;\n        canAdminOverwrite = _canAdminOverwrite;\n        ETH_USD_PRICE_FEED = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        );\n        BTC_ETH_PRICE_FEED = AggregatorV3Interface(\n            0xdeb288F737066589598e9214E782fa5A8eD689e8\n        );\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @dev Admin-only function to set price feeds.\n     * @param underlyings Underlying token addresses for which to set price feeds.\n     * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\n     * @param baseCurrency The currency in which `feeds` are based.\n     */\n    function setPriceFeeds(\n        address[] memory underlyings,\n        AggregatorV3Interface[] memory feeds,\n        FeedBaseCurrency baseCurrency\n    ) external onlyAdmin {\n        // Input validation\n        require(\n            underlyings.length > 0 && underlyings.length == feeds.length,\n            \"Lengths of both arrays must be equal and greater than 0.\"\n        );\n\n        // For each token/feed\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n\n            // Check for existing oracle if !canAdminOverwrite\n            if (!canAdminOverwrite)\n                require(\n                    address(priceFeeds[underlying]) == address(0),\n                    \"Admin cannot overwrite existing assignments of price feeds to underlying tokens.\"\n                );\n\n            // Set feed and base currency\n            priceFeeds[underlying] = feeds[i];\n            feedBaseCurrencies[underlying] = baseCurrency;\n        }\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n            return 1e18;\n\n        // Get token/ETH price from Chainlink\n        AggregatorV3Interface feed = priceFeeds[underlying];\n        require(\n            address(feed) != address(0),\n            \"No Chainlink price feed found for this underlying ERC20 token.\"\n        );\n        FeedBaseCurrency baseCurrency = feedBaseCurrencies[underlying];\n\n        if (baseCurrency == FeedBaseCurrency.ETH) {\n            (, int256 tokenEthPrice, , , ) = feed.latestRoundData();\n            return\n                tokenEthPrice >= 0\n                    ? uint256(tokenEthPrice).mul(1e18).div(\n                        10**uint256(feed.decimals())\n                    )\n                    : 0;\n        } else if (baseCurrency == FeedBaseCurrency.USD) {\n            (, int256 ethUsdPrice, , , ) = ETH_USD_PRICE_FEED.latestRoundData();\n            if (ethUsdPrice <= 0) return 0;\n            (, int256 tokenUsdPrice, , , ) = feed.latestRoundData();\n            return\n                tokenUsdPrice >= 0\n                    ? uint256(tokenUsdPrice)\n                        .mul(1e26)\n                        .div(10**uint256(feed.decimals()))\n                        .div(uint256(ethUsdPrice))\n                    : 0;\n        } else if (baseCurrency == FeedBaseCurrency.BTC) {\n            (, int256 btcEthPrice, , , ) = BTC_ETH_PRICE_FEED.latestRoundData();\n            if (btcEthPrice <= 0) return 0;\n            (, int256 tokenBtcPrice, , , ) = feed.latestRoundData();\n            return\n                tokenBtcPrice >= 0\n                    ? uint256(tokenBtcPrice).mul(uint256(btcEthPrice)).div(\n                        10**uint256(feed.decimals())\n                    )\n                    : 0;\n        }\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price\n        uint256 chainlinkPrice = _price(underlying);\n\n        // Format and return price\n        uint256 underlyingDecimals = uint256(\n            ERC20Upgradeable(underlying).decimals()\n        );\n        return\n            underlyingDecimals <= 18\n                ? uint256(chainlinkPrice).mul(10**(18 - underlyingDecimals))\n                : uint256(chainlinkPrice).div(10**(underlyingDecimals - 18));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/ChainlinkPriceOracleV3.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/FeedRegistryInterface.sol\";\nimport \"../external/chainlink/Denominations.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title ChainlinkPriceOracleV3\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV3 is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Official Chainlink feed registry contract.\n     */\n    FeedRegistryInterface feedRegistry =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n            return 1e18;\n\n        // Try token/ETH to get token/ETH\n        try\n            feedRegistry.latestRoundData(underlying, Denominations.ETH)\n        returns (\n            uint80 roundId,\n            int256 tokenEthPrice,\n            uint256,\n            uint256,\n            uint80 answeredInRound\n        ) {\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (tokenEthPrice <= 0) return 0;\n            return\n                uint256(tokenEthPrice).mul(1e18).div(\n                    10 **\n                        uint256(\n                            feedRegistry.decimals(underlying, Denominations.ETH)\n                        )\n                );\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(abi.encodePacked(\"Feed not found\")),\n                \"Attempt to get ETH-based feed failed for unexpected reason.\"\n            );\n        }\n\n        // Try token/USD to get token/ETH\n        try\n            feedRegistry.latestRoundData(underlying, Denominations.USD)\n        returns (\n            uint80 roundId,\n            int256 tokenUsdPrice,\n            uint256,\n            uint256,\n            uint80 answeredInRound\n        ) {\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (tokenUsdPrice <= 0) return 0;\n            int256 ethUsdPrice;\n            (roundId, ethUsdPrice, , , answeredInRound) = feedRegistry\n                .latestRoundData(Denominations.ETH, Denominations.USD);\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (ethUsdPrice <= 0) return 0;\n            return\n                uint256(tokenUsdPrice)\n                    .mul(1e26)\n                    .div(\n                        10 **\n                            uint256(\n                                feedRegistry.decimals(\n                                    underlying,\n                                    Denominations.USD\n                                )\n                            )\n                    )\n                    .div(uint256(ethUsdPrice));\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(abi.encodePacked(\"Feed not found\")),\n                \"Attempt to get USD-based feed failed for unexpected reason.\"\n            );\n        }\n\n        // Try token/BTC to get token/ETH\n        try\n            feedRegistry.latestRoundData(underlying, Denominations.BTC)\n        returns (\n            uint80 roundId,\n            int256 tokenBtcPrice,\n            uint256,\n            uint256,\n            uint80 answeredInRound\n        ) {\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (tokenBtcPrice <= 0) return 0;\n            int256 btcEthPrice;\n            (roundId, btcEthPrice, , , answeredInRound) = feedRegistry\n                .latestRoundData(Denominations.BTC, Denominations.ETH);\n            require(answeredInRound == roundId, \"Chainlink round timed out.\");\n            if (btcEthPrice <= 0) return 0;\n            return\n                uint256(tokenBtcPrice).mul(uint256(btcEthPrice)).div(\n                    10 **\n                        uint256(\n                            feedRegistry.decimals(underlying, Denominations.BTC)\n                        )\n                );\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(abi.encodePacked(\"Feed not found\")),\n                \"Attempt to get BTC-based feed failed for unexpected reason.\"\n            );\n        }\n\n        // Revert if all else fails\n        revert(\n            \"No Chainlink price feed found for this underlying ERC20 token.\"\n        );\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get, format, and return price\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/CurveFactoryLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/curve/ICurveFactoryRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title CurveFactoryLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveFactoryLpTokenPriceOracle is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveFactoryLpTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param pool pool LP token\n     */\n    function _price(address pool) internal view returns (uint256) {\n        address[] memory tokens = underlyingTokens[pool];\n        require(tokens.length != 0, \"LP token is not registered.\");\n        uint256 minPx = uint256(-1);\n        uint256 n = tokens.length;\n\n        for (uint256 i = 0; i < n; i++) {\n            address ulToken = tokens[i];\n            uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n            if (tokenPx < minPx) minPx = tokenPx;\n        }\n\n        require(\n            minPx != uint256(-1),\n            \"No minimum underlying token price found.\"\n        );\n        return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18); // Use min underlying token prices\n    }\n\n    /**\n     * @dev The Curve registry.\n     */\n    ICurveFactoryRegistry public constant registry =\n        ICurveFactoryRegistry(0xB9fC157394Af804a3578134A6585C0dc9cc990d4);\n\n    /**\n     * @dev Maps Curve LP token addresses to underlying token addresses.\n     */\n    mapping(address => address[]) public underlyingTokens;\n\n    /**\n     * @dev Maps Curve LP token addresses to pool addresses.\n     */\n    mapping(address => address) public poolOf;\n\n    /**\n     * @dev Register the pool given LP token address and set the pool info.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param pool pool LP token\n     */\n    function registerPool(address pool) external {\n        uint256 n = registry.get_n_coins(pool);\n        if (n == 0) (n, ) = registry.get_meta_n_coins(pool);\n        require(n != 0, \"n\");\n        address[4] memory tokens = registry.get_coins(pool);\n        for (uint256 i = 0; i < n; i++) {\n            underlyingTokens[pool].push(tokens[i]);\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/CurveLiquidityGaugeV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2PriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLiquidityGaugeV2PriceOracle is a price oracle for Curve LiquidityGaugeV2 tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n * This contract is expected to be called by a `MasterPriceOracle` with the necessary `CurveLpTokenPriceOracle` configured.\n * The price of a Curve LiquidityGaugeV2 token is the same as the price of its underlying Curve LP token.\n */\ncontract CurveLiquidityGaugeV2PriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LiquidityGaugeV2 price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LiquidityGaugeV2/ETH price from Curve, with 18 decimals of precision.\n     * @param gauge The LiquidityGaugeV2 contract address for price retrieval.\n     */\n    function _price(address gauge) internal view returns (uint256) {\n        return\n            BasePriceOracle(msg.sender).price(\n                ICurveLiquidityGaugeV2(gauge).lp_token()\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/CurveLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLpTokenPriceOracle is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveLpTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken The LP token contract address for price retrieval.\n     */\n    function _price(address lpToken) internal view returns (uint256) {\n        address pool = poolOf[lpToken];\n        require(pool != address(0), \"LP token is not registered.\");\n        address[] memory tokens = underlyingTokens[lpToken];\n        uint256 minPx = uint256(-1);\n        uint256 n = tokens.length;\n\n        for (uint256 i = 0; i < n; i++) {\n            address ulToken = tokens[i];\n            uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n            if (tokenPx < minPx) minPx = tokenPx;\n        }\n\n        require(\n            minPx != uint256(-1),\n            \"No minimum underlying token price found.\"\n        );\n        return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18); // Use min underlying token prices\n    }\n\n    /**\n     * @dev The Curve registry.\n     */\n    ICurveRegistry public constant registry =\n        ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c);\n\n    /**\n     * @dev Maps Curve LP token addresses to underlying token addresses.\n     */\n    mapping(address => address[]) public underlyingTokens;\n\n    /**\n     * @dev Maps Curve LP token addresses to pool addresses.\n     */\n    mapping(address => address) public poolOf;\n\n    /**\n     * @dev Register the pool given LP token address and set the pool info.\n     * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken LP token to find the corresponding pool.\n     */\n    function registerPool(address lpToken) external {\n        address pool = poolOf[lpToken];\n        require(pool == address(0), \"This LP token is already registered.\");\n        pool = registry.get_pool_from_lp_token(lpToken);\n        require(\n            pool != address(0),\n            \"No corresponding pool found for this LP token in the Curve registry.\"\n        );\n        poolOf[lpToken] = pool;\n        uint256 n = registry.get_n_coins(pool);\n        address[8] memory tokens = registry.get_coins(pool);\n        for (uint256 i = 0; i < n; i++)\n            underlyingTokens[lpToken].push(tokens[i]);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/CurveTriCryptoLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../external/curve/ICurveTriCryptoLpTokenOracle.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title CurveTriCryptoLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveTriCryptoLpTokenPriceOracle is a price oracle for Curve TriCrypto LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveTriCryptoLpTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Official TriCrypto LP token price oracle deployed by Curve.\n     */\n    ICurveTriCryptoLpTokenOracle public constant SOURCE_ORACLE =\n        ICurveTriCryptoLpTokenOracle(\n            0xE8b2989276E2Ca8FDEA2268E3551b2b4B2418950\n        );\n\n    /**\n     * @dev Chainlink ETH/USD price feed contract.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @notice Get the LiquidityGaugeV2 price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair TriCrypto LP token/ETH price from Curve, with 18 decimals of precision.\n     * @param gauge The LiquidityGaugeV2 contract address for price retrieval.\n     */\n    function _price(address gauge) internal view returns (uint256) {\n        (\n            uint80 roundId,\n            int256 ethUsdPrice,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = ETH_USD_PRICE_FEED.latestRoundData();\n        require(answeredInRound == roundId, \"Chainlink round timed out.\");\n        return\n            uint256(SOURCE_ORACLE.lp_price()).mul(1e8).div(\n                uint256(ethUsdPrice)\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/CvxFXSPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/curve/ICurveMinter.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title CvxFXSPriceOracle\n * @notice Returns prices for cvxFXS and cvxFXSFXS LP tokens\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CvxFXSPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice FXS token address.\n     */\n    address public FXS = 0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0;\n\n    /**\n     * @notice cvxFXS token address.\n     */\n    address public cvxFXS = 0xFEEf77d3f69374f66429C91d732A244f074bdf74;\n\n    /**\n     * @notice Curve cvxFXSFXS LP token address.\n     */\n    address public cvxFXSFXS = 0xF3A43307DcAFa93275993862Aae628fCB50dC768;\n\n    /**\n     * @notice Curve cvxFXSFXS Minter contract address.\n     */\n    ICurveMinter public cvxFXSFXSMinter =\n        ICurveMinter(0xd658A338613198204DCa1143Ac3F01A722b5d94A);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        if (token == cvxFXS) {\n            // check if exchange rate < 1\n            return\n                cvxFXSFXSMinter.price_oracle() < 1e18\n                    ? cvxFXSFXSMinter\n                        .price_oracle()\n                        .mul(BasePriceOracle(msg.sender).price(FXS))\n                        .div(1e18)\n                    : BasePriceOracle(msg.sender).price(FXS);\n        } else if (token == cvxFXSFXS) {\n            return\n                cvxFXSFXSMinter\n                    .lp_price()\n                    .mul(BasePriceOracle(msg.sender).price(FXS))\n                    .div(1e18);\n        } else revert(\"Invalid token passed to CvxFXSPriceOracle\");\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/ETHMAXYPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/rari/IUniswapV3Twap.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title ETHMAXYPriceOracle\n * @notice Returns prices for ETHMAXY with price deviation guard\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ETHMAXYPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice ETHMAXY token address.\n     */\n    address public ETHMAXY = 0x0FE20E0Fa9C78278702B05c333Cc000034bb69E2;\n\n    /**\n     * @notice Uni-v3 WETH oracle 500 fee tier address\n     */\n    IUniswapV3Twap univ3twap =\n        IUniswapV3Twap(0x35d45e98E3C3696A40645A4E98Ca6023EF135E04);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == ETHMAXY,\n            \"Invalid token passed to ETHMAXYPriceOracle.\"\n        );\n        uint256 price = univ3twap.price(token);\n        require(\n            price <= 1.2e18 && price >= .95e18,\n            \"ETHMAXY price out of bounds.\"\n        );\n        return price;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/FixedEthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title FixedEthPriceOracle\n * @notice Returns fixed prices of 1 ETH for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedEthPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return 1e18;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Format and return price\n        return\n            uint256(1e36).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/FixedEurPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title FixedEurPriceOracle\n * @notice Returns fixed prices of 1 EUR in terms of ETH for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedEurPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Chainlink ETH/USD price feed contracts.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @notice Chainlink EUR/USD price feed contracts.\n     */\n    AggregatorV3Interface public constant EUR_USD_PRICE_FEED =\n        AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Get ETH/USD price from Chainlink\n        (\n            uint80 roundId,\n            int256 ethUsdPrice,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = ETH_USD_PRICE_FEED.latestRoundData();\n        require(answeredInRound == roundId, \"Chainlink round timed out.\");\n        if (ethUsdPrice <= 0) return 0;\n\n        // Get EUR/USD price from Chainlink\n        int256 eurUsdPrice;\n        (roundId, eurUsdPrice, , , answeredInRound) = EUR_USD_PRICE_FEED\n            .latestRoundData();\n        require(answeredInRound == roundId, \"Chainlink round timed out.\");\n        if (eurUsdPrice <= 0) return 0;\n\n        // Return EUR/ETH price = EUR/USD price / ETH/USD price\n        return uint256(eurUsdPrice).mul(1e18).div(uint256(ethUsdPrice));\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Format and return price\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/FixedTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title FixedTokenPriceOracle\n * @notice Returns token prices using the prices for another token.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev The token to base prices on.\n     */\n    address public immutable baseToken;\n\n    /**\n     * @dev Sets the token to base prices on.\n     */\n    constructor(address _baseToken) public {\n        baseToken = _baseToken;\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        return BasePriceOracle(msg.sender).price(baseToken);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/FixedUsdPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title FixedUsdPriceOracle\n * @notice Returns fixed prices of 1 USD in terms of ETH for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedUsdPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Chainlink ETH/USD price feed contracts.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Get ETH/USD price from Chainlink\n        (\n            uint80 roundId,\n            int256 ethUsdPrice,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = ETH_USD_PRICE_FEED.latestRoundData();\n        require(answeredInRound == roundId, \"Chainlink round timed out.\");\n        if (ethUsdPrice <= 0) return 0;\n\n        // Return USD/ETH price = 1e26 / ETH/USD price\n        return uint256(1e26).div(uint256(ethUsdPrice));\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Format and return price\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/GAlcxPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/alchemix/IgALCX.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title GAlcxPriceOracle\n * @notice Returns prices for gALCX based on the ALCX price and the exchange rate.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GAlcxPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice gALCX token address.\n     */\n    IgALCX public gALCX = IgALCX(0x93Dede06AE3B5590aF1d4c111BC54C3f717E4b35);\n\n    /**\n     * @notice ALCX token address.\n     */\n    address public ALCX = 0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(gALCX),\n            \"Invalid token passed to GAlcxPriceOracle.\"\n        );\n        return\n            gALCX\n                .exchangeRate()\n                .mul(BasePriceOracle(msg.sender).price(ALCX))\n                .div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/GelatoGUniPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/gelato/GUniPool.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title GelatoGUniPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice GelatoGUniPriceOracle is a price oracle for Gelato G-UNI wrapped Uniswap V3 LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract GelatoGUniPriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH contract address.\n     */\n    address private constant WETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external view returns (uint256) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n     */\n    function _price(address token) internal view virtual returns (uint256) {\n        // Get G-UNI pool and underlying tokens\n        GUniPool pool = GUniPool(token);\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n\n        // Get underlying token prices\n        uint256 p0 = token0 == WETH_ADDRESS\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(token0);\n        require(\n            p0 > 0,\n            \"Failed to retrieve price for G-UNI underlying token0.\"\n        );\n        uint256 p1 = token1 == WETH_ADDRESS\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(token1);\n        require(\n            p1 > 0,\n            \"Failed to retrieve price for G-UNI underlying token1.\"\n        );\n\n        // Get conversion factors\n        uint256 dec0 = uint256(ERC20Upgradeable(token0).decimals());\n        require(\n            dec0 <= 18,\n            \"G-UNI underlying token0 decimals greater than 18.\"\n        );\n        uint256 to18Dec0 = 10**(18 - dec0);\n        uint256 dec1 = uint256(ERC20Upgradeable(token1).decimals());\n        require(\n            dec1 <= 18,\n            \"G-UNI underlying token1 decimals greater than 18.\"\n        );\n        uint256 to18Dec1 = 10**(18 - dec1);\n\n        // Get square root of underlying token prices\n        // token1/token0\n        // = (p0 / 10^dec0) / (p1 / 10^dec1)\n        // = (p0 * 10^dec1) / (p1 * 10^dec0)\n        // [From Uniswap's definition] sqrtPriceX96\n        // = sqrt(token1/token0) * 2^96\n        // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^96\n        // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^48 * 2^48\n        // = sqrt((p0 * 10^dec1 * 2^96) / (p1 * 10^dec0)) * 2^48\n        uint160 sqrtPriceX96 = toUint160(\n            sqrt(p0.mul(10**dec1).mul(1 << 96).div(p1.mul(10**dec0))) << 48\n        );\n\n        // Get balances of the tokens in the pool given fair underlying token prices\n        (uint256 r0, uint256 r1) = pool.getUnderlyingBalancesAtPrice(\n            sqrtPriceX96\n        );\n        require(\n            r0 > 0 || r1 > 0,\n            \"G-UNI underlying token balances not both greater than 0.\"\n        );\n\n        // Add the total value of each token together and divide by the totalSupply to get the unit price\n        return\n            p0.mul(r0.mul(to18Dec0)).add(p1.mul(r1.mul(to18Dec1))).div(\n                ERC20Upgradeable(token).totalSupply()\n            );\n    }\n\n    /**\n     * @dev Fast square root function.\n     * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n     * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n     */\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n\n    /**\n     * @dev Converts uint256 to uint160.\n     */\n    function toUint160(uint256 x) internal pure returns (uint160 z) {\n        require(\n            (z = uint160(x)) == x,\n            \"Overflow when converting uint256 into uint160.\"\n        );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/GFloorPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/floor/IgFloor.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title GFloorPriceOracle\n * @notice Returns prices for gFloor based on the Floor price and the gFloor index.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GFloorPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice gFloor token address.\n     */\n    IgFloor public gFloor = IgFloor(0xb1Cc59Fc717b8D4783D41F952725177298B5619d);\n\n    /**\n     * @notice Floor token address.\n     */\n    address public Floor = 0xf59257E961883636290411c11ec5Ae622d19455e;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(gFloor),\n            \"Invalid token passed to gFloorPriceOracle.\"\n        );\n        return\n            gFloor.index().mul(BasePriceOracle(msg.sender).price(Floor)).div(\n                1e9\n            ); // 1e9 = Floor base unit and therefore also gFloor/Floor index base unit\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/GOhmPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/olympus/IgOHM.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title GOhmPriceOracle\n * @notice Returns prices for gOHM based on the OHM (v2) price and the gOHM index.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GOhmPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice gOHM token address.\n     */\n    IgOHM public GOHM = IgOHM(0x0ab87046fBb341D058F17CBC4c1133F25a20a52f);\n\n    /**\n     * @notice OHM (v2) token address.\n     */\n    address public OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(GOHM),\n            \"Invalid token passed to GOhmPriceOracle.\"\n        );\n        return\n            GOHM.index().mul(BasePriceOracle(msg.sender).price(OHM)).div(1e9); // 1e9 = OHM base unit and therefore also gOHM/OHM index base unit\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/HarvestPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/harvest/IFarmVault.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title HarvestPriceOracle\n * @notice Returns prices for iFARM.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        IFarmVault vault = IFarmVault(token);\n        return\n            BasePriceOracle(msg.sender)\n                .price(vault.underlying())\n                .mul(vault.getPricePerFullShare())\n                .div(10**uint256(ERC20Upgradeable(token).decimals()));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/Keep3rPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/keep3r/Keep3rV1Oracle.sol\";\n\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title Keep3rPriceOracle\n * @notice Returns prices from `Keep3rV1Oracle` or `SushiswapV1Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n     */\n    constructor(bool sushiSwap) public {\n        Keep3rV1Oracle _rootOracle = Keep3rV1Oracle(\n            sushiSwap\n                ? 0xf67Ab1c914deE06Ba0F264031885Ea7B276a7cDa\n                : 0x73353801921417F465377c8d898c6f4C0270282C\n        );\n        rootOracle = _rootOracle;\n        uniswapV2Factory = IUniswapV2Factory(_rootOracle.factory());\n    }\n\n    /**\n     * @dev Keep3rV1Oracle token contract object.\n     */\n    Keep3rV1Oracle public immutable rootOracle;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev UniswapV2Factory contract address.\n     */\n    IUniswapV2Factory public immutable uniswapV2Factory;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Maximum TWAP interval.\n     */\n    uint256 public constant MAX_TWAP_TIME = 60 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint256) {\n        uint256 length = rootOracle.observationLength(pair);\n        require(length > 0, \"no length-1 observation\");\n        (uint256 lastTime, uint256 lastPx0Cumu, ) = rootOracle.observations(\n            pair,\n            length - 1\n        );\n        if (lastTime > now - MIN_TWAP_TIME) {\n            require(length > 1, \"no length-2 observation\");\n            (lastTime, lastPx0Cumu, ) = rootOracle.observations(\n                pair,\n                length - 2\n            );\n        }\n        uint256 elapsedTime = now - lastTime;\n        require(\n            elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME,\n            \"bad TWAP time\"\n        );\n        uint256 currPx0Cumu = currentPx0Cumu(pair);\n        return (currPx0Cumu - lastPx0Cumu) / (now - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint256) {\n        uint256 length = rootOracle.observationLength(pair);\n        require(length > 0, \"no length-1 observation\");\n        (uint256 lastTime, , uint256 lastPx1Cumu) = rootOracle.observations(\n            pair,\n            length - 1\n        );\n        if (lastTime > now - MIN_TWAP_TIME) {\n            require(length > 1, \"no length-2 observation\");\n            (lastTime, , lastPx1Cumu) = rootOracle.observations(\n                pair,\n                length - 2\n            );\n        }\n        uint256 elapsedTime = now - lastTime;\n        require(\n            elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME,\n            \"bad TWAP time\"\n        );\n        uint256 currPx1Cumu = currentPx1Cumu(pair);\n        return (currPx1Cumu - lastPx1Cumu) / (now - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair)\n        internal\n        view\n        returns (uint256 px0Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != now) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair)\n        internal\n        view\n        returns (uint256 px1Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH_ADDRESS) return 1e18;\n\n        // Call Keep3r for ERC20/ETH price and return\n        address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return\n            (underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair))\n                .div(2**56)\n                .mul(baseUnit)\n                .div(2**56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/Keep3rV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/keep3r/Keep3rV2OracleFactory.sol\";\nimport \"../external/keep3r/Keep3rV2Oracle.sol\";\n\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title Keep3rV2PriceOracle\n * @notice Returns prices from `Keep3rV2Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rV2PriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n     */\n    constructor(address _keep3rV2OracleFactory, address _uniswapV2Factory)\n        public\n    {\n        keep3rV2OracleFactory = Keep3rV2OracleFactory(_keep3rV2OracleFactory);\n        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Factory);\n    }\n\n    /**\n     * @dev Keep3rV1Oracle token contract object.\n     */\n    Keep3rV2OracleFactory public immutable keep3rV2OracleFactory;\n\n    /**\n     * @dev UniswapV2Factory contract object.\n     */\n    IUniswapV2Factory public immutable uniswapV2Factory;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint256) {\n        Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n        uint256 length = feed.length();\n        require(length > 0, \"no length-1 observation\");\n        (uint256 lastTime, uint256 lastPx0CumuCompressed, ) = feed.observations(\n            length - 1\n        );\n        if (lastTime > now - MIN_TWAP_TIME) {\n            require(length > 1, \"no length-2 observation\");\n            (lastTime, lastPx0CumuCompressed, ) = feed.observations(length - 2);\n        }\n        uint256 elapsedTime = now - lastTime;\n        require(\n            elapsedTime >= MIN_TWAP_TIME,\n            \"no TWAP satisfying MIN_TWAP_TIME\"\n        );\n        uint256 lastPx0Cumu = (uint256(lastPx0CumuCompressed) * (2**112)) /\n            1e18;\n        uint256 currPx0Cumu = currentPx0Cumu(pair);\n        return (currPx0Cumu - lastPx0Cumu) / (now - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint256) {\n        Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n        uint256 length = feed.length();\n        require(length > 0, \"no length-1 observation\");\n        (uint256 lastTime, , uint112 lastPx1CumuCompressed) = feed.observations(\n            length - 1\n        );\n        if (lastTime > now - MIN_TWAP_TIME) {\n            require(length > 1, \"no length-2 observation\");\n            (lastTime, , lastPx1CumuCompressed) = feed.observations(length - 2);\n        }\n        uint256 elapsedTime = now - lastTime;\n        require(\n            elapsedTime >= MIN_TWAP_TIME,\n            \"no TWAP satisfying MIN_TWAP_TIME\"\n        );\n        uint256 lastPx1Cumu = (uint256(lastPx1CumuCompressed) * (2**112)) /\n            1e18;\n        uint256 currPx1Cumu = currentPx1Cumu(pair);\n        return (currPx1Cumu - lastPx1Cumu) / (now - lastTime); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair)\n        internal\n        view\n        returns (uint256 px0Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != now) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair)\n        internal\n        view\n        returns (uint256 px1Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH_ADDRESS) return 1e18;\n\n        // Call Keep3r for ERC20/ETH price and return\n        address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return\n            (underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair))\n                .div(2**56)\n                .mul(baseUnit)\n                .div(2**56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, PriceOracle, BasePriceOracle {\n    /**\n     * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n     */\n    mapping(address => PriceOracle) public oracles;\n\n    /**\n     * @dev Default/fallback `PriceOracle`.\n     */\n    PriceOracle public defaultOracle;\n\n    /**\n     * @dev The administrator of this `MasterPriceOracle`.\n     */\n    address public admin;\n\n    /**\n     * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    bool internal noAdminOverwrite;\n\n    /**\n     * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function canAdminOverwrite() external view returns (bool) {\n        return !noAdminOverwrite;\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Event emitted when the default oracle is changed.\n     */\n    event NewDefaultOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev Event emitted when an underlying token's oracle is changed.\n     */\n    event NewOracle(address underlying, address oldOracle, address newOracle);\n\n    /**\n     * @dev Constructor to initialize state variables.\n     * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n     * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n     * @param _defaultOracle The default `PriceOracle` contract to use.\n     * @param _admin The admin who can assign oracles to underlying tokens.\n     * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function initialize(\n        address[] memory underlyings,\n        PriceOracle[] memory _oracles,\n        PriceOracle _defaultOracle,\n        address _admin,\n        bool _canAdminOverwrite\n    ) external initializer {\n        // Input validation\n        require(\n            underlyings.length == _oracles.length,\n            \"Lengths of both arrays must be equal.\"\n        );\n\n        // Initialize state variables\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            PriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, address(0), address(newOracle));\n        }\n\n        defaultOracle = _defaultOracle;\n        admin = _admin;\n        noAdminOverwrite = !_canAdminOverwrite;\n    }\n\n    /**\n     * @dev Sets `_oracles` for `underlyings`.\n     */\n    function add(\n        address[] calldata underlyings,\n        PriceOracle[] calldata _oracles\n    ) external onlyAdmin {\n        // Input validation\n        require(\n            underlyings.length > 0 && underlyings.length == _oracles.length,\n            \"Lengths of both arrays must be equal and greater than 0.\"\n        );\n\n        // Assign oracles to underlying tokens\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            address oldOracle = address(oracles[underlying]);\n            if (noAdminOverwrite)\n                require(\n                    oldOracle == address(0),\n                    \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n                );\n            PriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, oldOracle, address(newOracle));\n        }\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function setDefaultOracle(PriceOracle newOracle) external onlyAdmin {\n        PriceOracle oldOracle = defaultOracle;\n        defaultOracle = newOracle;\n        emit NewDefaultOracle(address(oldOracle), address(newOracle));\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying ERC20 token address\n        address underlying = address(CErc20(address(cToken)).underlying());\n\n        // Return 1e18 for ETH\n        if (underlying == address(0)) return 1e18;\n\n        // Get underlying price from assigned oracle\n        PriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0))\n            return oracle.getUnderlyingPrice(cToken);\n        if (address(defaultOracle) != address(0))\n            return defaultOracle.getUnderlyingPrice(cToken);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n\n    /**\n     * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get underlying price from assigned oracle\n        PriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0))\n            return BasePriceOracle(address(oracle)).price(underlying);\n        if (address(defaultOracle) != address(0))\n            return BasePriceOracle(address(defaultOracle)).price(underlying);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/MStablePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/mstable/IMasset.sol\";\nimport \"../external/mstable/ISavingsContractV2.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title MStablePriceOracle\n * @notice Returns prices for the mStable imUSD ERC20 token.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital>\n */\ncontract MStablePriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev mStable mUSD ERC20 token contract object.\n     */\n    IMasset public constant MUSD =\n        IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n    /**\n     * @dev mStable imUSD ERC20 token contract object.\n     */\n    ISavingsContractV2 public constant IMUSD =\n        ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n    /**\n     * @dev mStable mBTC ERC20 token contract object.\n     */\n    IMasset public constant MBTC =\n        IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n    /**\n     * @dev mStable imBTC ERC20 token contract object.\n     */\n    ISavingsContractV2 public constant IMBTC =\n        ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        if (underlying == address(MUSD)) return getMAssetEthPrice(MUSD);\n        else if (underlying == address(IMUSD))\n            return IMUSD.exchangeRate().mul(getMAssetEthPrice(MUSD)).div(1e18);\n        else if (underlying == address(MBTC)) return getMAssetEthPrice(MBTC);\n        else if (underlying == address(IMBTC))\n            return IMBTC.exchangeRate().mul(getMAssetEthPrice(MBTC)).div(1e18);\n        else revert(\"Invalid token passed to MStablePriceOracle.\");\n    }\n\n    /**\n     * @dev Returns the price in ETH of the mAsset using `msg.sender` as a root price oracle for underlying bAssets.\n     */\n    function getMAssetEthPrice(IMasset mAsset) internal view returns (uint256) {\n        (\n            IMasset.BassetPersonal[] memory bAssetPersonal,\n            IMasset.BassetData[] memory bAssetData\n        ) = mAsset.getBassets();\n        uint256 underlyingValueInEthScaled = 0;\n        for (uint256 i = 0; i < bAssetData.length; i++)\n            underlyingValueInEthScaled = underlyingValueInEthScaled.add(\n                uint256(bAssetData[i].vaultBalance)\n                    .mul(uint256(bAssetData[i].ratio))\n                    .div(1e8)\n                    .mul(\n                        BasePriceOracle(msg.sender).price(\n                            bAssetPersonal[i].addr\n                        )\n                    )\n            );\n        return\n            underlyingValueInEthScaled.div(\n                ERC20Upgradeable(address(mAsset)).totalSupply()\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/PreferredPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\nimport \"./MasterPriceOracle.sol\";\nimport \"./ChainlinkPriceOracleV2.sol\";\n\n/**\n * @title PreferredPriceOracle\n * @notice Returns prices from MasterPriceOracle, ChainlinkPriceOracleV2, or prices from a tertiary oracle (in order of preference).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PreferredPriceOracle is PriceOracle, BasePriceOracle {\n    /**\n     * @dev The primary `MasterPriceOracle`.\n     */\n    MasterPriceOracle public masterOracle;\n\n    /**\n     * @dev The secondary `ChainlinkPriceOracleV2`.\n     */\n    ChainlinkPriceOracleV2 public chainlinkOracleV2;\n\n    /**\n     * @dev The tertiary `PriceOracle`.\n     */\n    PriceOracle public tertiaryOracle;\n\n    /**\n     * @dev Constructor to set the primary `MasterPriceOracle`, the secondary `ChainlinkPriceOracleV2`, and the tertiary `PriceOracle`.\n     */\n    constructor(\n        MasterPriceOracle _masterOracle,\n        ChainlinkPriceOracleV2 _chainlinkOracleV2,\n        PriceOracle _tertiaryOracle\n    ) public {\n        require(\n            address(_masterOracle) != address(0),\n            \"MasterPriceOracle not set.\"\n        );\n        require(\n            address(_chainlinkOracleV2) != address(0),\n            \"ChainlinkPriceOracleV2 not set.\"\n        );\n        require(\n            address(_tertiaryOracle) != address(0),\n            \"Tertiary price oracle not set.\"\n        );\n        masterOracle = _masterOracle;\n        chainlinkOracleV2 = _chainlinkOracleV2;\n        tertiaryOracle = _tertiaryOracle;\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n            return 1e18;\n\n        // Try to get MasterPriceOracle price\n        if (address(masterOracle.oracles(underlying)) != address(0))\n            return masterOracle.price(underlying);\n\n        // Try to get ChainlinkPriceOracleV2 price\n        if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0))\n            return chainlinkOracleV2.price(underlying);\n\n        // Otherwise, get price from tertiary oracle\n        return BasePriceOracle(address(tertiaryOracle)).price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = address(CErc20(address(cToken)).underlying());\n\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n            return 1e18;\n\n        // Try to get MasterPriceOracle price\n        if (address(masterOracle.oracles(underlying)) != address(0))\n            return masterOracle.getUnderlyingPrice(cToken);\n\n        // Try to get ChainlinkPriceOracleV2 price\n        if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0))\n            return chainlinkOracleV2.getUnderlyingPrice(cToken);\n\n        // Otherwise, get price from tertiary oracle\n        return tertiaryOracle.getUnderlyingPrice(cToken);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/RecursivePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\nimport \"../external/compound/IComptroller.sol\";\n\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\n/**\n * @title RecursivePriceOracle\n * @notice Returns prices from other cTokens (from Compound or from Fuse).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract RecursivePriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Compound Comptroller address.\n     */\n    address public constant COMPOUND_COMPTROLLER =\n        0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    /**\n     * @dev Cream Comptroller address.\n     */\n    address public constant CREAM_COMPTROLLER =\n        0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\n\n    /**\n     * @dev Chainlink ETH/USD price feed contract.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get cToken's underlying cToken\n        CToken underlying = CToken(CErc20(address(cToken)).underlying());\n\n        // Get Comptroller\n        Comptroller comptroller = Comptroller(underlying.comptroller());\n\n        // Check for Compound Comptroller\n        if (address(comptroller) == COMPOUND_COMPTROLLER) {\n            // If cETH, return cETH/ETH exchange rate\n            if (compareStrings(underlying.symbol(), \"cETH\"))\n                return underlying.exchangeRateStored();\n\n            // Compound cErc20: cToken/token price * token/USD price / ETH/USD price = cToken/ETH price\n            (, int256 usdPerEth, , , ) = ETH_USD_PRICE_FEED.latestRoundData();\n            if (usdPerEth <= 0) return 0;\n            return\n                underlying\n                    .exchangeRateStored()\n                    .mul(comptroller.oracle().getUnderlyingPrice(underlying))\n                    .div(uint256(usdPerEth).mul(1e10));\n        }\n\n        // If cETH, return cETH/ETH exchange rate\n        if (address(comptroller) == CREAM_COMPTROLLER) {\n            // Cream\n            if (compareStrings(underlying.symbol(), \"cETH\"))\n                return underlying.exchangeRateStored();\n        } else if (underlying.isCEther()) {\n            // Fuse\n            return underlying.exchangeRateStored();\n        }\n\n        // Fuse cTokens: cToken/token price * token/ETH price = cToken/ETH price\n        return\n            underlying\n                .exchangeRateStored()\n                .mul(comptroller.oracle().getUnderlyingPrice(underlying))\n                .div(1e18);\n    }\n\n    /**\n     * @dev Compares two strings.\n     */\n    function compareStrings(string memory a, string memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return (keccak256(abi.encodePacked((a))) ==\n            keccak256(abi.encodePacked((b))));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/REthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/rocket/IrETH.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title REthPriceOracle\n * @notice Returns prices for rETH based on the rETH exchange rate.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract REthPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice rETH token address.\n     */\n    IrETH public rETH = IrETH(0xae78736Cd615f374D3085123A210448E74Fc6393);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(rETH),\n            \"Invalid token passed to rEthPriceOracle.\"\n        );\n        return rETH.getExchangeRate();\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/RgtTempPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title Temporary RGT Price Oracle pegged to TRIBE price * exchange rate (26.705673430).\n * @notice Returns prices for RGT based on the TRIBE price * `EXCHANGE_RATE`.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract RgtTempPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice RGT token address.\n     */\n    address public constant RGT = 0xD291E7a03283640FDc51b121aC401383A46cC623;\n\n    /**\n     * @notice TRIBE token address.\n     */\n    address public constant TRIBE = 0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B;\n\n    /**\n     * @notice Multiplier applied to RGT before converting to TRIBE scaled by 1e9.\n     */\n    uint256 public constant EXCHANGE_RATE = 26705673430;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(token == RGT, \"Invalid token passed to RGTTempPriceOracle.\");\n        return\n            EXCHANGE_RATE.mul(BasePriceOracle(msg.sender).price(TRIBE)).div(\n                1e9\n            ); // EXCHANGE_RATE is scaled by 1e9\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/SaddleLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/saddle/ISwap.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title SaddleLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice SaddleLpTokenPriceOracle is a price oracle for Saddle LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract SaddleLpTokenPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n     * @return Price denominated in ETH (scaled by 1e18).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Saddle, with 18 decimals of precision.\n     * Based on: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken The LP token contract address for price retrieval.\n     */\n    function _price(address lpToken) internal view returns (uint256) {\n        address pool = poolOf[lpToken];\n        require(pool != address(0), \"LP token is not registered.\");\n        address[] memory tokens = underlyingTokens[lpToken];\n        uint256 minPx = uint256(-1);\n        uint256 n = tokens.length;\n\n        for (uint256 i = 0; i < n; i++) {\n            address ulToken = tokens[i];\n            uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n            if (tokenPx < minPx) minPx = tokenPx;\n        }\n\n        require(\n            minPx != uint256(-1),\n            \"No minimum underlying token price found.\"\n        );\n        return minPx.mul(ISwap(pool).getVirtualPrice()).div(1e18); // Use min underlying token prices\n    }\n\n    /**\n     * @dev Maps Saddle LP token addresses to underlying token addresses.\n     */\n    mapping(address => address[]) public underlyingTokens;\n\n    /**\n     * @dev Maps Saddle LP token addresses to pool addresses.\n     */\n    mapping(address => address) public poolOf;\n\n    /**\n     * @dev Register the pool given LP token address and set the pool info.\n     * Based on: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n     * @param lpToken LP token to find the corresponding pool.\n     */\n    function registerPool(address lpToken) external {\n        address pool = poolOf[lpToken];\n        require(pool == address(0), \"This LP token is already registered.\");\n        pool = OwnableUpgradeable(lpToken).owner();\n        require(\n            pool != address(0),\n            \"No corresponding pool found for this LP token.\"\n        );\n        poolOf[lpToken] = pool;\n\n        for (uint256 i = 0; i < 32; i++) {\n            try ISwap(pool).getToken(uint8(i)) returns (\n                address underlyingToken\n            ) {\n                underlyingTokens[lpToken].push(underlyingToken);\n            } catch {\n                require(i > 0, \"Failed to get tokens underlying Saddle pool.\");\n                break;\n            }\n        }\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/StakedFodlPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/fodl/FodlStake.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title StakedFodlPriceOracle\n * @notice Returns prices for staked FODL (xFODL).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedFodlPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        FodlStake stakedFodl = FodlStake(token);\n        IERC20Upgradeable fodl = stakedFodl.fodlToken();\n        uint256 fodlEthPrice = BasePriceOracle(msg.sender).price(address(fodl));\n        return\n            fodl.balanceOf(token).mul(fodlEthPrice).div(\n                stakedFodl.totalSupply()\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/StakedSdtPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/stakedao/Sanctuary.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title StakedSdtPriceOracle\n * @notice Returns prices for Staked SDT (xSDT).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        Sanctuary sanctuary = Sanctuary(token);\n        IERC20Upgradeable sdt = sanctuary.sdt();\n        uint256 sdtEthPrice = BasePriceOracle(msg.sender).price(address(sdt));\n        return\n            sdt.balanceOf(token).mul(sdtEthPrice).div(sanctuary.totalSupply());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/StakedSpellPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/abracadabra/sSpell.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title StakedSpellPriceOracle\n * @notice Returns prices for Staked Spell Tokens (sSPELL).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSpellPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        sSpellV1 sSpell = sSpellV1(token);\n        IERC20Upgradeable spell = sSpell.token();\n        uint256 spellEthPrice = BasePriceOracle(msg.sender).price(\n            address(spell)\n        );\n        return\n            spell.balanceOf(token).mul(spellEthPrice).div(sSpell.totalSupply());\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/SushiBarPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/sushi/SushiBar.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title SushiBarPriceOracle\n * @notice Returns prices for SushiBar (xSUSHI).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        SushiBar sushiBar = SushiBar(token);\n        IERC20Upgradeable sushi = sushiBar.sushi();\n        uint256 sushiEthPrice = BasePriceOracle(msg.sender).price(\n            address(sushi)\n        );\n        return\n            sushi.balanceOf(token).mul(sushiEthPrice).div(\n                sushiBar.totalSupply()\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/SynthetixPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/synthetix/AddressResolver.sol\";\nimport \"../external/synthetix/ExchangeRates.sol\";\nimport \"../external/synthetix/ISynth.sol\";\nimport \"../external/synthetix/MixinResolver.sol\";\nimport \"../external/synthetix/Proxy.sol\";\n\n/**\n * @title SynthetixPriceOracle\n * @notice Returns prices for Synths from Synthetix's official `ExchangeRates` contract.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixPriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        underlying = Proxy(underlying).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `resolver` and `currencyKey`\n        ExchangeRates exchangeRates = ExchangeRates(\n            MixinResolver(underlying).resolver().requireAndGetAddress(\n                \"ExchangeRates\",\n                \"Failed to get Synthetix's ExchangeRates contract address.\"\n            )\n        );\n        return\n            exchangeRates\n                .effectiveValue(\n                    ISynth(underlying).currencyKey(),\n                    baseUnit,\n                    \"ETH\"\n                )\n                .mul(1e18)\n                .div(baseUnit);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/TemplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/temple/ITempleTreasury.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title TemplePriceOracle\n * @notice Returns on-chain IV price for temple\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n */\ncontract TemplePriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Temple treasury address.\n     */\n    ITempleTreasury public constant TREASURY =\n        ITempleTreasury(0x22c2fE05f55F81Bf32310acD9a7C51c4d7b4e443);\n\n    /**\n     * @notice Temple token address.\n     */\n    address public constant TEMPLE = 0x470EBf5f030Ed85Fc1ed4C2d36B9DD02e77CF1b7;\n\n    /**\n     * @dev The token (FRAX) on which to base IV (its price must be available via `msg.sender`).\n     */\n    address public constant baseToken =\n        0x853d955aCEf822Db058eb8505911ED77F175b99e;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(TEMPLE),\n            \"Invalid token passed to TemplePriceOracle\"\n        );\n        (uint256 stablec, uint256 temple) = TREASURY.intrinsicValueRatio(); // IV price is stablec / temple\n        return\n            stablec.mul(BasePriceOracle(msg.sender).price(baseToken)).div(\n                temple\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/TokemakPoolTAssetPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/tokemak/ILiquidityPool.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title TokemakPoolTAssetPriceOracle\n * @notice Returns prices for Tokenmak pools (tAssets).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract TokemakPoolTAssetPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        return\n            BasePriceOracle(msg.sender).price(\n                address(ILiquidityPool(token).underlyer())\n            );\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title UniswapLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract UniswapLpTokenPriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH contract address.\n     */\n    address private constant WETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @notice Get the LP token price price for an underlying token address.\n     * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying) external view returns (uint256) {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n     */\n    function _price(address token) internal view virtual returns (uint256) {\n        IUniswapV2Pair pair = IUniswapV2Pair(token);\n        uint256 totalSupply = pair.totalSupply();\n        if (totalSupply == 0) return 0;\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n        uint256 token0FairPrice = token0 == WETH_ADDRESS\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(token0).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(token0).decimals())\n            );\n        uint256 token1FairPrice = token1 == WETH_ADDRESS\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(token1).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(token1).decimals())\n            );\n\n        // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\n        uint256 sqrtK = sqrt(reserve0.mul(reserve1)).mul(2**112).div(\n            totalSupply\n        );\n        return\n            sqrtK\n                .mul(2)\n                .mul(sqrt(token0FairPrice))\n                .div(2**56)\n                .mul(sqrt(token1FairPrice))\n                .div(2**56);\n    }\n\n    /**\n     * @dev Fast square root function.\n     * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n     * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n     */\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapTwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\nimport \"./UniswapTwapPriceOracleRoot.sol\";\n\n/**\n * @title UniswapTwapPriceOracle\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Constructor that sets the UniswapV2Factory.\n     */\n    constructor(address _rootOracle, address _uniswapV2Factory) public {\n        rootOracle = UniswapTwapPriceOracleRoot(_rootOracle);\n        uniswapV2Factory = _uniswapV2Factory;\n    }\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev UniswapTwapPriceOracleRoot contract address.\n     */\n    UniswapTwapPriceOracleRoot public immutable rootOracle;\n\n    /**\n     * @dev UniswapV2Factory contract address.\n     */\n    address public immutable uniswapV2Factory;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH) return 1e18;\n\n        // Return root oracle ERC20/ETH TWAP\n        return rootOracle.price(underlying, uniswapV2Factory);\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapTwapPriceOracleRoot.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title UniswapTwapPriceOracleRoot\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleRoot {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint256) {\n        uint256 length = observationCount[pair];\n        require(length > 0, \"No length-1 TWAP observation.\");\n        Observation memory lastObservation = observations[pair][\n            (length - 1) % OBSERVATION_BUFFER\n        ];\n        if (lastObservation.timestamp > now - MIN_TWAP_TIME) {\n            require(length > 1, \"No length-2 TWAP observation.\");\n            lastObservation = observations[pair][\n                (length - 2) % OBSERVATION_BUFFER\n            ];\n        }\n        uint256 elapsedTime = now - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n        uint256 currPx0Cumu = currentPx0Cumu(pair);\n        return\n            (currPx0Cumu - lastObservation.priceCumulative) /\n            (now - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint256) {\n        uint256 length = observationCount[pair];\n        require(length > 0, \"No length-1 TWAP observation.\");\n        Observation memory lastObservation = observations[pair][\n            (length - 1) % OBSERVATION_BUFFER\n        ];\n        if (lastObservation.timestamp > now - MIN_TWAP_TIME) {\n            require(length > 1, \"No length-2 TWAP observation.\");\n            lastObservation = observations[pair][\n                (length - 2) % OBSERVATION_BUFFER\n            ];\n        }\n        uint256 elapsedTime = now - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n        uint256 currPx1Cumu = currentPx1Cumu(pair);\n        return\n            (currPx1Cumu - lastObservation.priceCumulative) /\n            (now - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair)\n        internal\n        view\n        returns (uint256 px0Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != now) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair)\n        internal\n        view\n        returns (uint256 px1Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` given `factory`.\n     */\n    function price(address underlying, address factory)\n        external\n        view\n        returns (uint256)\n    {\n        // Return ERC20/ETH TWAP\n        address pair = IUniswapV2Factory(factory).getPair(underlying, WETH);\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return\n            (underlying < WETH ? price0TWAP(pair) : price1TWAP(pair))\n                .div(2**56)\n                .mul(baseUnit)\n                .div(2**56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Struct for cumulative price observations.\n     */\n    struct Observation {\n        uint32 timestamp;\n        uint256 priceCumulative;\n    }\n\n    /**\n     * @dev Length after which observations roll over to index 0.\n     */\n    uint8 public constant OBSERVATION_BUFFER = 4;\n\n    /**\n     * @dev Total observation count for each pair.\n     */\n    mapping(address => uint256) public observationCount;\n\n    /**\n     * @dev Array of cumulative price observations for each pair.\n     */\n    mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\n\n    /// @notice Get pairs for token combinations.\n    function pairsFor(\n        address[] calldata tokenA,\n        address[] calldata tokenB,\n        address factory\n    ) external view returns (address[] memory) {\n        require(\n            tokenA.length > 0 && tokenA.length == tokenB.length,\n            \"Token array lengths must be equal and greater than 0.\"\n        );\n        address[] memory pairs = new address[](tokenA.length);\n        for (uint256 i = 0; i < tokenA.length; i++)\n            pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\n        return pairs;\n    }\n\n    /// @notice Check which of multiple pairs are workable/updatable.\n    function workable(\n        address[] calldata pairs,\n        uint256[] calldata minPeriods,\n        uint256[] calldata deviationThresholds\n    ) external view returns (bool[] memory) {\n        require(\n            pairs.length > 0 &&\n                pairs.length == minPeriods.length &&\n                pairs.length == deviationThresholds.length,\n            \"Array lengths must be equal and greater than 0.\"\n        );\n        bool[] memory answers = new bool[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++)\n            answers[i] = _workable(\n                pairs[i],\n                minPeriods[i],\n                deviationThresholds[i]\n            );\n        return answers;\n    }\n\n    /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\n    function _workable(\n        address pair,\n        uint256 minPeriod,\n        uint256 deviationThreshold\n    ) internal view returns (bool) {\n        // Workable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied\n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        if (observationCount[pair] <= 0) return true;\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        return\n            (block.timestamp -\n                observations[pair][\n                    (observationCount[pair] - 1) % OBSERVATION_BUFFER\n                ].timestamp) >\n            (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\n            lastTime !=\n            observations[pair][\n                (observationCount[pair] - 1) % OBSERVATION_BUFFER\n            ].timestamp &&\n            _deviation(pair) >= deviationThreshold;\n    }\n\n    /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\n    function _deviation(address pair) internal view returns (uint256) {\n        // Get token base unit\n        address token0 = IUniswapV2Pair(pair).token0();\n        bool useToken0Price = token0 != WETH;\n        address underlying = useToken0Price\n            ? token0\n            : IUniswapV2Pair(pair).token1();\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n\n        // Get TWAP price\n        uint256 twapPrice = (\n            useToken0Price ? price0TWAP(pair) : price1TWAP(pair)\n        ).div(2**56).mul(baseUnit).div(2**56); // Scaled by 1e18, not 2 ** 112\n\n        // Get spot price\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair)\n            .getReserves();\n        uint256 spotPrice = useToken0Price\n            ? reserve1.mul(baseUnit).div(reserve0)\n            : reserve0.mul(baseUnit).div(reserve1);\n\n        // Get ratio and return deviation\n        uint256 ratio = spotPrice.mul(1e18).div(twapPrice);\n        return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\n    }\n\n    /// @dev Internal function to check if a pair is updatable at all.\n    function _updateable(address pair) internal view returns (bool) {\n        // Updateable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        return\n            observationCount[pair] <= 0 ||\n            (block.timestamp -\n                observations[pair][\n                    (observationCount[pair] - 1) % OBSERVATION_BUFFER\n                ].timestamp) >\n            MIN_TWAP_TIME;\n    }\n\n    /// @notice Update one pair.\n    function update(address pair) external {\n        require(_update(pair), \"Failed to update pair.\");\n    }\n\n    /// @notice Update multiple pairs at once.\n    function update(address[] calldata pairs) external {\n        bool worked = false;\n        for (uint256 i = 0; i < pairs.length; i++)\n            if (_update(pairs[i])) worked = true;\n        require(worked, \"No pairs can be updated (yet).\");\n    }\n\n    /// @dev Internal function to update a single pair.\n    function _update(address pair) internal returns (bool) {\n        // Check if workable\n        if (!_updateable(pair)) return false;\n\n        // Get cumulative price(s): don't waste gas on storing reverse prices of WETH-based pairs\n        uint256 priceCumulative;\n        if (IUniswapV2Pair(pair).token0() == WETH)\n            priceCumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n        else if (IUniswapV2Pair(pair).token1() == WETH)\n            priceCumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        else revert(\"Only WETH-based pairs are supported.\");\n\n        // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        observations[pair][\n            observationCount[pair] % OBSERVATION_BUFFER\n        ] = Observation(lastTime, priceCumulative);\n        observationCount[pair]++;\n        return true;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapTwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\nimport \"./UniswapTwapPriceOracleV2Root.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2 is\n    Initializable,\n    PriceOracle,\n    BasePriceOracle\n{\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev UniswapTwapPriceOracleV2Root contract address.\n     */\n    UniswapTwapPriceOracleV2Root public rootOracle;\n\n    /**\n     * @dev UniswapV2Factory contract address.\n     */\n    address public uniswapV2Factory;\n\n    /**\n     * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\n     */\n    address public baseToken;\n\n    /**\n     * @dev Constructor that sets the UniswapTwapPriceOracleV2Root, UniswapV2Factory, and base token.\n     */\n    function initialize(\n        address _rootOracle,\n        address _uniswapV2Factory,\n        address _baseToken\n    ) external initializer {\n        require(\n            _rootOracle != address(0),\n            \"UniswapTwapPriceOracleV2Root not defined.\"\n        );\n        require(\n            _uniswapV2Factory != address(0),\n            \"UniswapV2Factory not defined.\"\n        );\n        rootOracle = UniswapTwapPriceOracleV2Root(_rootOracle);\n        uniswapV2Factory = _uniswapV2Factory;\n        baseToken = _baseToken == address(0) ? address(WETH) : _baseToken;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Internal function returning the price in ETH of `underlying`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH) return 1e18;\n\n        // Return root oracle ERC20/ETH TWAP\n        uint256 twap = rootOracle.price(\n            underlying,\n            baseToken,\n            uniswapV2Factory\n        );\n        return\n            baseToken == address(WETH)\n                ? twap\n                : twap.mul(BasePriceOracle(msg.sender).price(baseToken)).div(\n                    10**uint256(ERC20Upgradeable(baseToken).decimals())\n                );\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapTwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./UniswapTwapPriceOracleV2.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Factory\n * @notice Deploys and catalogs UniswapTwapPriceOracleV2 contracts.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Factory {\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev `UniswapTwapPriceOracleV2Root` contract address.\n     */\n    address public immutable rootOracle;\n\n    /**\n     * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\n     */\n    address public immutable logic;\n\n    /**\n     * @notice Maps `UniswapV2Factory` contracts to base tokens to `UniswapTwapPriceOracleV2` contract addresses.\n     */\n    mapping(address => mapping(address => UniswapTwapPriceOracleV2))\n        public oracles;\n\n    /**\n     * @dev Constructor that sets the `UniswapTwapPriceOracleV2Root` and `UniswapTwapPriceOracleV2` implementation contract.\n     */\n    constructor(address _rootOracle, address _logic) public {\n        require(\n            _rootOracle != address(0),\n            \"UniswapTwapPriceOracleV2Root not defined.\"\n        );\n        require(\n            _logic != address(0),\n            \"UniswapTwapPriceOracleV2 implementation/logic contract not defined.\"\n        );\n        rootOracle = _rootOracle;\n        logic = _logic;\n    }\n\n    /**\n     * @notice Deploys a `UniswapTwapPriceOracleV2`.\n     * @param uniswapV2Factory The `UniswapV2Factory` contract of the pairs for which this oracle will be used.\n     * @param baseToken The base token of the pairs for which this oracle will be used.\n     */\n    function deploy(address uniswapV2Factory, address baseToken)\n        external\n        returns (address)\n    {\n        // Input validation\n        if (baseToken == address(0)) baseToken = address(WETH);\n\n        // Return existing oracle if present\n        address currentOracle = address(oracles[uniswapV2Factory][baseToken]);\n        if (currentOracle != address(0)) return currentOracle;\n\n        // Deploy oracle\n        bytes32 salt = keccak256(abi.encodePacked(uniswapV2Factory, baseToken));\n        address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\n        UniswapTwapPriceOracleV2(oracle).initialize(\n            rootOracle,\n            uniswapV2Factory,\n            baseToken\n        );\n\n        // Set oracle in state\n        oracles[uniswapV2Factory][baseToken] = UniswapTwapPriceOracleV2(oracle);\n\n        // Return oracle address\n        return oracle;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapTwapPriceOracleV2Root.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Root\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Root {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Minimum TWAP interval.\n     */\n    uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n    /**\n     * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price0.\n     */\n    function price0TWAP(address pair) internal view returns (uint256) {\n        uint256 length = observationCount[pair];\n        require(length > 0, \"No length-1 TWAP observation.\");\n        Observation memory lastObservation = observations[pair][\n            (length - 1) % OBSERVATION_BUFFER\n        ];\n        if (lastObservation.timestamp > now - MIN_TWAP_TIME) {\n            require(length > 1, \"No length-2 TWAP observation.\");\n            lastObservation = observations[pair][\n                (length - 2) % OBSERVATION_BUFFER\n            ];\n        }\n        uint256 elapsedTime = now - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n        uint256 currPx0Cumu = currentPx0Cumu(pair);\n        return\n            (currPx0Cumu - lastObservation.price0Cumulative) /\n            (now - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The pair to query for price1.\n     */\n    function price1TWAP(address pair) internal view returns (uint256) {\n        uint256 length = observationCount[pair];\n        require(length > 0, \"No length-1 TWAP observation.\");\n        Observation memory lastObservation = observations[pair][\n            (length - 1) % OBSERVATION_BUFFER\n        ];\n        if (lastObservation.timestamp > now - MIN_TWAP_TIME) {\n            require(length > 1, \"No length-2 TWAP observation.\");\n            lastObservation = observations[pair][\n                (length - 2) % OBSERVATION_BUFFER\n            ];\n        }\n        uint256 elapsedTime = now - lastObservation.timestamp;\n        require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n        uint256 currPx1Cumu = currentPx1Cumu(pair);\n        return\n            (currPx1Cumu - lastObservation.price1Cumulative) /\n            (now - lastObservation.timestamp); // overflow is desired\n    }\n\n    /**\n     * @dev Return the current price0 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price0 cumulative value.\n     */\n    function currentPx0Cumu(address pair)\n        internal\n        view\n        returns (uint256 px0Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != now) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Return the current price1 cumulative value on Uniswap.\n     * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n     * @param pair The uniswap pair to query for price1 cumulative value.\n     */\n    function currentPx1Cumu(address pair)\n        internal\n        view\n        returns (uint256 px1Cumu)\n    {\n        uint32 currTime = uint32(now);\n        px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n        (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(\n            pair\n        ).getReserves();\n        if (lastTime != currTime) {\n            uint32 timeElapsed = currTime - lastTime; // overflow is desired\n            px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n        }\n    }\n\n    /**\n     * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\n     */\n    function price(\n        address underlying,\n        address baseToken,\n        address factory\n    ) external view returns (uint256) {\n        // Return ERC20/ETH TWAP\n        address pair = IUniswapV2Factory(factory).getPair(\n            underlying,\n            baseToken\n        );\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return\n            (underlying < baseToken ? price0TWAP(pair) : price1TWAP(pair))\n                .div(2**56)\n                .mul(baseUnit)\n                .div(2**56); // Scaled by 1e18, not 2 ** 112\n    }\n\n    /**\n     * @dev Struct for cumulative price observations.\n     */\n    struct Observation {\n        uint32 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    /**\n     * @dev Length after which observations roll over to index 0.\n     */\n    uint8 public constant OBSERVATION_BUFFER = 4;\n\n    /**\n     * @dev Total observation count for each pair.\n     */\n    mapping(address => uint256) public observationCount;\n\n    /**\n     * @dev Array of cumulative price observations for each pair.\n     */\n    mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\n\n    /// @notice Get pairs for token combinations.\n    function pairsFor(\n        address[] calldata tokenA,\n        address[] calldata tokenB,\n        address factory\n    ) external view returns (address[] memory) {\n        require(\n            tokenA.length > 0 && tokenA.length == tokenB.length,\n            \"Token array lengths must be equal and greater than 0.\"\n        );\n        address[] memory pairs = new address[](tokenA.length);\n        for (uint256 i = 0; i < tokenA.length; i++)\n            pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\n        return pairs;\n    }\n\n    /// @notice Check which of multiple pairs are workable/updatable.\n    function workable(\n        address[] calldata pairs,\n        address[] calldata baseTokens,\n        uint256[] calldata minPeriods,\n        uint256[] calldata deviationThresholds\n    ) external view returns (bool[] memory) {\n        require(\n            pairs.length > 0 &&\n                pairs.length == baseTokens.length &&\n                pairs.length == minPeriods.length &&\n                pairs.length == deviationThresholds.length,\n            \"Array lengths must be equal and greater than 0.\"\n        );\n        bool[] memory answers = new bool[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++)\n            answers[i] = _workable(\n                pairs[i],\n                baseTokens[i],\n                minPeriods[i],\n                deviationThresholds[i]\n            );\n        return answers;\n    }\n\n    /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\n    function _workable(\n        address pair,\n        address baseToken,\n        uint256 minPeriod,\n        uint256 deviationThreshold\n    ) internal view returns (bool) {\n        // Workable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied\n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        if (observationCount[pair] <= 0) return true;\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        return\n            (block.timestamp -\n                observations[pair][\n                    (observationCount[pair] - 1) % OBSERVATION_BUFFER\n                ].timestamp) >\n            (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\n            lastTime !=\n            observations[pair][\n                (observationCount[pair] - 1) % OBSERVATION_BUFFER\n            ].timestamp &&\n            _deviation(pair, baseToken) >= deviationThreshold;\n    }\n\n    /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\n    function _deviation(address pair, address baseToken)\n        internal\n        view\n        returns (uint256)\n    {\n        // Get token base unit\n        address token0 = IUniswapV2Pair(pair).token0();\n        bool useToken0Price = token0 != baseToken;\n        address underlying = useToken0Price\n            ? token0\n            : IUniswapV2Pair(pair).token1();\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n\n        // Get TWAP price\n        uint256 twapPrice = (\n            useToken0Price ? price0TWAP(pair) : price1TWAP(pair)\n        ).div(2**56).mul(baseUnit).div(2**56); // Scaled by 1e18, not 2 ** 112\n\n        // Get spot price\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair)\n            .getReserves();\n        uint256 spotPrice = useToken0Price\n            ? reserve1.mul(baseUnit).div(reserve0)\n            : reserve0.mul(baseUnit).div(reserve1);\n\n        // Get ratio and return deviation\n        uint256 ratio = spotPrice.mul(1e18).div(twapPrice);\n        return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\n    }\n\n    /// @dev Internal function to check if a pair is updatable at all.\n    function _updateable(address pair) internal view returns (bool) {\n        // Updateable if:\n        // 1) We have no observations\n        // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\n        // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        return\n            observationCount[pair] <= 0 ||\n            (block.timestamp -\n                observations[pair][\n                    (observationCount[pair] - 1) % OBSERVATION_BUFFER\n                ].timestamp) >\n            MIN_TWAP_TIME;\n    }\n\n    /// @notice Update one pair.\n    function update(address pair) external {\n        require(_update(pair), \"Failed to update pair.\");\n    }\n\n    /// @notice Update multiple pairs at once.\n    function update(address[] calldata pairs) external {\n        bool worked = false;\n        for (uint256 i = 0; i < pairs.length; i++)\n            if (_update(pairs[i])) worked = true;\n        require(worked, \"No pairs can be updated (yet).\");\n    }\n\n    /// @dev Internal function to update a single pair.\n    function _update(address pair) internal returns (bool) {\n        // Check if workable\n        if (!_updateable(pair)) return false;\n\n        // Get cumulative price(s)\n        uint256 price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        uint256 price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n        (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n        observations[pair][\n            observationCount[pair] % OBSERVATION_BUFFER\n        ] = Observation(lastTime, price0Cumulative, price1Cumulative);\n        observationCount[pair]++;\n        return true;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapV3TwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title UniswapV3TwapPriceOracle\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V3 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3TwapPriceOracle is BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Ideal TWAP interval.\n     */\n    uint32 public constant TWAP_PERIOD = 10 minutes;\n\n    /**\n     * @dev IUniswapV3Factory contract address.\n     */\n    address public immutable uniswapV3Factory;\n\n    /**\n     * @dev Uniswap V3 fee tier.\n     */\n    uint24 public immutable feeTier;\n\n    /**\n     * @dev Returns the price in ETH of `underlying` given `factory`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH) return 1e18;\n\n        // Return token/WETH TWAP\n        address pool = IUniswapV3Factory(uniswapV3Factory).getPool(\n            underlying,\n            WETH,\n            feeTier\n        );\n        (int24 arithmeticMeanTick, ) = OracleLibrary.consult(pool, TWAP_PERIOD);\n        uint128 baseUnit = 10**uint128(ERC20Upgradeable(underlying).decimals());\n        return\n            OracleLibrary.getQuoteAtTick(\n                arithmeticMeanTick,\n                baseUnit,\n                underlying,\n                WETH\n            );\n    }\n\n    /**\n     * @dev Constructor that sets the UniswapV3Factory and fee tier.\n     */\n    constructor(address _uniswapV3Factory, uint24 _feeTier) public {\n        require(_uniswapV3Factory != address(0));\n        require(_feeTier == 500 || _feeTier == 3000 || _feeTier == 10000);\n        uniswapV3Factory = _uniswapV3Factory;\n        feeTier = _feeTier;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapV3TwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title UniswapV3TwapPriceOracleV2\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V3 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3TwapPriceOracleV2 is\n    Initializable,\n    PriceOracle,\n    BasePriceOracle\n{\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Ideal TWAP interval.\n     */\n    uint32 public constant TWAP_PERIOD = 10 minutes;\n\n    /**\n     * @dev IUniswapV3Factory contract address.\n     */\n    address public uniswapV3Factory;\n\n    /**\n     * @dev Uniswap V3 fee tier.\n     */\n    uint24 public feeTier;\n\n    /**\n     * @dev Base token (WETH by default).\n     */\n    address public baseToken;\n\n    /**\n     * @dev Constructor that sets the UniswapV3Factory and fee tier.\n     */\n    function initialize(\n        address _uniswapV3Factory,\n        uint24 _feeTier,\n        address _baseToken\n    ) external initializer {\n        require(\n            _uniswapV3Factory != address(0),\n            \"UniswapV3Factory not defined.\"\n        );\n        require(\n            _feeTier == 500 || _feeTier == 3000 || _feeTier == 10000,\n            \"Invalid fee tier.\"\n        );\n        uniswapV3Factory = _uniswapV3Factory;\n        feeTier = _feeTier;\n        baseToken = _baseToken == address(0) ? address(WETH) : _baseToken;\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` given `factory`.\n     */\n    function _price(address underlying) internal view returns (uint256) {\n        // Return 1e18 for WETH\n        if (underlying == WETH) return 1e18;\n\n        // Return token/WETH TWAP\n        address pool = IUniswapV3Factory(uniswapV3Factory).getPool(\n            underlying,\n            baseToken,\n            feeTier\n        );\n        (int24 arithmeticMeanTick, ) = OracleLibrary.consult(pool, TWAP_PERIOD);\n        uint128 baseUnit = 10**uint128(ERC20Upgradeable(underlying).decimals());\n        uint256 quote = OracleLibrary.getQuoteAtTick(\n            arithmeticMeanTick,\n            baseUnit,\n            underlying,\n            baseToken\n        );\n        return\n            baseToken == address(WETH)\n                ? quote\n                : quote.mul(BasePriceOracle(msg.sender).price(baseToken)).div(\n                    10**uint256(ERC20Upgradeable(baseToken).decimals())\n                );\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return 1e18 for ETH\n        if (cToken.isCEther()) return 1e18;\n\n        // Get underlying ERC20 token address\n        address underlying = CErc20(address(cToken)).underlying();\n\n        // Get price, format, and return\n        uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n        return _price(underlying).mul(1e18).div(baseUnit);\n    }\n\n    /**\n     * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/UniswapV3TwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./UniswapV3TwapPriceOracleV2.sol\";\n\n/**\n * @title UniswapV3TwapPriceOracleV2Factory\n * @notice Deploys and catalogs UniswapV3TwapPriceOracleV2 contracts.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3TwapPriceOracleV2Factory {\n    /**\n     * @dev WETH token contract address.\n     */\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /**\n     * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\n     */\n    address public immutable logic;\n\n    /**\n     * @notice Maps `UniswapV3Factory` contracts to fee tiers to base tokens to `UniswapV3TwapPriceOracleV2` contract addresses.\n     */\n    mapping(address => mapping(uint256 => mapping(address => UniswapV3TwapPriceOracleV2)))\n        public oracles;\n\n    /**\n     * @notice Constructor that stores the UniswapV3TwapPriceOracleV2 implementation/logic contract.\n     * @param _logic The `UniswapV3TwapPriceOracleV2` implementation contract.\n     */\n    constructor(address _logic) public {\n        require(\n            _logic != address(0),\n            \"UniswapV3TwapPriceOracleV2 implementation/logic contract not defined.\"\n        );\n        logic = _logic;\n    }\n\n    /**\n     * @notice Deploys a `UniswapV3TwapPriceOracleV2`.\n     * @param uniswapV3Factory The `UniswapV3Factory` contract of the pairs for which this oracle will be used.\n     * @param feeTier The fee tier of the pairs for which this oracle will be used.\n     * @param baseToken The base token of the pairs for which this oracle will be used.\n     */\n    function deploy(\n        address uniswapV3Factory,\n        uint24 feeTier,\n        address baseToken\n    ) external returns (address) {\n        // Input validation\n        if (baseToken == address(0)) baseToken = address(WETH);\n\n        // Return existing oracle if present\n        address currentOracle = address(\n            oracles[uniswapV3Factory][feeTier][baseToken]\n        );\n        if (currentOracle != address(0)) return currentOracle;\n\n        // Deploy oracle\n        bytes32 salt = keccak256(\n            abi.encodePacked(uniswapV3Factory, feeTier, baseToken)\n        );\n        address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\n        UniswapV3TwapPriceOracleV2(oracle).initialize(\n            uniswapV3Factory,\n            feeTier,\n            baseToken\n        );\n\n        // Set oracle in state\n        oracles[uniswapV3Factory][feeTier][\n            baseToken\n        ] = UniswapV3TwapPriceOracleV2(oracle);\n\n        // Return oracle address\n        return oracle;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/VoltPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/volt/IVoltOracle.sol\";\nimport \"../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title VoltPriceOracle\n * @notice Returns prices for VOLT based on the Volt oracle price.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract VoltPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice VOLT token address.\n     */\n    address public VOLT = 0x559eBC30b0E58a45Cc9fF573f77EF1e5eb1b3E18;\n\n    /**\n     * @notice Volt oracle address.\n     */\n    IVoltOracle voltOracle =\n        IVoltOracle(0x84dc71500D504163A87756dB6368CC8bB654592f);\n\n    /**\n     * @notice Chainlink ETH/USD price feed contracts.\n     */\n    AggregatorV3Interface public constant ETH_USD_PRICE_FEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(VOLT),\n            \"Invalid token passed to VoltPriceOracle.\"\n        );\n\n        uint256 voltUsdPrice = voltOracle.currPegPrice();\n        // Get ETH/USD price from Chainlink\n        (, int256 ethUsdPrice, , , ) = ETH_USD_PRICE_FEED.latestRoundData();\n        return\n            uint256(voltUsdPrice).mul(1e26).div(1e18).div(uint256(ethUsdPrice));\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/WSSquidPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/olympus/sOlympus.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title WSSquidPriceOracle\n * @notice Returns prices for wsSQUID based on the SQUID price and the sSQUID index.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSSquidPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice sSQUID token address.\n     */\n    sOlympus public SSQUID =\n        sOlympus(0x9d49BfC921F36448234b0eFa67B5f91b3C691515);\n\n    /**\n     * @notice wsSQUID token address.\n     */\n    address public WSSQUID = 0x3b1388eB39c72D2145f092C01067C02Bb627d4BE;\n\n    /**\n     * @notice SQUID token address.\n     */\n    address public SQUID = 0x21ad647b8F4Fe333212e735bfC1F36B4941E6Ad2;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == WSSQUID,\n            \"Invalid token passed to WSSquidPriceOracle.\"\n        );\n        return\n            SSQUID.index().mul(BasePriceOracle(msg.sender).price(SQUID)).div(\n                1e9\n            ); // 1e9 = SQUID base unit and therefore also sSQUID/SQUID index base unit\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/WSTEthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/lido/IWstETH.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title WSTEthPriceOracle\n * @notice Returns prices for wstETH.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    address public stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        return\n            IWstETH(token)\n                .stEthPerToken()\n                .mul(BasePriceOracle(msg.sender).price(stETH))\n                .div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/WXBtrflyPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/redacted/wxBTRFLY.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title WXBtrflyPriceOracle\n * @notice Returns prices for wxBTRFLY based on the BTRFLY price and the sBTRFLY index.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WXBtrflyPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice wxBTRFLY token address.\n     */\n    wxBTRFLY public WXBTRFLY =\n        wxBTRFLY(0x186E55C0BebD2f69348d94C4A27556d93C5Bd36C);\n\n    /**\n     * @notice BTRFLY token address.\n     */\n    address public BTRFLY = 0xC0d4Ceb216B3BA9C3701B291766fDCbA977ceC3A;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        require(\n            token == address(WXBTRFLY),\n            \"Invalid token passed to WXBtrflyPriceOracle.\"\n        );\n        return\n            WXBTRFLY\n                .realIndex()\n                .mul(BasePriceOracle(msg.sender).price(BTRFLY))\n                .div(1e9); // 1e9 = BTRFLY base unit and therefore also xBTRFLY/BTRFLY index base unit\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/XVaultPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/nftx/INFTXInventoryStaking.sol\";\nimport \"../external/nftx/INFTXVaultUpgradeable.sol\";\nimport \"../external/nftx/IXTokenUpgradeable.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title NFTX xVault Price Oracle\n * @notice Returns prices for NFTX xAssets based on the underlying price and the xAssest Share Value.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract XVaultPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice INFTXInventoryStaking contract address.\n     */\n    INFTXInventoryStaking staking =\n        INFTXInventoryStaking(0x3E135c3E981fAe3383A5aE0d323860a34CfAB893);\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        IXTokenUpgradeable xToken = IXTokenUpgradeable(token);\n        INFTXVaultUpgradeable vault = INFTXVaultUpgradeable(xToken.baseToken());\n        require(\n            address(vault) != address(0),\n            \"Invalid token passed to XVaultPriceOracle\"\n        );\n        return\n            staking\n                .xTokenShareValue(vault.vaultId())\n                .mul(BasePriceOracle(msg.sender).price(address(vault)))\n                .div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/YVaultV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/yearn/IVault.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title YVaultV1PriceOracle\n * @notice Returns prices for V1 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV1PriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        // Get price of token underlying yVault\n        IVault yVault = IVault(token);\n        address underlyingToken = yVault.token();\n        uint256 underlyingPrice = underlyingToken ==\n            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(underlyingToken);\n\n        // yVault/ETH = yVault/token * token/ETH\n        // Return value = yVault/ETH scaled by 1e18\n        // `getPricePerFullShare` = yVault/token scaled by 1e18\n        // `underlyingPrice` = token/ETH scaled by 1e18\n        // Return value = `pricePerShare` * `underlyingPrice` / 1e18\n        return yVault.getPricePerFullShare().mul(underlyingPrice).div(1e18);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/YVaultV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"../external/yearn/IVaultV2.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title YVaultV2PriceOracle\n * @notice Returns prices for V2 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV2PriceOracle is PriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get price of token underlying yVault\n        IVaultV2 yVault = IVaultV2(CErc20(address(cToken)).underlying());\n        address underlyingToken = yVault.token();\n        uint256 underlyingPrice = underlyingToken ==\n            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n            ? 1e18\n            : BasePriceOracle(msg.sender).price(underlyingToken);\n\n        // yVault/ETH = yVault/token * token/ETH\n        // Return value = yVault/ETH scaled by 1e(36 - yVault decimals)\n        // `pricePerShare` = yVault/token scaled by 1e(yVault decimals)\n        // `underlyingPrice` = token/ETH scaled by 1e18\n        // Return value = `pricePerShare` * `underlyingPrice` * 1e(18 - (yVault decimals * 2))\n        uint256 baseUnit = 10**uint256(yVault.decimals());\n        return\n            yVault\n                .pricePerShare()\n                .mul(underlyingPrice)\n                .div(baseUnit)\n                .mul(1e18)\n                .div(baseUnit);\n    }\n}\n"
    },
    "contracts/rari-fuse/src/oracles/ZeroPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title ZeroPriceOracle\n * @notice Returns prices set to ~ 0\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ZeroPriceOracle is PriceOracle, BasePriceOracle {\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     * @param underlying The underlying token address for which to get the price.\n     * @return Price denominated in ETH (scaled by 1e18)\n     */\n    function price(address underlying)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _price(underlying);\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address underlying = CErc20(address(cToken)).underlying();\n        // Comptroller needs prices to be scaled by 1e(36 - decimals)\n        // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n        return\n            _price(underlying).mul(1e18).div(\n                10**uint256(ERC20Upgradeable(underlying).decimals())\n            );\n    }\n\n    /**\n     * @notice Fetches the token/ETH price, with 18 decimals of precision.\n     */\n    function _price(address token) internal view returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/rari-fuse/src/utils/InitializableClones.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title InitializableClones\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice Deploys minimal proxy contracts (known as \"clones\") and initializes them.\n */\ncontract InitializableClones {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Event emitted when a clone is deployed.\n     */\n    event Deployed(address instance);\n\n    /**\n     * @dev Deploys, initializes, and returns the address of a clone that mimics the behaviour of `master`.\n     */\n    function clone(address master, bytes memory initializer)\n        external\n        returns (address instance)\n    {\n        instance = ClonesUpgradeable.clone(master);\n        instance.functionCall(initializer, \"Failed to initialize clone.\");\n        emit Deployed(instance);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}